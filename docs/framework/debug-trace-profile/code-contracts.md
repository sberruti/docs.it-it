---
title: Contratti di codice
ms.date: 09/05/2018
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Code contracts
ms.assetid: 84526045-496f-489d-8517-a258cf76f040
ms.openlocfilehash: b60f992cf9d934ed622c89a49c491a80377fb6fe
ms.sourcegitcommit: 9c54866bcbdc49dbb981dd55be9bbd0443837aa2
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 02/14/2020
ms.locfileid: "77216708"
---
# <a name="code-contracts"></a><span data-ttu-id="c500d-102">Contratti di codice</span><span class="sxs-lookup"><span data-stu-id="c500d-102">Code Contracts</span></span>

<span data-ttu-id="c500d-103">I contratti di codice consentono di specificare precondizioni, postcondizioni e invarianti dell'oggetto nel codice.</span><span class="sxs-lookup"><span data-stu-id="c500d-103">Code contracts provide a way to specify preconditions, postconditions, and object invariants in your code.</span></span> <span data-ttu-id="c500d-104">Le precondizioni sono requisiti da soddisfare quando si accede a un metodo o a una proprietà.</span><span class="sxs-lookup"><span data-stu-id="c500d-104">Preconditions are requirements that must be met when entering a method or property.</span></span> <span data-ttu-id="c500d-105">Le postcondizioni descrivono le aspettative al momento dell'uscita dal codice del metodo o della proprietà.</span><span class="sxs-lookup"><span data-stu-id="c500d-105">Postconditions describe expectations at the time the method or property code exits.</span></span> <span data-ttu-id="c500d-106">Le invarianti dell'oggetto descrivono lo stato previsto per una classe in stato integro.</span><span class="sxs-lookup"><span data-stu-id="c500d-106">Object invariants describe the expected state for a class that is in a good state.</span></span>

<span data-ttu-id="c500d-107">I contratti di codice includono classi che consentono di contrassegnare il codice, un analizzatore statico per l'analisi in fase di compilazione e un analizzatore di runtime.</span><span class="sxs-lookup"><span data-stu-id="c500d-107">Code contracts include classes for marking your code, a static analyzer for compile-time analysis, and a runtime analyzer.</span></span> <span data-ttu-id="c500d-108">Le classi per i contratti di codice sono disponibili nello spazio dei nomi <xref:System.Diagnostics.Contracts>.</span><span class="sxs-lookup"><span data-stu-id="c500d-108">The classes for code contracts can be found in the <xref:System.Diagnostics.Contracts> namespace.</span></span>

<span data-ttu-id="c500d-109">I vantaggi dei contratti di codice includono:</span><span class="sxs-lookup"><span data-stu-id="c500d-109">The benefits of code contracts include the following:</span></span>

- <span data-ttu-id="c500d-110">Test migliorati: i contratti di codice consentono la verifica statica, il controllo di runtime e la generazione di documentazione.</span><span class="sxs-lookup"><span data-stu-id="c500d-110">Improved testing: Code contracts provide static contract verification, runtime checking, and documentation generation.</span></span>

- <span data-ttu-id="c500d-111">Strumenti di test automatici: è possibile usare i contratti di codice per generare unit test più significativi eliminando gli argomenti di test inutili che non soddisfano le precondizioni.</span><span class="sxs-lookup"><span data-stu-id="c500d-111">Automatic testing tools: You can use code contracts to generate more meaningful unit tests by filtering out meaningless test arguments that do not satisfy preconditions.</span></span>

- <span data-ttu-id="c500d-112">Verifica statica: lo strumento di controllo statico può rilevare eventuali violazioni dei contratti senza eseguire il programma.</span><span class="sxs-lookup"><span data-stu-id="c500d-112">Static verification: The static checker can decide whether there are any contract violations without running the program.</span></span> <span data-ttu-id="c500d-113">Verifica la presenza di contratti impliciti, ad esempio dereferenziazioni null e limiti di matrici, e di contratti espliciti.</span><span class="sxs-lookup"><span data-stu-id="c500d-113">It checks for implicit contracts, such as null dereferences and array bounds, and explicit contracts.</span></span>

- <span data-ttu-id="c500d-114">Documentazione di riferimento: il generatore di documentazione integra i file di documentazione XML esistenti con le informazioni sul contratto.</span><span class="sxs-lookup"><span data-stu-id="c500d-114">Reference documentation: The documentation generator augments existing XML documentation files with contract information.</span></span> <span data-ttu-id="c500d-115">Sono anche presenti fogli di stile utilizzabili con [Sandcastle](https://github.com/EWSoftware/SHFB) in modo che nelle pagine della documentazione generate siano contenute sezioni relative ai contratti.</span><span class="sxs-lookup"><span data-stu-id="c500d-115">There are also style sheets that can be used with [Sandcastle](https://github.com/EWSoftware/SHFB) so that the generated documentation pages have contract sections.</span></span>

<span data-ttu-id="c500d-116">I contratti possono essere usati immediatamente da tutti i linguaggi di .NET Framework; non è necessario scrivere un parser o un compilatore speciale.</span><span class="sxs-lookup"><span data-stu-id="c500d-116">All .NET Framework languages can immediately take advantage of contracts; you do not have to write a special parser or compiler.</span></span> <span data-ttu-id="c500d-117">Un componente aggiuntivo di Visual Studio consente di specificare il livello di analisi dei contratti di codice da eseguire.</span><span class="sxs-lookup"><span data-stu-id="c500d-117">A Visual Studio add-in lets you specify the level of code contract analysis to be performed.</span></span> <span data-ttu-id="c500d-118">Gli analizzatori possono confermare che i contratti sono formalmente corretti (controllo del tipo e risoluzione dei nomi) e possono produrre un form compilato dei contratti nel formato MSIL (Microsoft Intermediate Language).</span><span class="sxs-lookup"><span data-stu-id="c500d-118">The analyzers can confirm that the contracts are well-formed (type checking and name resolution) and can produce a compiled form of the contracts in Microsoft intermediate language (MSIL) format.</span></span> <span data-ttu-id="c500d-119">La funzionalità di creazione dei contratti in Visual Studio consente di usare IntelliSense standard fornito dallo strumento.</span><span class="sxs-lookup"><span data-stu-id="c500d-119">Authoring contracts in Visual Studio lets you take advantage of the standard IntelliSense provided by the tool.</span></span>

<span data-ttu-id="c500d-120">La maggior parte dei metodi nella classe dei contratti sono compilati in modo condizionale; in altre parole, il compilatore genera chiamate a questi metodi solo quando si definisce un simbolo speciale, CONTRACTS_FULL, tramite la direttiva `#define`.</span><span class="sxs-lookup"><span data-stu-id="c500d-120">Most methods in the contract class are conditionally compiled; that is, the compiler emits calls to these methods only when  you define a special symbol, CONTRACTS_FULL, by using the `#define` directive.</span></span> <span data-ttu-id="c500d-121">CONTRACTS_FULL consente di scrivere contratti nel codice senza usare le direttive `#ifdef`; è possibile produrre build diverse, alcune con contratti e altre senza.</span><span class="sxs-lookup"><span data-stu-id="c500d-121">CONTRACTS_FULL lets you write contracts in your code without using `#ifdef` directives; you can produce different builds, some with contracts, and some without.</span></span>

<span data-ttu-id="c500d-122">Per gli strumenti e le istruzioni dettagliate per l'uso dei contratti di codice, vedere [contratti di codice](https://marketplace.visualstudio.com/items?itemName=RiSEResearchinSoftwareEngineering.CodeContractsforNET) nel sito di Visual Studio Marketplace.</span><span class="sxs-lookup"><span data-stu-id="c500d-122">For tools and detailed instructions for using code contracts, see [Code Contracts](https://marketplace.visualstudio.com/items?itemName=RiSEResearchinSoftwareEngineering.CodeContractsforNET) on the Visual Studio marketplace site.</span></span>

## <a name="preconditions"></a><span data-ttu-id="c500d-123">Preconditions</span><span class="sxs-lookup"><span data-stu-id="c500d-123">Preconditions</span></span>

<span data-ttu-id="c500d-124">È possibile esprimere delle precondizioni usando il metodo <xref:System.Diagnostics.Contracts.Contract.Requires%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c500d-124">You can express preconditions by using the <xref:System.Diagnostics.Contracts.Contract.Requires%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c500d-125">Le precondizioni specificano lo stato nel momento in cui viene richiamato un metodo.</span><span class="sxs-lookup"><span data-stu-id="c500d-125">Preconditions specify state when a method is invoked.</span></span> <span data-ttu-id="c500d-126">In genere, vengono usate per specificare valori di parametro validi.</span><span class="sxs-lookup"><span data-stu-id="c500d-126">They are generally used to specify valid parameter values.</span></span> <span data-ttu-id="c500d-127">Tutti i membri menzionati nelle precondizioni devono essere accessibili almeno quanto il metodo stesso; in caso contrario, la precondizione potrebbe non essere compresa da tutti i chiamanti di un metodo.</span><span class="sxs-lookup"><span data-stu-id="c500d-127">All members that are mentioned in preconditions must be at least as accessible as the method itself; otherwise, the precondition might not be understood by all callers of a method.</span></span> <span data-ttu-id="c500d-128">La condizione non deve avere effetti collaterali.</span><span class="sxs-lookup"><span data-stu-id="c500d-128">The condition must have no side-effects.</span></span> <span data-ttu-id="c500d-129">Il comportamento in fase di esecuzione delle precondizioni con errori è determinato dall'analizzatore di runtime.</span><span class="sxs-lookup"><span data-stu-id="c500d-129">The run-time behavior of failed preconditions is determined by the runtime analyzer.</span></span>

<span data-ttu-id="c500d-130">Ad esempio, la precondizione seguente indica che il parametro `x` non deve essere null.</span><span class="sxs-lookup"><span data-stu-id="c500d-130">For example, the following precondition expresses that parameter `x` must be non-null.</span></span>

```csharp
Contract.Requires(x != null);
```

<span data-ttu-id="c500d-131">Se il codice deve generare una particolare eccezione in caso di errore di una precondizione, è possibile usare l'overload generico di <xref:System.Diagnostics.Contracts.Contract.Requires%2A> come descritto di seguito.</span><span class="sxs-lookup"><span data-stu-id="c500d-131">If your code must throw a particular exception on failure of a precondition, you can use the generic overload of <xref:System.Diagnostics.Contracts.Contract.Requires%2A> as follows.</span></span>

```csharp
Contract.Requires<ArgumentNullException>(x != null, "x");
```

### <a name="legacy-requires-statements"></a><span data-ttu-id="c500d-132">Istruzioni Requires legacy</span><span class="sxs-lookup"><span data-stu-id="c500d-132">Legacy Requires Statements</span></span>

<span data-ttu-id="c500d-133">La maggior parte del codice contiene la convalida dei parametri sotto forma di codice `if`-`then`-`throw`.</span><span class="sxs-lookup"><span data-stu-id="c500d-133">Most code contains some parameter validation in the form of `if`-`then`-`throw` code.</span></span> <span data-ttu-id="c500d-134">Gli strumenti dei contratti riconoscono queste istruzioni come precondizioni nei casi seguenti:</span><span class="sxs-lookup"><span data-stu-id="c500d-134">The contract tools recognize these statements as preconditions in the following cases:</span></span>

- <span data-ttu-id="c500d-135">Le istruzioni vengono visualizzate prima di qualsiasi altra istruzione in un metodo.</span><span class="sxs-lookup"><span data-stu-id="c500d-135">The statements appear before any other statements in a method.</span></span>

- <span data-ttu-id="c500d-136">L'intero set di istruzioni è seguito da una chiamata al metodo <xref:System.Diagnostics.Contracts.Contract> esplicita, ad esempio una chiamata al metodo <xref:System.Diagnostics.Contracts.Contract.Requires%2A>, <xref:System.Diagnostics.Contracts.Contract.Ensures%2A>, <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A> o <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A>.</span><span class="sxs-lookup"><span data-stu-id="c500d-136">The entire set of such statements is followed by an explicit <xref:System.Diagnostics.Contracts.Contract> method call, such as a call to the <xref:System.Diagnostics.Contracts.Contract.Requires%2A>, <xref:System.Diagnostics.Contracts.Contract.Ensures%2A>, <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>, or <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> method.</span></span>

<span data-ttu-id="c500d-137">Quando le istruzioni `if`-`then`-`throw` vengono visualizzate in questo formato, gli strumenti le riconoscono come istruzioni `requires` legacy.</span><span class="sxs-lookup"><span data-stu-id="c500d-137">When `if`-`then`-`throw` statements appear in this form, the tools recognize them as legacy `requires` statements.</span></span> <span data-ttu-id="c500d-138">Se la sequenza `if`-`then`-`throw` non è seguita da altri contratti, terminare il codice con il metodo <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c500d-138">If no other contracts follow the `if`-`then`-`throw` sequence, end the code with the <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A?displayProperty=nameWithType> method.</span></span>

```csharp
if (x == null) throw new ...
Contract.EndContractBlock(); // All previous "if" checks are preconditions
```

<span data-ttu-id="c500d-139">La condizione nel test precedente è una precondizione negata.</span><span class="sxs-lookup"><span data-stu-id="c500d-139">Note that the condition in the preceding test is a negated precondition.</span></span> <span data-ttu-id="c500d-140">La precondizione effettiva verrebbe `x != null`. Una precondizione negata è altamente limitata: deve essere scritta come mostrato nell'esempio precedente; ovvero non deve contenere clausole `else` e il corpo della clausola `then` deve essere una singola istruzione `throw`.</span><span class="sxs-lookup"><span data-stu-id="c500d-140">(The actual precondition would be `x != null`.) A negated precondition is highly restricted: It must be written as shown in the previous example; that is, it should contain no `else` clauses, and the body of the `then` clause must be a single `throw` statement.</span></span> <span data-ttu-id="c500d-141">Il test `if` è soggetto a regole di purezza e visibilità (vedere [Linee guida di utilizzo](#usage_guidelines)), ma l'espressione `throw` è soggetta solo a regole di purezza.</span><span class="sxs-lookup"><span data-stu-id="c500d-141">The `if` test is subject to both purity and visibility rules (see [Usage Guidelines](#usage_guidelines)), but the `throw` expression is subject only to purity rules.</span></span> <span data-ttu-id="c500d-142">Tuttavia, il tipo dell'eccezione generata deve essere visibile quanto il metodo in cui si verifica il contratto.</span><span class="sxs-lookup"><span data-stu-id="c500d-142">However, the type of the exception thrown must be as visible as the method in which the contract occurs.</span></span>

## <a name="postconditions"></a><span data-ttu-id="c500d-143">Postconditions</span><span class="sxs-lookup"><span data-stu-id="c500d-143">Postconditions</span></span>

<span data-ttu-id="c500d-144">Le postcondizioni sono contratti per lo stato di un metodo nel momento in cui termina.</span><span class="sxs-lookup"><span data-stu-id="c500d-144">Postconditions are contracts for the state of a method when it terminates.</span></span> <span data-ttu-id="c500d-145">La postcondizione viene controllata appena prima dell'uscita da un metodo.</span><span class="sxs-lookup"><span data-stu-id="c500d-145">The postcondition is checked just before exiting a method.</span></span> <span data-ttu-id="c500d-146">Il comportamento in fase di esecuzione delle postcondizioni con errori viene determinato dall'analizzatore di runtime.</span><span class="sxs-lookup"><span data-stu-id="c500d-146">The run-time behavior of failed postconditions is determined by the runtime analyzer.</span></span>

<span data-ttu-id="c500d-147">Diversamente dalle precondizioni, le postcondizioni possono fare riferimento a membri con visibilità inferiore.</span><span class="sxs-lookup"><span data-stu-id="c500d-147">Unlike preconditions, postconditions may reference members with less visibility.</span></span> <span data-ttu-id="c500d-148">Un client potrebbe non essere in grado di comprendere o usare alcune delle informazioni espresse da una postcondizione tramite uno stato privato, tuttavia ciò non influisce sulla capacità del client di usare il metodo correttamente.</span><span class="sxs-lookup"><span data-stu-id="c500d-148">A client may not be able to understand or make use of some of the information expressed by a postcondition using private state, but this does not affect the client's ability to use the method correctly.</span></span>

### <a name="standard-postconditions"></a><span data-ttu-id="c500d-149">Postcondizioni standard</span><span class="sxs-lookup"><span data-stu-id="c500d-149">Standard Postconditions</span></span>

<span data-ttu-id="c500d-150">È possibile esprimere postcondizioni standard con il metodo <xref:System.Diagnostics.Contracts.Contract.Ensures%2A>.</span><span class="sxs-lookup"><span data-stu-id="c500d-150">You can express standard postconditions by using the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> method.</span></span> <span data-ttu-id="c500d-151">Le postcondizioni esprimono una condizione che deve essere `true` quando il metodo termina regolarmente.</span><span class="sxs-lookup"><span data-stu-id="c500d-151">Postconditions express a condition that must be `true` upon normal termination of the method.</span></span>

```csharp
Contract.Ensures(this.F > 0);
```

### <a name="exceptional-postconditions"></a><span data-ttu-id="c500d-152">Postcondizioni eccezionali</span><span class="sxs-lookup"><span data-stu-id="c500d-152">Exceptional Postconditions</span></span>

<span data-ttu-id="c500d-153">Le postcondizioni eccezionali sono postcondizioni che devono essere `true` quando una particolare eccezione viene generata da un metodo.</span><span class="sxs-lookup"><span data-stu-id="c500d-153">Exceptional postconditions are postconditions that should be `true` when a particular exception is thrown by a method.</span></span> <span data-ttu-id="c500d-154">È possibile specificare queste postcondizioni tramite il metodo <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A?displayProperty=nameWithType>, come mostrato nell'esempio seguente.</span><span class="sxs-lookup"><span data-stu-id="c500d-154">You can specify these postconditions by using the <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A?displayProperty=nameWithType> method, as the following example shows.</span></span>

```csharp
Contract.EnsuresOnThrow<T>(this.F > 0);
```

<span data-ttu-id="c500d-155">L'argomento è la condizione che deve essere `true` quando viene generata un'eccezione che corrisponde a un sottotipo di `T`.</span><span class="sxs-lookup"><span data-stu-id="c500d-155">The argument is the condition that must be `true` whenever an exception that is a subtype of `T` is thrown.</span></span>

<span data-ttu-id="c500d-156">Alcuni tipi di eccezione sono difficili da usare in una postcondizione eccezionale.</span><span class="sxs-lookup"><span data-stu-id="c500d-156">There are some exception types that are difficult to use in an exceptional postcondition.</span></span> <span data-ttu-id="c500d-157">Ad esempio, l'uso del tipo <xref:System.Exception> per `T` richiede che il metodo garantisca la condizione indipendentemente dal tipo di eccezione generato, anche se si tratta di un overflow dello stack o di un'altra eccezione impossibile da controllare.</span><span class="sxs-lookup"><span data-stu-id="c500d-157">For example, using the type <xref:System.Exception> for `T` requires the method to guarantee the condition regardless of the type of exception that is thrown, even if it is a stack overflow or other impossible-to-control exception.</span></span> <span data-ttu-id="c500d-158">Le postcondizioni eccezionali devono essere usate solo per eccezioni specifiche che potrebbero essere generate quando viene chiamato un membro, ad esempio quando viene generata un'eccezione <xref:System.InvalidTimeZoneException> per una chiamata al metodo <xref:System.TimeZoneInfo>.</span><span class="sxs-lookup"><span data-stu-id="c500d-158">You should use exceptional postconditions only for specific exceptions that might be thrown when a member is called, for example, when an <xref:System.InvalidTimeZoneException> is thrown for a <xref:System.TimeZoneInfo> method call.</span></span>

### <a name="special-postconditions"></a><span data-ttu-id="c500d-159">Postcondizioni speciali</span><span class="sxs-lookup"><span data-stu-id="c500d-159">Special Postconditions</span></span>

<span data-ttu-id="c500d-160">I seguenti metodi possono essere usati solo all'interno di postcondizioni:</span><span class="sxs-lookup"><span data-stu-id="c500d-160">The following methods may be used only within postconditions:</span></span>

- <span data-ttu-id="c500d-161">È possibile fare riferimento ai valori restituiti dai metodi nelle postcondizioni usando l'espressione `Contract.Result<T>()`, dove `T` viene sostituito dal tipo restituito del metodo.</span><span class="sxs-lookup"><span data-stu-id="c500d-161">You can refer to method return values in postconditions by using the expression `Contract.Result<T>()`, where `T` is replaced by the return type of the method.</span></span> <span data-ttu-id="c500d-162">Quando il compilatore non è in grado di dedurre il tipo, è necessario fornirlo in modo esplicito.</span><span class="sxs-lookup"><span data-stu-id="c500d-162">When the compiler is unable to infer the type, you must explicitly provide it.</span></span> <span data-ttu-id="c500d-163">Il compilatore C#, ad esempio, non è in grado di dedurre i tipi per i metodi che non accettano argomenti, pertanto richiede la seguente postcondizione: `Contract.Ensures(0 <Contract.Result<int>())`. I metodi con un tipo restituito `void` non possono fare riferimento a `Contract.Result<T>()` nelle relative postcondizioni.</span><span class="sxs-lookup"><span data-stu-id="c500d-163">For example, the C# compiler is unable to infer types for methods that do not take any arguments, so it requires the following postcondition: `Contract.Ensures(0 <Contract.Result<int>())` Methods with a return type of `void` cannot refer to `Contract.Result<T>()` in their postconditions.</span></span>

- <span data-ttu-id="c500d-164">Un valore di prestato in una postcondizione fa riferimento al valore di un'espressione all'inizio di un metodo o di una proprietà.</span><span class="sxs-lookup"><span data-stu-id="c500d-164">A prestate value in a postcondition refers to the value of an expression at the start of a method or property.</span></span> <span data-ttu-id="c500d-165">Usa l'espressione `Contract.OldValue<T>(e)`, dove `T` è il tipo di `e`.</span><span class="sxs-lookup"><span data-stu-id="c500d-165">It uses the expression `Contract.OldValue<T>(e)`, where `T` is the type of `e`.</span></span> <span data-ttu-id="c500d-166">È possibile omettere l'argomento di tipo generico quando il compilatore è in grado di dedurre il tipo.</span><span class="sxs-lookup"><span data-stu-id="c500d-166">You can omit the generic type argument whenever the compiler is able to infer its type.</span></span> <span data-ttu-id="c500d-167">Ad esempio, il C# compilatore deduce sempre il tipo perché accetta un argomento. Esistono diverse restrizioni su ciò che può verificarsi in `e` e i contesti in cui può essere visualizzata un'espressione precedente.</span><span class="sxs-lookup"><span data-stu-id="c500d-167">(For example, the C# compiler always infers the type because it takes an argument.) There are several restrictions on what can occur in `e` and the contexts in which an old expression may appear.</span></span> <span data-ttu-id="c500d-168">Un'espressione Old non può contenere un'altra espressione Old.</span><span class="sxs-lookup"><span data-stu-id="c500d-168">An old expression cannot contain another old expression.</span></span> <span data-ttu-id="c500d-169">In particolare, un'espressione Old deve fare riferimento a un valore esistente nello stato di precondizione del metodo.</span><span class="sxs-lookup"><span data-stu-id="c500d-169">Most importantly, an old expression must refer to a value that existed in the method's precondition state.</span></span> <span data-ttu-id="c500d-170">In altre parole, deve essere un'espressione valutabile finché la precondizione del metodo resta `true`.</span><span class="sxs-lookup"><span data-stu-id="c500d-170">In other words, it must be an expression that can be evaluated as long as the method's precondition is `true`.</span></span> <span data-ttu-id="c500d-171">Di seguito sono riportate diverse istanze di questa regola.</span><span class="sxs-lookup"><span data-stu-id="c500d-171">Here are several instances of that rule.</span></span>

  - <span data-ttu-id="c500d-172">Il valore deve esistere nello stato di precondizione del metodo.</span><span class="sxs-lookup"><span data-stu-id="c500d-172">The value must exist in the method's precondition state.</span></span> <span data-ttu-id="c500d-173">Per fare riferimento a un campo in un oggetto, le precondizioni devono garantire che l'oggetto sia sempre non null.</span><span class="sxs-lookup"><span data-stu-id="c500d-173">In order to reference a field on an object, the preconditions must guarantee that the object is always non-null.</span></span>

  - <span data-ttu-id="c500d-174">Non è possibile fare riferimento al valore restituito del metodo in un'espressione Old:</span><span class="sxs-lookup"><span data-stu-id="c500d-174">You cannot refer to the method's return value in an old expression:</span></span>

      ```csharp
      Contract.OldValue(Contract.Result<int>() + x) // ERROR
      ```

  - <span data-ttu-id="c500d-175">Non è possibile fare riferimento a parametri `out` in un'espressione Old.</span><span class="sxs-lookup"><span data-stu-id="c500d-175">You cannot refer to `out` parameters in an old expression.</span></span>

  - <span data-ttu-id="c500d-176">Un'espressione Old non può dipendere dalla variabile associata di un quantificatore se l'intervallo del quantificatore dipende dal valore restituito del metodo:</span><span class="sxs-lookup"><span data-stu-id="c500d-176">An old expression cannot depend on the bound variable of a quantifier if the range of the quantifier depends on the return value of the method:</span></span>

      ```csharp
      Contract.ForAll(0, Contract.Result<int>(), i => Contract.OldValue(xs[i]) > 3); // ERROR
      ```

  - <span data-ttu-id="c500d-177">Un'espressione Old non può fare riferimento al parametro del delegato anonimo in una chiamata a <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> o <xref:System.Diagnostics.Contracts.Contract.Exists%2A> a meno che non venga usata come indicizzatore o argomento di una chiamata al metodo:</span><span class="sxs-lookup"><span data-stu-id="c500d-177">An old expression cannot refer to the parameter of the anonymous delegate in a <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> or <xref:System.Diagnostics.Contracts.Contract.Exists%2A> call unless it is used as an indexer or argument to a method call:</span></span>

      ```csharp
      Contract.ForAll(0, xs.Length, i => Contract.OldValue(xs[i]) > 3); // OK
      Contract.ForAll(0, xs.Length, i => Contract.OldValue(i) > 3); // ERROR
      ```

  - <span data-ttu-id="c500d-178">Un'espressione Old non può verificarsi nel corpo di un delegato anonimo se il valore dell'espressione dipende da uno dei parametri del delegato, a meno che quest'ultimo non sia un argomento del metodo <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> o <xref:System.Diagnostics.Contracts.Contract.Exists%2A>:</span><span class="sxs-lookup"><span data-stu-id="c500d-178">An old expression cannot occur in the body of an anonymous delegate if the value of the old expression depends on any of the parameters of the anonymous delegate, unless the anonymous delegate is an argument to the <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> or <xref:System.Diagnostics.Contracts.Contract.Exists%2A> method:</span></span>

      ```csharp
      Method(... (T t) => Contract.OldValue(... t ...) ...); // ERROR
      ```

  - <span data-ttu-id="c500d-179">I parametri `Out` presentano un problema in quanto i contratti vengono visualizzati prima del corpo del metodo e la maggior parte dei compilatori non consente riferimenti ai parametri `out` nelle postcondizioni.</span><span class="sxs-lookup"><span data-stu-id="c500d-179">`Out` parameters present a problem because contracts appear before the body of the method, and most compilers do not allow references to `out` parameters in postconditions.</span></span> <span data-ttu-id="c500d-180">Per risolvere il problema, la classe <xref:System.Diagnostics.Contracts.Contract> fornisce il metodo <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> che consente una postcondizione basata su un parametro `out`.</span><span class="sxs-lookup"><span data-stu-id="c500d-180">To solve this problem, the <xref:System.Diagnostics.Contracts.Contract> class provides the <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> method, which allows a postcondition based on an `out` parameter.</span></span>

      ```csharp
      public void OutParam(out int x)
      {
          Contract.Ensures(Contract.ValueAtReturn(out x) == 3);
          x = 3;
      }
      ```

      <span data-ttu-id="c500d-181">Come per il metodo <xref:System.Diagnostics.Contracts.Contract.OldValue%2A>, è possibile omettere il parametro di tipo generico quando il compilatore è in grado di dedurre il tipo.</span><span class="sxs-lookup"><span data-stu-id="c500d-181">As with the <xref:System.Diagnostics.Contracts.Contract.OldValue%2A> method, you can omit the generic type parameter whenever the compiler is able to infer its type.</span></span> <span data-ttu-id="c500d-182">Il rewriter del contratto sostituisce la chiamata al metodo con il valore del parametro `out`.</span><span class="sxs-lookup"><span data-stu-id="c500d-182">The contract rewriter replaces the method call with the value of the `out` parameter.</span></span> <span data-ttu-id="c500d-183">Il metodo <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> può essere visualizzato solo nelle postcondizioni.</span><span class="sxs-lookup"><span data-stu-id="c500d-183">The <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> method may appear only in postconditions.</span></span> <span data-ttu-id="c500d-184">L'argomento del metodo deve essere un parametro `out` o un campo del parametro `out` di una struttura.</span><span class="sxs-lookup"><span data-stu-id="c500d-184">The argument to the method must be an `out` parameter or a field of a structure `out` parameter.</span></span> <span data-ttu-id="c500d-185">Quest'ultimo è utile anche in caso di riferimento a campi nella postcondizione di un costruttore della struttura.</span><span class="sxs-lookup"><span data-stu-id="c500d-185">The latter is also useful when referring to fields in the postcondition of a structure constructor.</span></span>

      > [!NOTE]
      > <span data-ttu-id="c500d-186">Attualmente, gli strumenti di analisi dei contratti di codice non verificano se i parametri `out` vengono inizializzati correttamente e ne ignorano la menzione nella postcondizione.</span><span class="sxs-lookup"><span data-stu-id="c500d-186">Currently, the code contract analysis tools do not check whether `out` parameters are initialized properly and disregard their mention in the postcondition.</span></span> <span data-ttu-id="c500d-187">Quindi, nell'esempio precedente, se la riga dopo il contratto avesse usato il valore `x` anziché assegnare un numero intero, un compilatore non avrebbe generato l'errore corretto.</span><span class="sxs-lookup"><span data-stu-id="c500d-187">Therefore, in the previous example, if the line after the contract had used the value of `x` instead of assigning an integer to it, a compiler would not issue the correct error.</span></span> <span data-ttu-id="c500d-188">Tuttavia, in una build in cui il simbolo del preprocessore CONTRACTS_FULL non viene definito (ad esempio una build di rilascio), il compilatore genererà un errore.</span><span class="sxs-lookup"><span data-stu-id="c500d-188">However, on a build where the CONTRACTS_FULL preprocessor symbol is not defined (such asa release build), the compiler will issue an error.</span></span>

## <a name="invariants"></a><span data-ttu-id="c500d-189">Invarianti</span><span class="sxs-lookup"><span data-stu-id="c500d-189">Invariants</span></span>

<span data-ttu-id="c500d-190">Le invarianti dell'oggetto sono condizioni che devono essere true per ogni istanza di una classe quando l'oggetto è visibile a un client.</span><span class="sxs-lookup"><span data-stu-id="c500d-190">Object invariants are conditions that should be true for each instance of a class whenever that object is visible to a client.</span></span> <span data-ttu-id="c500d-191">Esprimono le condizioni con le quali l'oggetto viene considerato corretto.</span><span class="sxs-lookup"><span data-stu-id="c500d-191">They express the conditions under which the object is considered to be correct.</span></span>

<span data-ttu-id="c500d-192">I metodi invarianti vengono contrassegnati ai fini dell'identificazione con l'attributo <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute>.</span><span class="sxs-lookup"><span data-stu-id="c500d-192">The invariant methods are identified by being marked with the <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> attribute.</span></span> <span data-ttu-id="c500d-193">I metodi invarianti non devono contenere codice, fatta eccezione per una sequenza di chiamate al metodo <xref:System.Diagnostics.Contracts.Contract.Invariant%2A>, ognuna delle quali specifica una singola invariante, come mostrato nell'esempio seguente.</span><span class="sxs-lookup"><span data-stu-id="c500d-193">The invariant methods must contain no code except for a sequence of calls to the <xref:System.Diagnostics.Contracts.Contract.Invariant%2A> method, each of which specifies an individual invariant, as shown in the following example.</span></span>

```csharp
[ContractInvariantMethod]
protected void ObjectInvariant ()
{
    Contract.Invariant(this.y >= 0);
    Contract.Invariant(this.x > this.y);
    ...
}
```

<span data-ttu-id="c500d-194">Le invarianti vengono definite in modo condizionale dal simbolo del preprocessore CONTRACTS_FULL.</span><span class="sxs-lookup"><span data-stu-id="c500d-194">Invariants are conditionally defined by the CONTRACTS_FULL preprocessor symbol.</span></span> <span data-ttu-id="c500d-195">Durante il controllo in fase di esecuzione, le invarianti vengono controllate alla fine di ogni metodo pubblico.</span><span class="sxs-lookup"><span data-stu-id="c500d-195">During run-time checking, invariants are checked at the end of each public method.</span></span> <span data-ttu-id="c500d-196">Se un'invariante menziona un metodo pubblico nella stessa classe, il controllo dell'invariante che avverrebbe normalmente alla fine di tale metodo viene disabilitato.</span><span class="sxs-lookup"><span data-stu-id="c500d-196">If an invariant mentions a public method in the same class, the invariant check that would normally happen at the end of that public method is disabled.</span></span> <span data-ttu-id="c500d-197">Al contrario, il controllo viene eseguito solo alla fine della chiamata al metodo più esterna in quella classe.</span><span class="sxs-lookup"><span data-stu-id="c500d-197">Instead, the check occurs only at the end of the outermost method call to that class.</span></span> <span data-ttu-id="c500d-198">Ciò avviene anche se la classe viene immessa di nuovo a causa di una chiamata a un metodo in un'altra classe.</span><span class="sxs-lookup"><span data-stu-id="c500d-198">This also happens if the class is re-entered because of a call to a method on another class.</span></span> <span data-ttu-id="c500d-199">Gli invarianti non vengono controllati per un finalizzatore di oggetti e un'implementazione di <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c500d-199">Invariants are not checked for an object finalizer and an <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation.</span></span>

<a name="usage_guidelines"></a>

## <a name="usage-guidelines"></a><span data-ttu-id="c500d-200">Linee guida per l'uso</span><span class="sxs-lookup"><span data-stu-id="c500d-200">Usage Guidelines</span></span>

### <a name="contract-ordering"></a><span data-ttu-id="c500d-201">Ordine dei contratti</span><span class="sxs-lookup"><span data-stu-id="c500d-201">Contract Ordering</span></span>

<span data-ttu-id="c500d-202">La tabella seguente mostra l'ordine degli elementi da usare per la scrittura di contratti del metodo.</span><span class="sxs-lookup"><span data-stu-id="c500d-202">The following table shows the order of elements you should use when you write method contracts.</span></span>

|`If-then-throw statements`|<span data-ttu-id="c500d-203">Precondizioni pubbliche compatibili con le versioni precedenti</span><span class="sxs-lookup"><span data-stu-id="c500d-203">Backward-compatible public preconditions</span></span>|
|-|-|
|<xref:System.Diagnostics.Contracts.Contract.Requires%2A>|<span data-ttu-id="c500d-204">Tutte le precondizioni pubbliche.</span><span class="sxs-lookup"><span data-stu-id="c500d-204">All public preconditions.</span></span>|
|<xref:System.Diagnostics.Contracts.Contract.Ensures%2A>|<span data-ttu-id="c500d-205">Tutte le postcondizioni pubbliche (normali).</span><span class="sxs-lookup"><span data-stu-id="c500d-205">All public (normal) postconditions.</span></span>|
|<xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>|<span data-ttu-id="c500d-206">Tutte le postcondizioni pubbliche eccezionali.</span><span class="sxs-lookup"><span data-stu-id="c500d-206">All public exceptional postconditions.</span></span>|
|<xref:System.Diagnostics.Contracts.Contract.Ensures%2A>|<span data-ttu-id="c500d-207">Tutte le postcondizioni private/interne (normali).</span><span class="sxs-lookup"><span data-stu-id="c500d-207">All private/internal (normal) postconditions.</span></span>|
|<xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>|<span data-ttu-id="c500d-208">Tutte le postcondizioni private/interne eccezionali.</span><span class="sxs-lookup"><span data-stu-id="c500d-208">All private/internal exceptional postconditions.</span></span>|
|<xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A>|<span data-ttu-id="c500d-209">Se si usano le precondizioni di stile `if`-`then`-`throw` senza altri contratti, inserire una chiamata a <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> per indicare che tutti i controlli if precedenti sono precondizioni.</span><span class="sxs-lookup"><span data-stu-id="c500d-209">If using `if`-`then`-`throw` style preconditions without any other contracts, place a call to <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> to indicate that all previous if checks are preconditions.</span></span>|

<a name="purity"></a>

### <a name="purity"></a><span data-ttu-id="c500d-210">Purezza</span><span class="sxs-lookup"><span data-stu-id="c500d-210">Purity</span></span>

<span data-ttu-id="c500d-211">Tutti i metodi chiamati all'interno di un contratto devono essere puri; in altre parole, non devono aggiornare stati preesistenti.</span><span class="sxs-lookup"><span data-stu-id="c500d-211">All methods that are called within a contract must be pure; that is, they must not update any preexisting state.</span></span> <span data-ttu-id="c500d-212">Un metodo puro può modificare gli oggetti creati in seguito all'accesso al metodo stesso.</span><span class="sxs-lookup"><span data-stu-id="c500d-212">A pure method is allowed to modify objects that have been created after entry into the pure method.</span></span>

<span data-ttu-id="c500d-213">Gli strumenti dei contratti di codice presuppongono che i seguenti elementi di codice siano puri:</span><span class="sxs-lookup"><span data-stu-id="c500d-213">Code contract tools currently assume that the following code elements are pure:</span></span>

- <span data-ttu-id="c500d-214">Metodi contrassegnati con <xref:System.Diagnostics.Contracts.PureAttribute>.</span><span class="sxs-lookup"><span data-stu-id="c500d-214">Methods that are marked with the <xref:System.Diagnostics.Contracts.PureAttribute>.</span></span>

- <span data-ttu-id="c500d-215">Tipi contrassegnati con <xref:System.Diagnostics.Contracts.PureAttribute> (l'attributo si applica a tutti i metodi del tipo).</span><span class="sxs-lookup"><span data-stu-id="c500d-215">Types that are marked with the <xref:System.Diagnostics.Contracts.PureAttribute> (the attribute applies to all the type's methods).</span></span>

- <span data-ttu-id="c500d-216">Funzioni di accesso get della proprietà.</span><span class="sxs-lookup"><span data-stu-id="c500d-216">Property get accessors.</span></span>

- <span data-ttu-id="c500d-217">Operatori (metodi statici i cui nomi iniziano con "op" e che hanno uno o due parametri e un tipo restituito non void).</span><span class="sxs-lookup"><span data-stu-id="c500d-217">Operators (static methods whose names start with "op", and that have one or two parameters and a non-void return type).</span></span>

- <span data-ttu-id="c500d-218">Tutti i metodi il cui nome completo inizia con "System.Diagnostics.Contracts.Contract", "System.String", "System.IO.Path" o "System.Type".</span><span class="sxs-lookup"><span data-stu-id="c500d-218">Any method whose fully qualified name begins with "System.Diagnostics.Contracts.Contract", "System.String", "System.IO.Path", or "System.Type".</span></span>

- <span data-ttu-id="c500d-219">Tutti i delegati richiamati, purché al tipo del delegato venga attribuito <xref:System.Diagnostics.Contracts.PureAttribute>.</span><span class="sxs-lookup"><span data-stu-id="c500d-219">Any invoked delegate, provided that the delegate type itself is attributed with the <xref:System.Diagnostics.Contracts.PureAttribute>.</span></span> <span data-ttu-id="c500d-220">I tipi del delegato <xref:System.Predicate%601?displayProperty=nameWithType> e <xref:System.Comparison%601?displayProperty=nameWithType> sono considerati puri.</span><span class="sxs-lookup"><span data-stu-id="c500d-220">The delegate types <xref:System.Predicate%601?displayProperty=nameWithType> and <xref:System.Comparison%601?displayProperty=nameWithType> are considered pure.</span></span>

<a name="visibility"></a>

### <a name="visibility"></a><span data-ttu-id="c500d-221">Visibilità</span><span class="sxs-lookup"><span data-stu-id="c500d-221">Visibility</span></span>

<span data-ttu-id="c500d-222">Tutti i membri menzionati in un contratto devono essere visibili almeno quanto il metodo in cui vengono visualizzati.</span><span class="sxs-lookup"><span data-stu-id="c500d-222">All members mentioned in a contract must be at least as visible as the method in which they appear.</span></span> <span data-ttu-id="c500d-223">Un campo privato, ad esempio, non può essere menzionato in una precondizione per un metodo pubblico; i client non possono convalidare un simile contratto prima di chiamare il metodo.</span><span class="sxs-lookup"><span data-stu-id="c500d-223">For example, a private field cannot be mentioned in a precondition for a public method; clients cannot validate such a contract before they call the method.</span></span> <span data-ttu-id="c500d-224">Tuttavia, se il campo è contrassegnato con <xref:System.Diagnostics.Contracts.ContractPublicPropertyNameAttribute>, è esente da queste regole.</span><span class="sxs-lookup"><span data-stu-id="c500d-224">However, if the field is marked with the <xref:System.Diagnostics.Contracts.ContractPublicPropertyNameAttribute>, it is exempt from these rules.</span></span>

## <a name="example"></a><span data-ttu-id="c500d-225">Esempio</span><span class="sxs-lookup"><span data-stu-id="c500d-225">Example</span></span>

<span data-ttu-id="c500d-226">L'esempio seguente mostra l'uso dei contratti di codice.</span><span class="sxs-lookup"><span data-stu-id="c500d-226">The following example shows the use of code contracts.</span></span>

[!code-csharp[ContractExample#1](../../../samples/snippets/csharp/VS_Snippets_CLR/contractexample/cs/program.cs#1)]
[!code-vb[ContractExample#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/contractexample/vb/program.vb#1)]
