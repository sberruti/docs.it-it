---
title: releaseHandleFailed (MDA)
ms.date: 03/30/2017
helpviewer_keywords:
- managed debugging assistants (MDAs), handles
- release handle failed
- CriticalHandle class, run-time errors
- releaseHandleFailed MDA
- ReleaseHandle method
- SafeHandle class, run-time errors
- MDAs (managed debugging assistants), handles
ms.assetid: 44cd98ba-95e5-40a1-874d-e8e163612c51
ms.openlocfilehash: 265344cb100a41cde5443cd0914dc66271aabf93
ms.sourcegitcommit: 9c54866bcbdc49dbb981dd55be9bbd0443837aa2
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 02/14/2020
ms.locfileid: "77216120"
---
# <a name="releasehandlefailed-mda"></a><span data-ttu-id="e2380-102">releaseHandleFailed (MDA)</span><span class="sxs-lookup"><span data-stu-id="e2380-102">releaseHandleFailed MDA</span></span>
<span data-ttu-id="e2380-103">L'assistente al debug gestito `releaseHandleFailed` viene attivato per notificare agli sviluppatori quando il metodo <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> di una classe derivata da <xref:System.Runtime.InteropServices.SafeHandle> o <xref:System.Runtime.InteropServices.CriticalHandle> restituisce `false`.</span><span class="sxs-lookup"><span data-stu-id="e2380-103">The `releaseHandleFailed` managed debugging assistant (MDA) is activated is to notify developers when the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method of a class derived from <xref:System.Runtime.InteropServices.SafeHandle> or <xref:System.Runtime.InteropServices.CriticalHandle> returns `false`.</span></span>  
  
## <a name="symptoms"></a><span data-ttu-id="e2380-104">Sintomi</span><span class="sxs-lookup"><span data-stu-id="e2380-104">Symptoms</span></span>  
 <span data-ttu-id="e2380-105">Perdita di risorse o di memoria</span><span class="sxs-lookup"><span data-stu-id="e2380-105">Resource or memory leaks.</span></span>  <span data-ttu-id="e2380-106">Se si verifica un errore nel metodo <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> della classe che deriva da <xref:System.Runtime.InteropServices.SafeHandle> o <xref:System.Runtime.InteropServices.CriticalHandle>, è possibile che la risorsa incapsulata dalla classe non sia stata rilasciata o eliminata.</span><span class="sxs-lookup"><span data-stu-id="e2380-106">If the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method of the class deriving from <xref:System.Runtime.InteropServices.SafeHandle> or <xref:System.Runtime.InteropServices.CriticalHandle> fails, then the resource encapsulated by the class might not have been released or cleaned up.</span></span>  
  
## <a name="cause"></a><span data-ttu-id="e2380-107">Causa</span><span class="sxs-lookup"><span data-stu-id="e2380-107">Cause</span></span>  
 <span data-ttu-id="e2380-108">Se si creano classi che derivano da  <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> o <xref:System.Runtime.InteropServices.SafeHandle>, è necessario fornire l'implementazione del metodo <xref:System.Runtime.InteropServices.CriticalHandle>. Di conseguenza, le problematiche sono specifiche della singola risorsa.</span><span class="sxs-lookup"><span data-stu-id="e2380-108">Users must provide the implementation of the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method if they create classes that derive from <xref:System.Runtime.InteropServices.SafeHandle> or <xref:System.Runtime.InteropServices.CriticalHandle>; thus, the circumstances are specific to the individual resource.</span></span> <span data-ttu-id="e2380-109">È necessario, tuttavia, che siano rispettati i seguenti requisiti:</span><span class="sxs-lookup"><span data-stu-id="e2380-109">However, the requirements are as follows:</span></span>  
  
- <span data-ttu-id="e2380-110">I tipi <xref:System.Runtime.InteropServices.SafeHandle> e <xref:System.Runtime.InteropServices.CriticalHandle> rappresentano wrapper per risorse vitali di un processo.</span><span class="sxs-lookup"><span data-stu-id="e2380-110"><xref:System.Runtime.InteropServices.SafeHandle> and <xref:System.Runtime.InteropServices.CriticalHandle> types represent wrappers around vital process resources.</span></span> <span data-ttu-id="e2380-111">Una perdita di memoria può rendere il processo inusabile.</span><span class="sxs-lookup"><span data-stu-id="e2380-111">A memory leak would make the process unusable over time.</span></span>  
  
- <span data-ttu-id="e2380-112">È necessario che non si verifichi un errore durante l'esecuzione del metodo <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>.</span><span class="sxs-lookup"><span data-stu-id="e2380-112">The <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method must not fail to perform its function.</span></span> <span data-ttu-id="e2380-113">Una volta che il processo acquisisce una risorsa di questo tipo, per rilasciarla è necessario usare il metodo <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>.</span><span class="sxs-lookup"><span data-stu-id="e2380-113">Once the process acquires such a resource, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> is the only way to release it.</span></span> <span data-ttu-id="e2380-114">Un errore del metodo implica quindi una perdita di risorse.</span><span class="sxs-lookup"><span data-stu-id="e2380-114">Therefore, failure implies resource leaks.</span></span>  
  
- <span data-ttu-id="e2380-115">Qualsiasi errore che si verifica durante l'esecuzione del metodo <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>, impedendo il rilascio della risorsa, costituisce un bug nell'implementazione del metodo <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> stesso.</span><span class="sxs-lookup"><span data-stu-id="e2380-115">Any failure that does occur during the execution of <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>, impeding the release of the resource, is a bug in the implementation of the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method itself.</span></span> <span data-ttu-id="e2380-116">È compito del programmatore assicurare che il contratto venga rispettato, anche se durante l'esecuzione viene chiamato codice creato da altri utenti.</span><span class="sxs-lookup"><span data-stu-id="e2380-116">It is the responsibility of the programmer to ensure that the contract is fulfilled, even if that code calls code authored by someone else to perform its function.</span></span>  
  
## <a name="resolution"></a><span data-ttu-id="e2380-117">Risoluzione</span><span class="sxs-lookup"><span data-stu-id="e2380-117">Resolution</span></span>  
 <span data-ttu-id="e2380-118">È necessario esaminare il codice che usa lo specifico tipo <xref:System.Runtime.InteropServices.SafeHandle> (o <xref:System.Runtime.InteropServices.CriticalHandle>) che ha generato la notifica dell'assistente al debug gestito per individuare i punti in cui il valore dell'handle non elaborato viene estratto da <xref:System.Runtime.InteropServices.SafeHandle> e copiato in un'altra posizione.</span><span class="sxs-lookup"><span data-stu-id="e2380-118">The code that uses the specific <xref:System.Runtime.InteropServices.SafeHandle> (or <xref:System.Runtime.InteropServices.CriticalHandle>) type that raised the MDA notification should be reviewed, looking for places where the raw handle value is extracted from the <xref:System.Runtime.InteropServices.SafeHandle> and copied elsewhere.</span></span> <span data-ttu-id="e2380-119">Questa è la causa principale degli errori nelle implementazioni di <xref:System.Runtime.InteropServices.SafeHandle> o <xref:System.Runtime.InteropServices.CriticalHandle>, poiché l'uso del valore dell'handle non elaborato non viene più controllato da Common Language Runtime.</span><span class="sxs-lookup"><span data-stu-id="e2380-119">This is the usual cause of failures within <xref:System.Runtime.InteropServices.SafeHandle> or <xref:System.Runtime.InteropServices.CriticalHandle> implementations, because the usage of the raw handle value is then no longer tracked by the runtime.</span></span> <span data-ttu-id="e2380-120">Se successivamente la copia dell'handle non elaborato viene chiusa, può verificarsi un errore in una successiva chiamata a <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> poiché la chiusura viene tentata sullo stesso handle, ormai non più valido.</span><span class="sxs-lookup"><span data-stu-id="e2380-120">If the raw handle copy is subsequently closed, it can cause a later <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> call to fail because the close is attempted on the same handle, which is now invalid.</span></span>  
  
 <span data-ttu-id="e2380-121">Esistono alcune situazioni in cui può verificarsi la duplicazione di un handle non corretto:</span><span class="sxs-lookup"><span data-stu-id="e2380-121">There are a number of ways in which incorrect handle duplication can occur:</span></span>  
  
- <span data-ttu-id="e2380-122">Individuare le chiamate al metodo <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A>.</span><span class="sxs-lookup"><span data-stu-id="e2380-122">Look for calls to the <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> method.</span></span> <span data-ttu-id="e2380-123">Le chiamate a questo metodo dovrebbero essere molto rare e quelle eventualmente presenti dovrebbero essere circondate da chiamate ai metodi <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> e <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A>.</span><span class="sxs-lookup"><span data-stu-id="e2380-123">Calls to this method should be exceedingly rare, and any that you find should be surrounded by calls to the <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> and <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> methods.</span></span> <span data-ttu-id="e2380-124">Questi ultimi specificano l'area di codice in cui il valore dell'handle non elaborato può essere usato in maniera sicura.</span><span class="sxs-lookup"><span data-stu-id="e2380-124">These latter methods specify the region of code in which the raw handle value may be safely used.</span></span> <span data-ttu-id="e2380-125">Al di fuori di quest'area, o se il conteggio dei riferimenti non viene mai incrementato nella prima posizione, il valore dell'handle può essere invalidato in qualsiasi momento da una chiamata a <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> o <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> su un altro thread.</span><span class="sxs-lookup"><span data-stu-id="e2380-125">Outside this region, or if the reference count is never incremented in the first place, the handle value can be invalidated at any time by a call to <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> on another thread.</span></span> <span data-ttu-id="e2380-126">Una volta individuati tutti gli usi di <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A>, è necessario seguire il percorso dell'handle non elaborato per verificare che non venga passato a qualche componente che chiamerà `CloseHandle` o un altro metodo nativo di basso livello che causerà il rilascio dell'handle.</span><span class="sxs-lookup"><span data-stu-id="e2380-126">Once all uses of <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> have been tracked down, you should follow the path the raw handle takes to ensure it is not handed off to some component that will eventually call `CloseHandle` or another low-level native method that will release the handle.</span></span>  
  
- <span data-ttu-id="e2380-127">Verificare che l'handle non elaborato appartenga al codice usato per inizializzare <xref:System.Runtime.InteropServices.SafeHandle> con un valore di handle valido.</span><span class="sxs-lookup"><span data-stu-id="e2380-127">Ensure that the code that is used to initialize the <xref:System.Runtime.InteropServices.SafeHandle> with a valid raw handle value owns the handle.</span></span> <span data-ttu-id="e2380-128">Se si definisce un oggetto <xref:System.Runtime.InteropServices.SafeHandle> intorno a un handle che non appartiene al codice senza impostare il parametro `ownsHandle` su `false` nel costruttore base, sia <xref:System.Runtime.InteropServices.SafeHandle> che il vero proprietario dell'handle possono tentare di chiudere l'handle, generando quindi un errore in <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> se <xref:System.Runtime.InteropServices.SafeHandle> non riesce a chiudere l'handle prima del proprietario.</span><span class="sxs-lookup"><span data-stu-id="e2380-128">If you form a <xref:System.Runtime.InteropServices.SafeHandle> around a handle your code does not own without setting the `ownsHandle` parameter to `false` in the base constructor, then both the <xref:System.Runtime.InteropServices.SafeHandle> and the real handle owner can try to close the handle, leading to an error in <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> if the <xref:System.Runtime.InteropServices.SafeHandle> loses the race.</span></span>  
  
- <span data-ttu-id="e2380-129">Quando viene effettuato il marshalling di <xref:System.Runtime.InteropServices.SafeHandle> tra domini applicazione, verificare che la derivazione di <xref:System.Runtime.InteropServices.SafeHandle> usata sia stata contrassegnata come serializzabile.</span><span class="sxs-lookup"><span data-stu-id="e2380-129">When a <xref:System.Runtime.InteropServices.SafeHandle> is marshaled between application domains, confirm the <xref:System.Runtime.InteropServices.SafeHandle> derivation being used has been marked as serializable.</span></span> <span data-ttu-id="e2380-130">Nei rari casi in cui una classe derivata da <xref:System.Runtime.InteropServices.SafeHandle> sia stata resa serializzabile, tale classe deve implementare l'interfaccia <xref:System.Runtime.Serialization.ISerializable> o usare una delle altre tecniche che consentono di controllare manualmente il processo di serializzazione e deserializzazione.</span><span class="sxs-lookup"><span data-stu-id="e2380-130">In the rare cases where a class derived from <xref:System.Runtime.InteropServices.SafeHandle> has been made serializable, it should implement the <xref:System.Runtime.Serialization.ISerializable> interface or use one of the other techniques for controlling the serialization and deserialization process manually.</span></span> <span data-ttu-id="e2380-131">Questa operazione è necessaria poiché l'azione di serializzazione predefinita consiste nel creare un clone bit per bit del valore dell'handle non elaborato incluso e questo fa sì che due istanze di <xref:System.Runtime.InteropServices.SafeHandle> ritengano di essere proprietarie dello stesso handle.</span><span class="sxs-lookup"><span data-stu-id="e2380-131">This is required because the default serialization action is to create a bitwise clone of the enclosed raw handle value, resulting in two <xref:System.Runtime.InteropServices.SafeHandle> instances thinking they own the same handle.</span></span> <span data-ttu-id="e2380-132">A un certo punto entrambe tenteranno di chiamare <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> sullo stesso handle,</span><span class="sxs-lookup"><span data-stu-id="e2380-132">Both will try to call <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> on the same handle at some point.</span></span> <span data-ttu-id="e2380-133">ma ovviamente la seconda istanza di <xref:System.Runtime.InteropServices.SafeHandle> non riuscirà ad eseguire questa operazione.</span><span class="sxs-lookup"><span data-stu-id="e2380-133">The second <xref:System.Runtime.InteropServices.SafeHandle> to do this will fail.</span></span> <span data-ttu-id="e2380-134">La procedura corretta da seguire quando si serializza un oggetto <xref:System.Runtime.InteropServices.SafeHandle> consiste nel chiamare la funzione `DuplicateHandle` o una funzione simile per il tipo di handle nativo in modo da creare una copia valida distinta dell'handle.</span><span class="sxs-lookup"><span data-stu-id="e2380-134">The correct course of action when serializing a <xref:System.Runtime.InteropServices.SafeHandle> is to call the `DuplicateHandle` function or a similar function for your native handle type to make a distinct legal handle copy.</span></span> <span data-ttu-id="e2380-135">Se il tipo di handle non supporta questa funzione, il tipo <xref:System.Runtime.InteropServices.SafeHandle> che lo include non può essere reso serializzabile.</span><span class="sxs-lookup"><span data-stu-id="e2380-135">If your handle type does not support this then the <xref:System.Runtime.InteropServices.SafeHandle> type wrapping it cannot be made serializable.</span></span>  
  
- <span data-ttu-id="e2380-136">È possibile individuare il punto in cui un handle viene chiuso anticipatamente, causando un errore al momento della chiamata finale al metodo <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>, inserendo un punto di interruzione sulla routine nativa usata per rilasciare l'handle, ad esempio la funzione `CloseHandle`.</span><span class="sxs-lookup"><span data-stu-id="e2380-136">It may be possible to track where a handle is being closed early, leading to a failure when the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method is finally called, by placing a debugger breakpoint on the native routine used to release the handle, for example the `CloseHandle` function.</span></span> <span data-ttu-id="e2380-137">Questo potrebbe non essere possibile in situazioni di sovraccarico o anche nel caso di test funzionali di medie dimensioni a causa del volume elevato di traffico spesso associato a tali routine.</span><span class="sxs-lookup"><span data-stu-id="e2380-137">This may not be possible for stress scenarios or even medium-sized functional tests due to the heavy traffic such routines often deal with.</span></span> <span data-ttu-id="e2380-138">In questo caso può essere utile instrumentare il codice che chiama il metodo di rilascio nativo, allo scopo di catturare l'identità del chiamante, o eventualmente eseguire una traccia dello stack completa, in modo da ottenere il valore dell'handle rilasciato,</span><span class="sxs-lookup"><span data-stu-id="e2380-138">It may help to instrument the code that calls the native release method, in order to capture the identity of the caller, or possibly a full stack trace, and the value of the handle being released.</span></span>  <span data-ttu-id="e2380-139">che può essere quindi confrontato con il valore indicato da questo assistente al debug gestito.</span><span class="sxs-lookup"><span data-stu-id="e2380-139">The handle value can be compared with the value reported by this MDA.</span></span>  
  
- <span data-ttu-id="e2380-140">Alcuni tipi di handle nativi, ad esempio tutti gli handle Win32 che possono essere rilasciati mediante la funzione `CloseHandle`, condividono lo stesso spazio dei nomi dell'handle.</span><span class="sxs-lookup"><span data-stu-id="e2380-140">Note that some native handle types, such as all the Win32 handles that can be released via the `CloseHandle` function, share the same handle namespace.</span></span> <span data-ttu-id="e2380-141">Il rilascio errato di un tipo di handle può causare problemi con un altro handle.</span><span class="sxs-lookup"><span data-stu-id="e2380-141">An erroneous release of one handle type can cause problems with another.</span></span> <span data-ttu-id="e2380-142">Se ad esempio si chiude involontariamente due volte un handle di evento Win32, è possibile che venga chiuso prematuramente un handle di file apparentemente non correlato.</span><span class="sxs-lookup"><span data-stu-id="e2380-142">For instance, accidentally closing a Win32 event handle twice might lead to an apparently unrelated file handle being closed prematurely.</span></span> <span data-ttu-id="e2380-143">Questo problema si verifica quando l'handle viene rilasciato e il valore dell'handle può essere usato per controllare un'altra risorsa, eventualmente di un altro tipo.</span><span class="sxs-lookup"><span data-stu-id="e2380-143">This happens when the handle is released and the handle value becomes available for use to track another resource, potentially of another type.</span></span> <span data-ttu-id="e2380-144">Se in questa situazione viene eseguito per errore un secondo rilascio, è possibile che venga invalidato l'handle di un thread non correlato.</span><span class="sxs-lookup"><span data-stu-id="e2380-144">If this happens and is followed by an erroneous second release, the handle of an unrelated thread might be invalidated.</span></span>  
  
## <a name="effect-on-the-runtime"></a><span data-ttu-id="e2380-145">Effetto sull'ambiente di esecuzione</span><span class="sxs-lookup"><span data-stu-id="e2380-145">Effect on the Runtime</span></span>  
 <span data-ttu-id="e2380-146">L'assistente al debug gestito non ha alcun effetto su CLR.</span><span class="sxs-lookup"><span data-stu-id="e2380-146">This MDA has no effect on the CLR.</span></span>  
  
## <a name="output"></a><span data-ttu-id="e2380-147">Output</span><span class="sxs-lookup"><span data-stu-id="e2380-147">Output</span></span>  
 <span data-ttu-id="e2380-148">Un messaggio indicante che un oggetto <xref:System.Runtime.InteropServices.SafeHandle> o <xref:System.Runtime.InteropServices.CriticalHandle> non è riuscito a rilasciare correttamente l'handle.</span><span class="sxs-lookup"><span data-stu-id="e2380-148">A message indicating that a <xref:System.Runtime.InteropServices.SafeHandle> or a <xref:System.Runtime.InteropServices.CriticalHandle> failed to properly release the handle.</span></span> <span data-ttu-id="e2380-149">Ad esempio:</span><span class="sxs-lookup"><span data-stu-id="e2380-149">For example:</span></span>  
  
```output
"A SafeHandle or CriticalHandle of type 'MyBrokenSafeHandle'   
failed to properly release the handle with value 0x0000BEEF. This   
usually indicates that the handle was released incorrectly via   
another means (such as extracting the handle using DangerousGetHandle   
and closing it directly or building another SafeHandle around it."  
```  
  
## <a name="configuration"></a><span data-ttu-id="e2380-150">Configurazione</span><span class="sxs-lookup"><span data-stu-id="e2380-150">Configuration</span></span>  
  
```xml  
<mdaConfig>  
  <assistants>  
    <releaseHandleFailed/>  
  </assistants>  
</mdaConfig>  
```  
  
## <a name="example"></a><span data-ttu-id="e2380-151">Esempio</span><span class="sxs-lookup"><span data-stu-id="e2380-151">Example</span></span>  
 <span data-ttu-id="e2380-152">i seguito è riportato un esempio di codice che può attivare l'assistente al debug gestito `releaseHandleFailed`.</span><span class="sxs-lookup"><span data-stu-id="e2380-152">The following is a code example that can activate the `releaseHandleFailed` MDA.</span></span>  
  
```csharp
bool ReleaseHandle()  
{  
    // Calling the Win32 CloseHandle function to release the   
    // native handle wrapped by this SafeHandle. This method returns   
    // false on failure, but should only fail if the input is invalid   
    // (which should not happen here). The method specifically must not   
    // fail simply because of lack of resources or other transient   
    // failures beyond the user’s control. That would make it unacceptable   
    // to call CloseHandle as part of the implementation of this method.  
    return CloseHandle(handle);  
}  
```  
  
## <a name="see-also"></a><span data-ttu-id="e2380-153">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="e2380-153">See also</span></span>

- <xref:System.Runtime.InteropServices.MarshalAsAttribute>
- [<span data-ttu-id="e2380-154">Diagnostica degli errori tramite gli assistenti al debug gestito</span><span class="sxs-lookup"><span data-stu-id="e2380-154">Diagnosing Errors with Managed Debugging Assistants</span></span>](diagnosing-errors-with-managed-debugging-assistants.md)
- [<span data-ttu-id="e2380-155">Marshalling di interoperabilità</span><span class="sxs-lookup"><span data-stu-id="e2380-155">Interop Marshaling</span></span>](../interop/interop-marshaling.md)
