---
title: Precedenza del valore della proprietà di dipendenza
ms.date: 03/30/2017
helpviewer_keywords:
- dependency properties [WPF], classes as owners
- dependency properties [WPF], metadata
- classes [WPF], owners of dependency properties
- metadata [WPF], dependency properties
ms.assetid: 1fbada8e-4867-4ed1-8d97-62c07dad7ebc
ms.openlocfilehash: 1d7c644c7f7581a96ffff1a0fe1fcf2adfe071e0
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 03/12/2020
ms.locfileid: "79186151"
---
# <a name="dependency-property-value-precedence"></a>Precedenza del valore della proprietà di dipendenza
<a name="introduction"></a> Questo argomento illustra il modo in cui i meccanismi del sistema di proprietà [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] possono influire sul valore di una proprietà di dipendenza e descrive la precedenza in base alla quale gli aspetti del sistema di proprietà si applicano al valore effettivo di una proprietà.  

<a name="prerequisites"></a>
## <a name="prerequisites"></a>Prerequisites  
 Questo argomento presuppone la conoscenza delle proprietà di dipendenza dal punto di vista di un consumer delle proprietà di dipendenza esistenti nelle classi di [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], nonché la lettura dell'argomento [Panoramica sulle proprietà di dipendenza](dependency-properties-overview.md). Per seguire gli esempi illustrati in questo argomento, è anche necessario conoscere [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] e saper scrivere applicazioni [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  
  
<a name="intro"></a>
## <a name="the-wpf-property-system"></a>Il sistema di proprietà WPF  
 Il sistema di proprietà [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] offre un potente strumento per consentire la determinazione del valore delle proprietà di dipendenza in base a numerosi fattori, abilitando funzionalità quali la convalida delle proprietà in tempo reale, l'associazione tardiva e la notifica alle proprietà correlate delle modifiche ai valori di altre proprietà. L'ordine e logica precisi usati per determinare i valori delle proprietà di dipendenza sono piuttosto complessi. La conoscenza di questo ordine consentirà di evitare l'impostazione dì proprietà non necessarie e potrebbe anche eliminare i dubbi sui motivi precisi per i quali alcuni tentativi di influenzare o anticipare un valore delle proprietà di dipendenza non hanno determinato il valore atteso.  
  
<a name="multiple_sets"></a>
## <a name="dependency-properties-might-be-set-in-multiple-places"></a>Le proprietà di dipendenza possono essere impostate in più punti  
 Di seguito [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] è riportato<xref:System.Windows.Controls.Control.Background%2A>l'esempio in cui la stessa proprietà ( ) ha tre diverse operazioni "set" che potrebbero influenzare il valore.  
  
 [!code-xaml[PropertiesOvwSupport#DPPrecedence](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml#dpprecedence)]  
  
 In questo caso, quale colore ci si aspetta che verrà applicato, rosso, verde o blu?  
  
 Ad eccezione dei valori animati e della coercizione, i set di proprietà locali vengono impostati con la precedenza più elevata. Se si imposta localmente un valore, è possibile prevedere che il valore venga accettato, anche al di là degli stili o dei modelli di controllo. Di seguito è <xref:System.Windows.Controls.Control.Background%2A> riportato su Rosso locale. Pertanto, lo stile definito in questo ambito, anche se è uno stile implicito che altrimenti si applicherebbe <xref:System.Windows.Controls.Control.Background%2A> a tutti gli elementi di quel tipo in tale ambito, non è la precedenza più alta per fornire alla proprietà il relativo valore.  Se è stato rimosso il valore locale Red dall'istanza specifica del controllo Button, lo stile avrà la precedenza e il pulsante otterrà il valore di Background dallo stile.  All'interno dello stile, i trigger hanno la precedenza, pertanto il pulsante sarà blu se il mouse è posizionato su di esso e verde in caso contrario.  
  
<a name="listing"></a>
## <a name="dependency-property-setting-precedence-list"></a>Elenco delle precedenze per l'impostazione delle proprietà di dipendenza  
 Di seguito viene riportato l'ordine definitivo usato dal sistema di proprietà per l'assegnazione dei valori di runtime delle proprietà di dipendenza. La precedenza più elevata viene elencata per prima. Questo elenco si basa su alcuni dei concetti generali espressi in [Panoramica sulle proprietà di dipendenza](dependency-properties-overview.md).  
  
1. **Coercizione del sistema di proprietà.** Per informazioni dettagliate sulla coercizione, vedere [Coercizione, animazione e valore di base](#animations) più avanti in questo argomento.  
  
2. **Animazioni attive o animazioni con un comportamento di attesa.** Per ottenere qualsiasi effetto pratico, l'animazione di una proprietà deve essere in grado di avere la precedenza sul valore di base (inanimato), anche se quel valore è stato impostato localmente. Per informazioni dettagliate, vedere [Coercizione, animazione e valore di base](#animations) più avanti in questo argomento.  
  
3. **Valore locale.** Un valore locale può essere impostato per comodità della proprietà "wrapper", che equivale [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]anche all'impostazione <xref:System.Windows.DependencyObject.SetValue%2A> come attributo o elemento proprietà in , oppure da una chiamata all'API utilizzando una proprietà di un'istanza specifica. Se si imposta un valore locale usando un'associazione o una risorsa, ciascuno di questi elementi dispone della precedenza come se fosse stato impostato un valore diretto.  
  
4. **Proprietà del modello TemplatedParent.** Un elemento <xref:System.Windows.FrameworkElement.TemplatedParent%2A> ha un se è stato creato <xref:System.Windows.Controls.ControlTemplate> <xref:System.Windows.DataTemplate>come parte di un modello (a o ). Per informazioni dettagliate sulle situazioni in cui viene applicato, vedere [TemplatedParent](#templatedparent) più avanti in questo argomento. All'interno del modello, viene applicata la seguente precedenza:  
  
    1. Trigger dal <xref:System.Windows.FrameworkElement.TemplatedParent%2A> modello.  
  
    2. Insiemi [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] di proprietà <xref:System.Windows.FrameworkElement.TemplatedParent%2A> (in genere tramite attributi) nel modello.  
  
5. **Stile implicito.** Si applica solo alla proprietà `Style`. La proprietà `Style` viene riempita da qualsiasi risorsa di stile con una chiave che corrisponde al tipo di quell'elemento. Quella risorsa di stile deve essere presente nella pagina o nell'applicazione. La ricerca per una risorsa di stile implicita non viene eseguita nei temi.  
  
6. **Trigger degli stili.** I trigger all'interno di stili da una pagina o un'applicazione (questi stili potrebbero essere stili espliciti o impliciti, ma non derivati dagli stili predefiniti, che hanno una precedenza inferiore).  
  
7. **Trigger dei modelli.** Qualsiasi trigger da un modello all'interno di uno stile oppure un modello applicato direttamente.  
  
8. **Setter di stili.** Valori da <xref:System.Windows.Setter> un all'interno di stili dalla pagina o dall'applicazione.  
  
9. **Stile (tema) predefinito.** Per informazioni dettagliate sui casi in cui viene applicato e sul modo in cui gli stili del tema si riferiscono ai modelli all'interno degli stili del tema, vedere [Stili (tema) predefiniti](#themestyles) più avanti in questo argomento. All'interno di uno stile predefinito, viene applicato il seguente ordine di precedenza:  
  
    1. Trigger attivi nello stile del tema.  
  
    2. Setter nello stile del tema.  
  
10. **Eredità.** Alcune proprietà di dipendenza ereditano i propri valori dall'elemento padre agli elementi figlio, in modo che non sia necessario impostarli in modo specifico per ogni elemento in tutta l'applicazione. Per informazioni dettagliate, vedere [Ereditarietà dei valori](property-value-inheritance.md)delle proprietà .  
  
11. **Valore predefinito dai metadati delle proprietà di dipendenza.** Qualsiasi proprietà di dipendenza specificata può avere un valore predefinito come stabilito dalla registrazione del sistema di proprietà di quella particolare proprietà. Inoltre, le classi derivate che ereditano una proprietà di dipendenza hanno la possibilità di eseguire l'override di tali metadati (incluso il valore predefinito) in base al tipo. Per altre informazioni, vedere [Metadati delle proprietà di dipendenza](dependency-property-metadata.md). Dato che l'ereditarietà viene controllata prima del valore predefinito, per una proprietà ereditata un valore predefinito dell'elemento padre ha la precedenza su un elemento figlio.  Di conseguenza, se una proprietà ereditabile non viene impostata ovunque, viene usato il valore predefinito come specificato nella radice o nell'elemento padre invece del valore predefinito dell'elemento figlio.  
  
<a name="templatedparent"></a>
## <a name="templatedparent"></a>TemplatedParent  
 TemplatedParent come un elemento di precedenza non si applica a qualsiasi proprietà di un elemento che viene dichiarata direttamente nel markup dell'applicazione standard. Il concetto di TemplatedParent esiste solo per elementi figlio all'interno di una struttura ad albero visuale che vengono creati tramite l'applicazione del modello. Quando il sistema <xref:System.Windows.FrameworkElement.TemplatedParent%2A> di proprietà cerca un valore nel modello, cerca il modello che ha creato l'elemento. I valori delle <xref:System.Windows.FrameworkElement.TemplatedParent%2A> proprietà del modello in genere agiscono come se fossero impostati come valore locale nell'elemento figlio, ma questa precedenza minore rispetto al valore locale esiste perché i modelli sono potenzialmente condivisi. Per informazioni dettagliate, vedere <xref:System.Windows.FrameworkElement.TemplatedParent%2A>.  
  
<a name="style_property"></a>
## <a name="the-style-property"></a>Proprietà Style  
 L'ordine di ricerca descritto in precedenza si <xref:System.Windows.FrameworkElement.Style%2A> applica a tutte le possibili proprietà di dipendenza ad eccezione di una: la proprietà. La <xref:System.Windows.FrameworkElement.Style%2A> proprietà è univoca in quanto non può essere applicata a se stessa, pertanto gli elementi di precedenza da 5 a 8 non si applicano. Inoltre, l'animazione o <xref:System.Windows.FrameworkElement.Style%2A> l'animazione forzata non è consigliata (e l'animazione <xref:System.Windows.FrameworkElement.Style%2A> richiederebbe una classe di animazione personalizzata). In questo modo <xref:System.Windows.FrameworkElement.Style%2A> è possibile impostare la proprietà in tre modi:This leaves three ways that the property might be set:  
  
- **Stile esplicito.** La <xref:System.Windows.FrameworkElement.Style%2A> proprietà viene impostata direttamente. Nella maggior parte degli scenari, lo stile non viene definito inline, ma viene invece indicato come una risorsa, tramite una chiave esplicita. In questo caso la stessa proprietà Style agisce come se fosse un valore locale, elemento di precedenza 3.  
  
- **Stile implicito.** La <xref:System.Windows.FrameworkElement.Style%2A> proprietà non è impostata direttamente. Tuttavia, <xref:System.Windows.FrameworkElement.Style%2A> l'esiste a un certo livello nella sequenza di ricerca delle risorse (pagina, applicazione) e viene digitato utilizzando una chiave di risorsa che corrisponde al tipo a cui deve essere applicato lo stile. In questo caso, la <xref:System.Windows.FrameworkElement.Style%2A> proprietà stessa agisce in base a una precedenza identificata nella sequenza come elemento 5. Questa condizione può essere <xref:System.Windows.DependencyPropertyHelper> rilevata utilizzando <xref:System.Windows.FrameworkElement.Style%2A> <xref:System.Windows.BaseValueSource.ImplicitStyleReference> la proprietà e cercando nei risultati.  
  
- **Stile predefinito**, noto anche come **stile del tema.** La <xref:System.Windows.FrameworkElement.Style%2A> proprietà non è impostata direttamente `null` e infatti verrà letto fino alla fase di esecuzione. In questo caso, lo stile deriva dalla valutazione del tema di runtime che fa parte del motore di presentazione [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  
  
 Per gli stili impliciti non inclusi nei `MyButton` `Button`temi, il tipo deve corrispondere `Button`esattamente: una classe derivata da non utilizzerà in modo implicito uno stile per .  
  
<a name="themestyles"></a>
## <a name="default-theme-styles"></a>Stili (tema) predefiniti  
 Ogni controllo fornito con [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] dispone di uno stile predefinito. Potenzialmente, lo stile predefinito varia in base al tema, motivo per il quale questo stile predefinito viene indicato in alcuni casi come uno stile del tema.  
  
 Le informazioni più importanti che si trovano all'interno di uno stile predefinito per un controllo <xref:System.Windows.Controls.Control.Template%2A> è il relativo modello di controllo, che esiste nello stile del tema come setter per la relativa proprietà. Se non esistesse un modello derivato dagli stili predefiniti, un controllo senza un modello personalizzato come parte di uno stile personalizzato non presenterebbe alcun aspetto visivo. Il modello derivato dallo stile predefinito fornisce all'aspetto visivo di ciascun controllo una struttura di base e definisce anche le connessioni tra proprietà definite nella struttura ad albero visuale del modello e la classe di controlli corrispondente. Ogni controllo espone un set di proprietà che può influenzare l'aspetto visivo del controllo senza sostituire completamente il modello. Si consideri ad esempio l'aspetto visivo predefinito di un <xref:System.Windows.Controls.Primitives.Thumb> controllo, che è un componente di un <xref:System.Windows.Controls.Primitives.ScrollBar>oggetto .  
  
 A <xref:System.Windows.Controls.Primitives.Thumb> ha determinate proprietà personalizzabili. Il modello predefinito <xref:System.Windows.Controls.Primitives.Thumb> di un crea una struttura <xref:System.Windows.Controls.Border> di base / struttura ad albero visuale con diversi componenti annidati per creare un aspetto svelto. Se una proprietà che fa parte del modello deve <xref:System.Windows.Controls.Primitives.Thumb> essere esposta per la personalizzazione dalla classe, tale proprietà deve essere esposta da un [TemplateBinding](templatebinding-markup-extension.md), all'interno del modello. Nel caso <xref:System.Windows.Controls.Primitives.Thumb>di , varie proprietà di questi bordi <xref:System.Windows.Controls.Border.Background%2A> condividono un'associazione di modello a proprietà quali o <xref:System.Windows.Controls.Border.BorderThickness%2A>. Ma certe altre proprietà o disposizioni visive sono hardcoded nel modello di controllo o sono associate a valori che derivano direttamente dal tema e non possono essere modificate senza sostituire l'intero modello. Generalmente, se una proprietà deriva da un elemento padre basato su modelli e non viene esposta da un'associazione di modelli, non può essere regolata dagli stili poiché non esiste un modo semplice per fare riferimento ad essa. Ma tale proprietà potrebbe essere ancora influenzata dall'ereditarietà dei valori della proprietà nel modello applicato oppure dal valore predefinito.  
  
 Gli stili del tema usano un tipo come chiave nelle definizioni. Tuttavia, quando i temi vengono applicati a una determinata istanza <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> dell'elemento, la ricerca dei temi per questo tipo viene eseguita controllando la proprietà in un controllo. Questa operazione è in contrasto con l'uso del tipo letterale, adottato dagli stili impliciti. Il valore <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> di erediterà alle classi derivate anche se l'implementatore non lo ha modificato (il modo previsto per modificare la proprietà non consiste nell'eseguirne l'override a livello di proprietà, ma nel modificarne il valore predefinito nei metadati della proprietà). Questo riferimento indiretto consente alle classi di base di definire gli stili del tema per gli elementi derivati che non dispongono di un altro stile oppure, in un caso più importante, che non dispongono di un modello all'interno di quello stile e che di conseguenza non avrebbero alcun aspetto visivo predefinito. Così, è `MyButton` possibile <xref:System.Windows.Controls.Button> derivare da <xref:System.Windows.Controls.Button> e otterrà ancora il modello predefinito. Se si è stati `MyButton` l'autore del controllo e si desidera un <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> `MyButton` comportamento diverso, è possibile eseguire l'override dei `MyButton` metadati della proprietà `MyButton` di dipendenza per on per restituire una chiave diversa e quindi definire gli stili del tema pertinenti, incluso il modello, è necessario creare un pacchetto con il controllo. Per altri dettagli su temi, stili e creazione di controlli, vedere [Cenni preliminari sulla modifica di controlli](../controls/control-authoring-overview.md).  
  
<a name="resources"></a>
## <a name="dynamic-resource-references-and-binding"></a>Riferimenti e associazione di risorse dinamiche  
 I riferimenti alle risorse dinamiche e le operazioni di associazione rispettano la precedenza della posizione su cui sono impostati. Ad esempio, una risorsa dinamica applicata a un valore locale agisce in base all'elemento di precedenza 3, a un'associazione per un setter di proprietà all'interno di un stile del tema viene applicato un elemento di precedenza 9 e così via. Dato che i riferimenti e l'associazione per le risorse dinamiche devono essere in grado di ottenere valori dallo stato della fase di esecuzione dell'applicazione, ciò comporta che anche il processo effettivo di determinazione della precedenza del valore di proprietà per qualsiasi proprietà specificata si estende nella fase di esecuzione.  
  
 I riferimenti alle risorse dinamiche non fanno parte in senso stretto del sistema di proprietà, ma hanno un proprio ordine di ricerca che interagisce con la sequenza elencata in precedenza. Tale precedenza è documentata più approfonditamente in [Risorse XAML](../../../desktop-wpf/fundamentals/xaml-resources-define.md). La somma di base di tale precedenza è: elemento alla radice della pagina, applicazione, tema, sistema.  
  
 Le risorse dinamiche e le associazioni hanno la precedenza relativamente a dove sono state impostate, ma il valore viene rinviato. Una conseguenza di ciò è che, se si imposta una risorsa dinamica o un'associazione su un valore locale, qualsiasi modifica al valore locale sostituisce completamente la risorsa dinamica o l'associazione. Anche se si <xref:System.Windows.DependencyObject.ClearValue%2A> chiama il metodo per cancellare il valore impostato localmente, la risorsa dinamica o l'associazione non verrà ripristinata. Infatti, se <xref:System.Windows.DependencyObject.ClearValue%2A> si chiama su una proprietà che dispone di una risorsa dinamica o <xref:System.Windows.DependencyObject.ClearValue%2A> associazione sul posto (senza alcun valore locale letterale), vengono cancellati anche dalla chiamata.  
  
<a name="setcurrentvalue"></a>
## <a name="setcurrentvalue"></a>SetCurrentValue  
 Il <xref:System.Windows.DependencyObject.SetCurrentValue%2A> metodo è un altro modo per impostare una proprietà, ma non è in ordine di precedenza. Consente <xref:System.Windows.DependencyObject.SetCurrentValue%2A> invece di modificare il valore di una proprietà senza sovrascrivere l'origine di un valore precedente. È possibile <xref:System.Windows.DependencyObject.SetCurrentValue%2A> utilizzare qualsiasi ora che si desidera impostare un valore senza assegnare a tale valore la precedenza di un valore locale. Ad esempio, se una proprietà viene impostata da <xref:System.Windows.DependencyObject.SetCurrentValue%2A>un trigger e quindi viene assegnato un altro valore tramite , il sistema di proprietà rispetta comunque il trigger e la proprietà verrà modificata se si verifica l'azione del trigger. <xref:System.Windows.DependencyObject.SetCurrentValue%2A>consente di modificare il valore della proprietà senza fornirle un'origine con una precedenza maggiore. Analogamente, è <xref:System.Windows.DependencyObject.SetCurrentValue%2A> possibile utilizzare per modificare il valore di una proprietà senza sovrascrivere un'associazione.  
  
<a name="animations"></a>
## <a name="coercion-animations-and-base-value"></a>Coercizione, animazioni e valore di base  
 Coercizione e animazione agiscono entrambe su un valore che viene definito come il "valore di base" in tutto questo SDK. Di conseguenza, il valore di base è un qualsiasi valore determinato tramite la valutazione verso l'alto negli elementi fino a raggiungere l'elemento 2.  
  
 Per un'animazione, il valore di base può avere un effetto sul valore animato, se quell'animazione non specifica le impostazioni "From" e "To" per determinati comportamenti o se l'animazione ripristina intenzionalmente il valore di base quando viene completata. Per osservare questo comportamento nella pratica, eseguire l'[Esempio valori di destinazione dell'animazione From/To/By](https://github.com/Microsoft/WPF-Samples/tree/master/Animation/TargetValues). Tentare di impostare i valori locali dell'altezza del rettangolo nell'esempio, in modo che il valore locale iniziale sia diverso da qualsiasi impostazione "From" nell'animazione. Si noterà che le animazioni iniziano immediatamente usando i valori "From" valori e sostituiscono il valore di base una volta avviate. L'animazione può specificare di tornare al valore trovato prima <xref:System.Windows.Media.Animation.FillBehavior>dell'animazione una volta completata specificando il Stop . In seguito, verrà usata la precedenza normale per la determinazione del valore di base.  
  
 Possono essere applicate più animazioni a una sola proprietà, ognuna delle quali definita da punti diversi nella precedenza dei valori. Tuttavia, queste animazioni comporranno i relativi valori, piuttosto che applicare semplicemente l'animazione dalla precedenza più elevata. Ciò dipende dal modo preciso in cui sono definite le animazioni e dal tipo del valore che viene animato. Per altre informazioni sulle proprietà di animazione vedere [Cenni preliminari sull'animazione](../graphics-multimedia/animation-overview.md).  
  
 La coercizione si applica al livello più elevato in assoluto. Anche un'animazione già in esecuzione è soggetta alla coercizione del valore. Alcune proprietà di dipendenza esistenti in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] dispongono di una coercizione incorporata. Per una proprietà di dipendenza personalizzata, è possibile definire il comportamento <xref:System.Windows.CoerceValueCallback> di coercizione per una proprietà di dipendenza personalizzata scrivendo e passando il callback come parte dei metadati quando si crea la proprietà. È anche possibile eseguire l'override del comportamento di coercizione di proprietà esistenti eseguendo l'override dei metadati di quella proprietà in una classe derivata. La coercizione interagisce con il valore di base in modo tale che i vincoli di coercizione vengano applicati come i vincoli esistenti in quel momento, mantenendo tuttavia il valore di base. Pertanto, se i vincoli nella coercizione vengono rimossi in un secondo momento, la coercizione restituirà il valore più vicino possibile a quel valore di base e l'influenza della coercizione su una proprietà cesserà potenzialmente appena vengono rimossi tutti i vincoli. Per altre informazioni sul comportamento di coercizione, vedere [Callback e convalida delle proprietà di dipendenza](dependency-property-callbacks-and-validation.md).  
  
<a name="triggers"></a>
## <a name="trigger-behaviors"></a>Comportamenti dei trigger  
 I controlli spesso definiscono i comportamenti dei trigger come parte dello stile predefinito nei temi. L'impostazione di proprietà locali sui controlli può impedire ai trigger di essere in grado di rispondere agli eventi generati dagli utenti sia da un punto di vista visivo sia da un punto di vista di comportamento. L'utilizzo più comune di un trigger di <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A>proprietà è per le proprietà del controllo o dello stato, ad esempio . Ad esempio, per <xref:System.Windows.Controls.Button> impostazione predefinita <xref:System.Windows.UIElement.IsEnabled%2A> quando `false`un <xref:System.Windows.Controls.Control.Foreground%2A> oggetto è disabilitato (trigger for is ) il valore nello stile del tema è ciò che fa sì che il controllo venga visualizzato "in grigio". Ma se è stato <xref:System.Windows.Controls.Control.Foreground%2A> impostato un valore locale, quel normale colore grigio-out sarà ignorato in precedenza dal set di proprietà locale, anche in questo scenario attivato dalla proprietà. Prestare attenzione nell'impostazione di valori per proprietà che presentano comportamenti di trigger a livello di tema e accertarsi di non interferire impropriamente con l'esperienza utente prevista per quel controllo.  
  
<a name="clearvalue"></a>
## <a name="clearvalue-and-value-precedence"></a>ClearValue e precedenza dei valori  
 Il <xref:System.Windows.DependencyObject.ClearValue%2A> metodo fornisce un mezzo opportuno per cancellare qualsiasi valore applicato localmente da una proprietà di dipendenza impostata su un elemento. Tuttavia, <xref:System.Windows.DependencyObject.ClearValue%2A> la chiamata non è una garanzia che l'impostazione predefinita stabilita nei metadati durante la registrazione della proprietà sia il nuovo valore effettivo. Tutti gli altri partecipanti nella precedenza dei valori sono ancora attivi. Solo il valore impostato localmente è stato rimosso dalla sequenza di precedenza. Ad esempio, se <xref:System.Windows.DependencyObject.ClearValue%2A> si chiama su una proprietà in cui tale proprietà è impostata anche da uno stile del tema, il valore del tema viene applicato come nuovo valore anziché come valore predefinito basato su metadati. Se si desidera estrarre tutti i partecipanti al valore della proprietà dal processo e impostare il valore sul valore predefinito dei metadati registrati, è possibile ottenere definitivamente tale <xref:System.Windows.DependencyObject.SetValue%2A>valore predefinito eseguendo una query sui metadati della proprietà di dipendenza e quindi utilizzare il valore predefinito per impostare localmente la proprietà con una chiamata a .  
  
## <a name="see-also"></a>Vedere anche

- <xref:System.Windows.DependencyObject>
- <xref:System.Windows.DependencyProperty>
- [Cenni preliminari sulle proprietà di dipendenza](dependency-properties-overview.md)
- [Proprietà di dipendenza personalizzate](custom-dependency-properties.md)
- [Callback e convalida delle proprietà di dipendenza](dependency-property-callbacks-and-validation.md)
