---
title: Precedenza del valore della proprietà di dipendenza
ms.date: 03/30/2017
helpviewer_keywords:
- dependency properties [WPF], classes as owners
- dependency properties [WPF], metadata
- classes [WPF], owners of dependency properties
- metadata [WPF], dependency properties
ms.assetid: 1fbada8e-4867-4ed1-8d97-62c07dad7ebc
ms.openlocfilehash: a9ff3a4f6ac08a0f7ec6dd9fc26bf190f43f3584
ms.sourcegitcommit: 011314e0c8eb4cf4a11d92078f58176c8c3efd2d
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 02/09/2020
ms.locfileid: "77095203"
---
# <a name="dependency-property-value-precedence"></a>Precedenza del valore della proprietà di dipendenza
<a name="introduction"></a> Questo argomento illustra il modo in cui i meccanismi del sistema di proprietà [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] possono influire sul valore di una proprietà di dipendenza e descrive la precedenza in base alla quale gli aspetti del sistema di proprietà si applicano al valore effettivo di una proprietà.  

<a name="prerequisites"></a>   
## <a name="prerequisites"></a>Prerequisites  
 Questo argomento presuppone la conoscenza delle proprietà di dipendenza dal punto di vista di un consumer delle proprietà di dipendenza esistenti nelle classi di [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], nonché la lettura dell'argomento [Panoramica sulle proprietà di dipendenza](dependency-properties-overview.md). Per seguire gli esempi illustrati in questo argomento, è anche necessario conoscere [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] e saper scrivere applicazioni [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  
  
<a name="intro"></a>   
## <a name="the-wpf-property-system"></a>Il sistema di proprietà WPF  
 Il sistema di proprietà [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] offre un potente strumento per consentire la determinazione del valore delle proprietà di dipendenza in base a numerosi fattori, abilitando funzionalità quali la convalida delle proprietà in tempo reale, l'associazione tardiva e la notifica alle proprietà correlate delle modifiche ai valori di altre proprietà. L'ordine e logica precisi usati per determinare i valori delle proprietà di dipendenza sono piuttosto complessi. La conoscenza di questo ordine consentirà di evitare l'impostazione dì proprietà non necessarie e potrebbe anche eliminare i dubbi sui motivi precisi per i quali alcuni tentativi di influenzare o anticipare un valore delle proprietà di dipendenza non hanno determinato il valore atteso.  
  
<a name="multiple_sets"></a>   
## <a name="dependency-properties-might-be-set-in-multiple-places"></a>Le proprietà di dipendenza possono essere impostate in più punti  
 Di seguito è riportato un esempio [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] in cui la stessa proprietà (<xref:System.Windows.Controls.Control.Background%2A>) presenta tre diverse operazioni "set" che potrebbero influenzare il valore.  
  
 [!code-xaml[PropertiesOvwSupport#DPPrecedence](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml#dpprecedence)]  
  
 In questo caso, quale colore ci si aspetta che verrà applicato, rosso, verde o blu?  
  
 Ad eccezione dei valori animati e della coercizione, i set di proprietà locali vengono impostati con la precedenza più elevata. Se si imposta localmente un valore, è possibile prevedere che il valore venga accettato, anche al di là degli stili o dei modelli di controllo. Nell'esempio <xref:System.Windows.Controls.Control.Background%2A> viene impostato su rosso localmente. Pertanto, lo stile definito in questo ambito, anche se si tratta di uno stile implicito altrimenti applicabile a tutti gli elementi di quel tipo in tale ambito, non è la precedenza più elevata per fornire il valore della proprietà <xref:System.Windows.Controls.Control.Background%2A>.  Se è stato rimosso il valore locale Red dall'istanza specifica del controllo Button, lo stile avrà la precedenza e il pulsante otterrà il valore di Background dallo stile.  All'interno dello stile, i trigger hanno la precedenza, pertanto il pulsante sarà blu se il mouse è posizionato su di esso e verde in caso contrario.  
  
<a name="listing"></a>   
## <a name="dependency-property-setting-precedence-list"></a>Elenco delle precedenze per l'impostazione delle proprietà di dipendenza  
 Di seguito viene riportato l'ordine definitivo usato dal sistema di proprietà per l'assegnazione dei valori di runtime delle proprietà di dipendenza. La precedenza più elevata viene elencata per prima. Questo elenco si basa su alcuni dei concetti generali espressi in [Panoramica sulle proprietà di dipendenza](dependency-properties-overview.md).  
  
1. **Coercizione del sistema di proprietà.** Per informazioni dettagliate sulla coercizione, vedere [Coercizione, animazione e valore di base](#animations) più avanti in questo argomento.  
  
2. **Animazioni attive o animazioni con un comportamento di attesa.** Per ottenere qualsiasi effetto pratico, l'animazione di una proprietà deve essere in grado di avere la precedenza sul valore di base (inanimato), anche se quel valore è stato impostato localmente. Per informazioni dettagliate, vedere [Coercizione, animazione e valore di base](#animations) più avanti in questo argomento.  
  
3. **Valore locale.** Un valore locale può essere impostato tramite la praticità della proprietà "wrapper", che equivale anche a impostare come attributo o elemento proprietà in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]o da una chiamata all'API <xref:System.Windows.DependencyObject.SetValue%2A> utilizzando una proprietà di un'istanza specifica. Se si imposta un valore locale usando un'associazione o una risorsa, ciascuno di questi elementi dispone della precedenza come se fosse stato impostato un valore diretto.  
  
4. **Proprietà del modello TemplatedParent.** Un elemento ha un <xref:System.Windows.FrameworkElement.TemplatedParent%2A> se è stato creato come parte di un modello (<xref:System.Windows.Controls.ControlTemplate> o <xref:System.Windows.DataTemplate>). Per informazioni dettagliate sulle situazioni in cui viene applicato, vedere [TemplatedParent](#templatedparent) più avanti in questo argomento. All'interno del modello, viene applicata la seguente precedenza:  
  
    1. Trigger dal modello di <xref:System.Windows.FrameworkElement.TemplatedParent%2A>.  
  
    2. Set di proprietà (in genere tramite [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] attributi) nel modello di <xref:System.Windows.FrameworkElement.TemplatedParent%2A>.  
  
5. **Stile implicito.** Si applica solo alla proprietà `Style`. La proprietà `Style` viene riempita da qualsiasi risorsa di stile con una chiave che corrisponde al tipo di quell'elemento. Quella risorsa di stile deve essere presente nella pagina o nell'applicazione. La ricerca per una risorsa di stile implicita non viene eseguita nei temi.  
  
6. **Trigger degli stili.** I trigger all'interno di stili da una pagina o un'applicazione (questi stili potrebbero essere stili espliciti o impliciti, ma non derivati dagli stili predefiniti, che hanno una precedenza inferiore).  
  
7. **Trigger dei modelli.** Qualsiasi trigger da un modello all'interno di uno stile oppure un modello applicato direttamente.  
  
8. **Setter di stili.** Valori da un <xref:System.Windows.Setter> all'interno di stili dalla pagina o dall'applicazione.  
  
9. **Stile (tema) predefinito.** Per informazioni dettagliate sui casi in cui viene applicato e sul modo in cui gli stili del tema si riferiscono ai modelli all'interno degli stili del tema, vedere [Stili (tema) predefiniti](#themestyles) più avanti in questo argomento. All'interno di uno stile predefinito, viene applicato il seguente ordine di precedenza:  
  
    1. Trigger attivi nello stile del tema.  
  
    2. Setter nello stile del tema.  
  
10. **Ereditarietà.** Alcune proprietà di dipendenza ereditano i propri valori dall'elemento padre agli elementi figlio, in modo che non sia necessario impostarli in modo specifico per ogni elemento in tutta l'applicazione. Per informazioni dettagliate, vedere [Ereditarietà del valore della proprietà](property-value-inheritance.md).  
  
11. **Valore predefinito dai metadati delle proprietà di dipendenza.** Qualsiasi proprietà di dipendenza specificata può avere un valore predefinito come stabilito dalla registrazione del sistema di proprietà di quella particolare proprietà. Inoltre, le classi derivate che ereditano una proprietà di dipendenza hanno la possibilità di eseguire l'override di tali metadati (incluso il valore predefinito) in base al tipo. Per altre informazioni, vedere [Metadati delle proprietà di dipendenza](dependency-property-metadata.md). Dato che l'ereditarietà viene controllata prima del valore predefinito, per una proprietà ereditata un valore predefinito dell'elemento padre ha la precedenza su un elemento figlio.  Di conseguenza, se una proprietà ereditabile non viene impostata ovunque, viene usato il valore predefinito come specificato nella radice o nell'elemento padre invece del valore predefinito dell'elemento figlio.  
  
<a name="templatedparent"></a>   
## <a name="templatedparent"></a>TemplatedParent  
 TemplatedParent come un elemento di precedenza non si applica a qualsiasi proprietà di un elemento che viene dichiarata direttamente nel markup dell'applicazione standard. Il concetto di TemplatedParent esiste solo per elementi figlio all'interno di una struttura ad albero visuale che vengono creati tramite l'applicazione del modello. Quando il sistema di proprietà Cerca un valore nel modello di <xref:System.Windows.FrameworkElement.TemplatedParent%2A>, sta cercando il modello che ha creato tale elemento. I valori delle proprietà del modello di <xref:System.Windows.FrameworkElement.TemplatedParent%2A> in genere agiscono come se fossero impostati come valore locale nell'elemento figlio, ma questa precedenza minore rispetto al valore locale esiste perché i modelli sono potenzialmente condivisi. Per informazioni dettagliate, vedere <xref:System.Windows.FrameworkElement.TemplatedParent%2A>.  
  
<a name="style_property"></a>   
## <a name="the-style-property"></a>Proprietà Style  
 L'ordine di ricerca descritto in precedenza si applica a tutte le possibili proprietà di dipendenza tranne una: la proprietà <xref:System.Windows.FrameworkElement.Style%2A>. La proprietà <xref:System.Windows.FrameworkElement.Style%2A> è univoca in quanto non è possibile applicare uno stile, quindi gli elementi di precedenza da 5 a 8 non vengono applicati. Inoltre, l'animazione o la coercizione di <xref:System.Windows.FrameworkElement.Style%2A> non è consigliata (e l'animazione <xref:System.Windows.FrameworkElement.Style%2A> richiederebbe una classe di animazione personalizzata). In questo modo è possibile impostare la proprietà <xref:System.Windows.FrameworkElement.Style%2A>:  
  
- **Stile esplicito.** La proprietà <xref:System.Windows.FrameworkElement.Style%2A> è impostata direttamente. Nella maggior parte degli scenari, lo stile non viene definito inline, ma viene invece indicato come una risorsa, tramite una chiave esplicita. In questo caso la stessa proprietà Style agisce come se fosse un valore locale, elemento di precedenza 3.  
  
- **Stile implicito.** La proprietà <xref:System.Windows.FrameworkElement.Style%2A> non è impostata direttamente. Tuttavia, il <xref:System.Windows.FrameworkElement.Style%2A> esiste a un certo livello nella sequenza di ricerca delle risorse (pagina, applicazione) e viene immesso con una chiave di risorsa corrispondente al tipo a cui deve essere applicato lo stile. In questo caso, la proprietà <xref:System.Windows.FrameworkElement.Style%2A> stesso agisce con una precedenza identificata nella sequenza come elemento 5. Questa condizione può essere rilevata utilizzando <xref:System.Windows.DependencyPropertyHelper> sulla proprietà <xref:System.Windows.FrameworkElement.Style%2A> e cercando <xref:System.Windows.BaseValueSource.ImplicitStyleReference> nei risultati.  
  
- **Stile predefinito**, noto anche come **stile del tema.** La proprietà <xref:System.Windows.FrameworkElement.Style%2A> non è impostata direttamente e in realtà verrà letta come `null` fino alla fase di esecuzione. In questo caso, lo stile deriva dalla valutazione del tema di runtime che fa parte del motore di presentazione [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  
  
 Per gli stili impliciti non presenti nei temi, il tipo deve corrispondere esattamente a un `MyButton` classe derivata da `Button`non utilizzerà in modo implicito uno stile per `Button`.  
  
<a name="themestyles"></a>   
## <a name="default-theme-styles"></a>Stili (tema) predefiniti  
 Ogni controllo fornito con [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] dispone di uno stile predefinito. Potenzialmente, lo stile predefinito varia in base al tema, motivo per il quale questo stile predefinito viene indicato in alcuni casi come uno stile del tema.  
  
 Le informazioni più importanti trovate all'interno di uno stile predefinito per un controllo sono il relativo modello di controllo, che esiste nello stile del tema come Setter per la relativa proprietà <xref:System.Windows.Controls.Control.Template%2A>. Se non esistesse un modello derivato dagli stili predefiniti, un controllo senza un modello personalizzato come parte di uno stile personalizzato non presenterebbe alcun aspetto visivo. Il modello derivato dallo stile predefinito fornisce all'aspetto visivo di ciascun controllo una struttura di base e definisce anche le connessioni tra proprietà definite nella struttura ad albero visuale del modello e la classe di controlli corrispondente. Ogni controllo espone un set di proprietà che può influenzare l'aspetto visivo del controllo senza sostituire completamente il modello. Si consideri, ad esempio, l'aspetto visivo predefinito di un controllo <xref:System.Windows.Controls.Primitives.Thumb>, che è un componente di un <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 Una <xref:System.Windows.Controls.Primitives.Thumb> dispone di determinate proprietà personalizzabili. Il modello predefinito di un <xref:System.Windows.Controls.Primitives.Thumb> crea una struttura di base/struttura ad albero visuale con diversi componenti <xref:System.Windows.Controls.Border> annidati per creare un aspetto smussato. Se una proprietà che fa parte del modello deve essere esposta per la personalizzazione da parte della classe <xref:System.Windows.Controls.Primitives.Thumb>, tale proprietà deve essere esposta da un oggetto [TemplateBinding](templatebinding-markup-extension.md), all'interno del modello. Nel caso di <xref:System.Windows.Controls.Primitives.Thumb>, diverse proprietà di questi bordi condividono un'associazione di modelli a proprietà quali <xref:System.Windows.Controls.Border.Background%2A> o <xref:System.Windows.Controls.Border.BorderThickness%2A>. Ma certe altre proprietà o disposizioni visive sono hardcoded nel modello di controllo o sono associate a valori che derivano direttamente dal tema e non possono essere modificate senza sostituire l'intero modello. Generalmente, se una proprietà deriva da un elemento padre basato su modelli e non viene esposta da un'associazione di modelli, non può essere regolata dagli stili poiché non esiste un modo semplice per fare riferimento ad essa. Ma tale proprietà potrebbe essere ancora influenzata dall'ereditarietà dei valori della proprietà nel modello applicato oppure dal valore predefinito.  
  
 Gli stili del tema usano un tipo come chiave nelle definizioni. Tuttavia, quando i temi vengono applicati a una determinata istanza dell'elemento, la ricerca dei temi per questo tipo viene eseguita controllando la proprietà <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> su un controllo. Questa operazione è in contrasto con l'uso del tipo letterale, adottato dagli stili impliciti. Il valore di <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> erediterà le classi derivate anche se l'implementatore non lo ha modificato (il modo previsto per modificare la proprietà non è eseguirne l'override a livello di proprietà, ma per modificare il valore predefinito nei metadati della proprietà). Questo riferimento indiretto consente alle classi di base di definire gli stili del tema per gli elementi derivati che non dispongono di un altro stile oppure, in un caso più importante, che non dispongono di un modello all'interno di quello stile e che di conseguenza non avrebbero alcun aspetto visivo predefinito. Pertanto, è possibile derivare `MyButton` da <xref:System.Windows.Controls.Button> e ottenere comunque il <xref:System.Windows.Controls.Button> modello predefinito. Se si fosse l'autore del controllo di `MyButton` e si volesse un comportamento diverso, era possibile eseguire l'override dei metadati della proprietà di dipendenza per <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> su `MyButton` per restituire una chiave diversa, quindi definire gli stili del tema pertinenti, incluso il modello per `MyButton` che è necessario creare un pacchetto con il controllo `MyButton`. Per altri dettagli su temi, stili e creazione di controlli, vedere [Cenni preliminari sulla modifica di controlli](../controls/control-authoring-overview.md).  
  
<a name="resources"></a>   
## <a name="dynamic-resource-references-and-binding"></a>Riferimenti e associazione di risorse dinamiche  
 I riferimenti alle risorse dinamiche e le operazioni di associazione rispettano la precedenza della posizione su cui sono impostati. Ad esempio, una risorsa dinamica applicata a un valore locale agisce in base all'elemento di precedenza 3, a un'associazione per un setter di proprietà all'interno di un stile del tema viene applicato un elemento di precedenza 9 e così via. Dato che i riferimenti e l'associazione per le risorse dinamiche devono essere in grado di ottenere valori dallo stato della fase di esecuzione dell'applicazione, ciò comporta che anche il processo effettivo di determinazione della precedenza del valore di proprietà per qualsiasi proprietà specificata si estende nella fase di esecuzione.  
  
 I riferimenti alle risorse dinamiche non fanno parte in senso stretto del sistema di proprietà, ma hanno un proprio ordine di ricerca che interagisce con la sequenza elencata in precedenza. Tale precedenza è documentata più approfonditamente in [Risorse XAML](../../../desktop-wpf/fundamentals/xaml-resources-define.md). La somma di base di tale precedenza è: elemento alla radice della pagina, applicazione, tema, sistema.  
  
 Le risorse dinamiche e le associazioni hanno la precedenza relativamente a dove sono state impostate, ma il valore viene rinviato. Una conseguenza di ciò è che, se si imposta una risorsa dinamica o un'associazione su un valore locale, qualsiasi modifica al valore locale sostituisce completamente la risorsa dinamica o l'associazione. Anche se si chiama il metodo <xref:System.Windows.DependencyObject.ClearValue%2A> per cancellare il valore impostato localmente, la risorsa dinamica o l'associazione non verrà ripristinata. Infatti, se si chiama <xref:System.Windows.DependencyObject.ClearValue%2A> su una proprietà con una risorsa dinamica o un'associazione sul posto (senza valore locale letterale), vengono cancellate anche dalla chiamata <xref:System.Windows.DependencyObject.ClearValue%2A>.  
  
<a name="setcurrentvalue"></a>   
## <a name="setcurrentvalue"></a>SetCurrentValue  
 Il metodo <xref:System.Windows.DependencyObject.SetCurrentValue%2A> è un altro modo per impostare una proprietà, ma non è in ordine di precedenza. <xref:System.Windows.DependencyObject.SetCurrentValue%2A> consente invece di modificare il valore di una proprietà senza sovrascrivere l'origine di un valore precedente. È possibile utilizzare <xref:System.Windows.DependencyObject.SetCurrentValue%2A> ogni volta che si desidera impostare un valore senza assegnare tale valore alla precedenza di un valore locale. Se, ad esempio, una proprietà viene impostata da un trigger e quindi viene assegnato un altro valore tramite <xref:System.Windows.DependencyObject.SetCurrentValue%2A>, il sistema di proprietà rispetta il trigger e la proprietà verrà modificata se si verifica l'azione del trigger. <xref:System.Windows.DependencyObject.SetCurrentValue%2A> consente di modificare il valore della proprietà senza assegnarle un'origine con precedenza maggiore. Analogamente, è possibile utilizzare <xref:System.Windows.DependencyObject.SetCurrentValue%2A> per modificare il valore di una proprietà senza sovrascrivere un'associazione.  
  
<a name="animations"></a>   
## <a name="coercion-animations-and-base-value"></a>Coercizione, animazioni e valore di base  
 La coercizione e l'animazione agiscono entrambi su un valore definito come "valore di base" in tutto questo SDK. Di conseguenza, il valore di base è un qualsiasi valore determinato tramite la valutazione verso l'alto negli elementi fino a raggiungere l'elemento 2.  
  
 Per un'animazione, il valore di base può avere un effetto sul valore animato, se quell'animazione non specifica le impostazioni "From" e "To" per determinati comportamenti o se l'animazione ripristina intenzionalmente il valore di base quando viene completata. Per osservare questo comportamento nella pratica, eseguire l'[Esempio valori di destinazione dell'animazione From/To/By](https://github.com/Microsoft/WPF-Samples/tree/master/Animation/TargetValues). Tentare di impostare i valori locali dell'altezza del rettangolo nell'esempio, in modo che il valore locale iniziale sia diverso da qualsiasi impostazione "From" nell'animazione. Si noterà che le animazioni iniziano immediatamente usando i valori "From" valori e sostituiscono il valore di base una volta avviate. L'animazione potrebbe specificare per tornare al valore trovato prima dell'animazione dopo che è stato completato specificando l'<xref:System.Windows.Media.Animation.FillBehavior>stop. In seguito, verrà usata la precedenza normale per la determinazione del valore di base.  
  
 Possono essere applicate più animazioni a una sola proprietà, ognuna delle quali definita da punti diversi nella precedenza dei valori. Tuttavia, queste animazioni comporranno i relativi valori, piuttosto che applicare semplicemente l'animazione dalla precedenza più elevata. Ciò dipende dal modo preciso in cui sono definite le animazioni e dal tipo del valore che viene animato. Per altre informazioni sull'animazione di proprietà, vedere [Cenni preliminari sull'animazione](../graphics-multimedia/animation-overview.md).  
  
 La coercizione si applica al livello più elevato in assoluto. Anche un'animazione già in esecuzione è soggetta alla coercizione del valore. Alcune proprietà di dipendenza esistenti in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] dispongono di una coercizione incorporata. Per una proprietà di dipendenza personalizzata, si definisce il comportamento di coercizione per una proprietà di dipendenza personalizzata scrivendo un <xref:System.Windows.CoerceValueCallback> e passando il callback come parte dei metadati quando si crea la proprietà. È anche possibile eseguire l'override del comportamento di coercizione di proprietà esistenti eseguendo l'override dei metadati di quella proprietà in una classe derivata. La coercizione interagisce con il valore di base in modo tale che i vincoli di coercizione vengano applicati come i vincoli esistenti in quel momento, mantenendo tuttavia il valore di base. Pertanto, se i vincoli nella coercizione vengono rimossi in un secondo momento, la coercizione restituirà il valore più vicino possibile a quel valore di base e l'influenza della coercizione su una proprietà cesserà potenzialmente appena vengono rimossi tutti i vincoli. Per altre informazioni sul comportamento di coercizione, vedere [Callback e convalida delle proprietà di dipendenza](dependency-property-callbacks-and-validation.md).  
  
<a name="triggers"></a>   
## <a name="trigger-behaviors"></a>Comportamenti dei trigger  
 I controlli spesso definiscono i comportamenti dei trigger come parte dello stile predefinito nei temi. L'impostazione di proprietà locali sui controlli può impedire ai trigger di essere in grado di rispondere agli eventi generati dagli utenti sia da un punto di vista visivo sia da un punto di vista di comportamento. L'uso più comune di un trigger di proprietà è per le proprietà di controllo o di stato, ad esempio <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A>. Per impostazione predefinita, ad esempio, quando un <xref:System.Windows.Controls.Button> è disabilitato (il trigger per <xref:System.Windows.UIElement.IsEnabled%2A> è `false`), il valore di <xref:System.Windows.Controls.Control.Foreground%2A> nello stile del tema è quello che fa sì che il controllo venga visualizzato in grigio. Tuttavia, se è stato impostato un valore di <xref:System.Windows.Controls.Control.Foreground%2A> locale, il normale colore grigio viene sovraregolato in base alla priorità del set di proprietà locali, anche in questo scenario attivato dalla proprietà. Prestare attenzione nell'impostazione di valori per proprietà che presentano comportamenti di trigger a livello di tema e accertarsi di non interferire impropriamente con l'esperienza utente prevista per quel controllo.  
  
<a name="clearvalue"></a>   
## <a name="clearvalue-and-value-precedence"></a>ClearValue e precedenza dei valori  
 Il metodo <xref:System.Windows.DependencyObject.ClearValue%2A> fornisce un espediente per cancellare qualsiasi valore applicato localmente da una proprietà di dipendenza impostata su un elemento. Tuttavia, la chiamata di <xref:System.Windows.DependencyObject.ClearValue%2A> non garantisce che l'impostazione predefinita, come stabilito nei metadati durante la registrazione della proprietà, sia il nuovo valore effettivo. Tutti gli altri partecipanti nella precedenza dei valori sono ancora attivi. Solo il valore impostato localmente è stato rimosso dalla sequenza di precedenza. Se ad esempio si chiama <xref:System.Windows.DependencyObject.ClearValue%2A> su una proprietà in cui tale proprietà viene impostata anche da uno stile del tema, il valore del tema viene applicato come nuovo valore anziché come predefinito basato sui metadati. Se si desidera che tutti i partecipanti del valore della proprietà vengano esclusi dal processo e il valore venga impostato sull'impostazione predefinita dei metadati registrati, è possibile ottenere tale valore predefinito eseguendo una query sui metadati della proprietà di dipendenza, quindi è possibile utilizzare il valore predefinito per impostare localmente la proprietà con una chiamata a <xref:System.Windows.DependencyObject.SetValue%2A>.  
  
## <a name="see-also"></a>Vedere anche

- <xref:System.Windows.DependencyObject>
- <xref:System.Windows.DependencyProperty>
- [Cenni preliminari sulle proprietà di dipendenza](dependency-properties-overview.md)
- [Proprietà di dipendenza personalizzate](custom-dependency-properties.md)
- [Callback e convalida delle proprietà di dipendenza](dependency-property-callbacks-and-validation.md)
