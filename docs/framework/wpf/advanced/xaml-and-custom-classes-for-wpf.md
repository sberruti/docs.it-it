---
title: Classi XAML e personalizzate per WPF
ms.date: 03/30/2017
helpviewer_keywords:
- custom classes in XAML [WPF]
- XAML [WPF], custom classes
- classes [WPF], custom classes in XAML
ms.assetid: e7313137-581e-4a64-8453-d44e15a6164a
ms.openlocfilehash: aa2dd7a5c30894f85ed1d4aae0228b76ece3c005
ms.sourcegitcommit: f8c36054eab877de4d40a705aacafa2552ce70e9
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 12/31/2019
ms.locfileid: "75559872"
---
# <a name="xaml-and-custom-classes-for-wpf"></a><span data-ttu-id="5eea0-102">Classi XAML e personalizzate per WPF</span><span class="sxs-lookup"><span data-stu-id="5eea0-102">XAML and Custom Classes for WPF</span></span>
<span data-ttu-id="5eea0-103">XAML come implementato nei Framework Common Language Runtime (CLR) supporta la possibilità di definire una classe o una struttura personalizzata in qualsiasi linguaggio Common Language Runtime (CLR), quindi accedere a tale classe usando il markup XAML.</span><span class="sxs-lookup"><span data-stu-id="5eea0-103">XAML as implemented in common language runtime (CLR) frameworks supports the ability to define a custom class or structure in any common language runtime (CLR) language, and then access that class using XAML markup.</span></span> <span data-ttu-id="5eea0-104">All'interno dello stesso file di markup è possibile usare una combinazione di tipi definiti da [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] e di tipi personalizzati, in genere tramite mapping dei tipi personalizzati al prefisso di uno spazio dei nomi XAML.</span><span class="sxs-lookup"><span data-stu-id="5eea0-104">You can use a mixture of [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]-defined types and your custom types within the same markup file, typically by mapping the custom types to a XAML namespace prefix.</span></span> <span data-ttu-id="5eea0-105">Questo argomento descrive i requisiti che una classe personalizzata deve soddisfare perché sia utilizzabile come elemento XAML.</span><span class="sxs-lookup"><span data-stu-id="5eea0-105">This topic discusses the requirements that a custom class must satisfy to be usable as a XAML element.</span></span>  

<a name="Custom_Classes_in_Applications_vs__in_Assemblies"></a>   
## <a name="custom-classes-in-applications-or-assemblies"></a><span data-ttu-id="5eea0-106">Classi personalizzate in applicazioni o assembly</span><span class="sxs-lookup"><span data-stu-id="5eea0-106">Custom Classes in Applications or Assemblies</span></span>  
 <span data-ttu-id="5eea0-107">È possibile definire classi personalizzate da usare in XAML in due modi distinti: all'interno del code-behind o di altro codice che generi l'applicazione [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] primaria o come classe di un assembly separato, ad esempio un eseguibile o una DLL usata come libreria di classi.</span><span class="sxs-lookup"><span data-stu-id="5eea0-107">Custom classes that are used in XAML can be defined in two distinct ways: within the code-behind or other code that produces the primary [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] application, or as a class in a separate assembly, such as an executable or DLL used as a class library.</span></span> <span data-ttu-id="5eea0-108">Ognuno di questi approcci presenta vantaggi e svantaggi specifici.</span><span class="sxs-lookup"><span data-stu-id="5eea0-108">Each of these approaches has particular advantages and disadvantages.</span></span>  
  
- <span data-ttu-id="5eea0-109">Il vantaggio della creazione di una libreria di classi consiste nella possibilità di condividere tutte queste classi personalizzate tra un gran numero di applicazioni diverse.</span><span class="sxs-lookup"><span data-stu-id="5eea0-109">The advantage of creating a class library is that any such custom classes can be shared across many different possible applications.</span></span> <span data-ttu-id="5eea0-110">Una libreria separata, poi, rende più semplice il controllo delle versioni delle applicazioni in caso di problemi e facilita la creazione di classi destinate a fungere da elementi radice di una pagina XAML.</span><span class="sxs-lookup"><span data-stu-id="5eea0-110">A separate library also makes versioning issues of applications easier to control, and simplifies creating a class where the intended class usage is as a root element on a XAML page.</span></span>  
  
- <span data-ttu-id="5eea0-111">Il vantaggio di poter definire classi personalizzate all'interno dell'applicazione consiste nel fatto che si tratta di una tecnica relativamente leggera in grado di ridurre al minimo i problemi di distribuzione e test che si riscontrano quando, oltre al file eseguibile dell'applicazione principale, si introducono assembly separati.</span><span class="sxs-lookup"><span data-stu-id="5eea0-111">The advantage of defining the custom classes in the application is that this technique is relatively lightweight and minimizes the deployment and testing issues encountered when you introduce separate assemblies beyond the main application executable.</span></span>  
  
- <span data-ttu-id="5eea0-112">Che le classi personalizzate vengano definite all'interno dello stesso assembly o in un assembly diverso, perché siano utilizzabili come elementi in XAML è necessario effettuarne il mapping tra lo spazio dei nomi CLR e quello XML.</span><span class="sxs-lookup"><span data-stu-id="5eea0-112">Whether defined in the same or different assembly, custom classes need to be mapped between CLR  namespace and XML  namespace in order to be used in XAML as elements.</span></span> <span data-ttu-id="5eea0-113">Vedere [Spazi dei nomi XAML e mapping dello spazio dei nomi per XAML WPF](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="5eea0-113">See [XAML Namespaces and Namespace Mapping for WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span></span>  
  
<a name="Requirements_for_a_Custom_Class_as_a_XAML_Element"></a>   
## <a name="requirements-for-a-custom-class-as-a-xaml-element"></a><span data-ttu-id="5eea0-114">Requisiti per una classe personalizzata come elemento XAML</span><span class="sxs-lookup"><span data-stu-id="5eea0-114">Requirements for a Custom Class as a XAML Element</span></span>  
 <span data-ttu-id="5eea0-115">Perché sia possibile crearne un'istanza come elemento oggetto, la classe deve soddisfare i requisiti seguenti:</span><span class="sxs-lookup"><span data-stu-id="5eea0-115">In order to be able to be instantiated as an object element, your class must meet the following requirements:</span></span>  
  
- <span data-ttu-id="5eea0-116">Deve essere pubblica e supportare un costruttore pubblico senza parametri predefinito.</span><span class="sxs-lookup"><span data-stu-id="5eea0-116">Your custom class must be public and support a default (parameterless) public constructor.</span></span> <span data-ttu-id="5eea0-117">Per alcune note riguardanti le strutture, vedere la sezione seguente.</span><span class="sxs-lookup"><span data-stu-id="5eea0-117">(See following section for notes regarding structures.)</span></span>  
  
- <span data-ttu-id="5eea0-118">La classe personalizzata non deve essere una classe annidata.</span><span class="sxs-lookup"><span data-stu-id="5eea0-118">Your custom class must not be a nested class.</span></span> <span data-ttu-id="5eea0-119">Le classi annidate e il punto presente nella relativa sintassi di utilizzo CLR generale interferiscono con altre funzionalità di [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] e/o di XAML, ad esempio le proprietà collegate.</span><span class="sxs-lookup"><span data-stu-id="5eea0-119">Nested classes and the "dot" in their general CLR usage syntax interfere with other [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] and/or XAML features such as attached properties.</span></span>  
  
 <span data-ttu-id="5eea0-120">Oltre ad abilitare la sintassi degli elementi oggetto, la definizione dell'oggetto abilita la sintassi degli elementi proprietà per tutte le altre proprietà pubbliche che accettano tale oggetto come tipo valore.</span><span class="sxs-lookup"><span data-stu-id="5eea0-120">In addition to enabling object element syntax, your object definition also enables property element syntax for any other public properties that take that object as the value type.</span></span> <span data-ttu-id="5eea0-121">Ciò è dovuto al fatto che è ora possibile creare un'istanza dell'oggetto come elemento oggetto e inserirla come valore dell'elemento di tale proprietà.</span><span class="sxs-lookup"><span data-stu-id="5eea0-121">This is because the object can now be instantiated as an object element and can fill the property element value of such a property.</span></span>  
  
### <a name="structures"></a><span data-ttu-id="5eea0-122">Strutture</span><span class="sxs-lookup"><span data-stu-id="5eea0-122">Structures</span></span>  
 <span data-ttu-id="5eea0-123">Le strutture definite come tipi personalizzati sono sempre in grado di essere costruite in XAML in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]. Ciò è dovuto al fatto che i compilatori CLR creano implicitamente un costruttore senza parametri per una struttura che Inizializza i valori predefiniti di tutti i valori delle proprietà.</span><span class="sxs-lookup"><span data-stu-id="5eea0-123">Structures that you define as custom types are always able to be constructed in XAML  in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] .This is because the CLR compilers implicitly create a parameterless constructor for a structure that initializes all property values to their defaults.</span></span> <span data-ttu-id="5eea0-124">In alcuni casi il comportamento predefinito relativo alla costruzione e/o all'utilizzo degli elementi oggetto per una struttura non è consigliabile.</span><span class="sxs-lookup"><span data-stu-id="5eea0-124">In some cases, the default construction behavior and/or object element usage for a structure is not desirable.</span></span> <span data-ttu-id="5eea0-125">Ciò può essere dovuto al fatto che la struttura ha lo scopo di inserire valori e, dal punto di vista concettuale, di funzionare come un'unione, mentre i valori contenuti potrebbero essere interpretabili come reciprocamente esclusivi. Pertanto, non è possibile impostare alcuna delle proprietà della struttura.</span><span class="sxs-lookup"><span data-stu-id="5eea0-125">This might be because the structure is intended to fill values and function conceptually as a union, where the values contained might have mutually exclusive interpretations and thus none of its properties are settable.</span></span> <span data-ttu-id="5eea0-126">Viene <xref:System.Windows.GridLength>un [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] esempio di tale struttura.</span><span class="sxs-lookup"><span data-stu-id="5eea0-126">A [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] example of such a structure is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="5eea0-127">In genere, tali strutture devono implementare un convertitore di tipi che consenta di esprimere i valori sotto forma di attributo tramite convenzioni di stringa che creano interpretazioni o modalità diverse dei valori della struttura.</span><span class="sxs-lookup"><span data-stu-id="5eea0-127">Generally, such structures should implement a type converter such that the values can be expressed in attribute form, using string conventions that create the different interpretations or modes of the structure's values.</span></span> <span data-ttu-id="5eea0-128">La struttura deve anche esporre un comportamento simile per la costruzione del codice tramite un costruttore senza parametri.</span><span class="sxs-lookup"><span data-stu-id="5eea0-128">The structure should also expose similar behavior for code construction through a non-parameterless constructor.</span></span>  
  
<a name="Requirements_for_Properties_of_a_Custom_Class_as_XAML"></a>   
## <a name="requirements-for-properties-of-a-custom-class-as-xaml-attributes"></a><span data-ttu-id="5eea0-129">Requisiti per le proprietà di classi personalizzate come attributi XAML</span><span class="sxs-lookup"><span data-stu-id="5eea0-129">Requirements for Properties of a Custom Class as XAML Attributes</span></span>  
 <span data-ttu-id="5eea0-130">Le proprietà devono fare riferimento a un tipo in base al valore (ad esempio una primitiva) o usare una classe per il tipo che ha un costruttore senza parametri o un convertitore di tipi dedicato a cui un processore XAML può accedere.</span><span class="sxs-lookup"><span data-stu-id="5eea0-130">Properties must reference a by-value type (such as a primitive), or use a class for type that has either a parameterless constructor or a dedicated type converter that a XAML processor can access.</span></span> <span data-ttu-id="5eea0-131">Nell'implementazione XAML di CLR, i processori XAML trovano questi convertitori tramite il supporto nativo per le primitive di linguaggio o tramite l'applicazione di <xref:System.ComponentModel.TypeConverterAttribute> a un tipo o a un membro nelle definizioni di tipi di supporto</span><span class="sxs-lookup"><span data-stu-id="5eea0-131">In the CLR XAML implementation, XAML processors either find such converters through native support for language primitives, or through application of <xref:System.ComponentModel.TypeConverterAttribute> to a type or member in backing type definitions</span></span>  
  
 <span data-ttu-id="5eea0-132">In alternativa, la proprietà può fare riferimento a un tipo di una classe astratta oppure a un'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="5eea0-132">Alternatively, the property may reference an abstract class type, or an interface.</span></span> <span data-ttu-id="5eea0-133">Per le classi astratte o le interfacce, l'aspettativa per l'analisi XAML è che il valore della proprietà debba essere popolato con istanze di classi pratiche che implementano l'interfaccia oppure con istanze di tipi che derivano dalla classe astratta.</span><span class="sxs-lookup"><span data-stu-id="5eea0-133">For abstract classes or interfaces, the expectation for XAML parsing is that the property value must be filled with practical class instances that implement the interface, or instances of types that derive from the abstract class.</span></span>  
  
 <span data-ttu-id="5eea0-134">In una classe astratta è possibile dichiarare le proprietà, ma queste possono essere impostate solo per le classi pratiche che derivano dalla classe astratta.</span><span class="sxs-lookup"><span data-stu-id="5eea0-134">Properties can be declared on an abstract class, but can only be set on practical classes that derive from the abstract class.</span></span> <span data-ttu-id="5eea0-135">Questo perché la creazione dell'elemento oggetto per la classe richiede un costruttore pubblico senza parametri sulla classe.</span><span class="sxs-lookup"><span data-stu-id="5eea0-135">This is because creating the object element for the class at all requires a public parameterless constructor on the class.</span></span>  
  
### <a name="typeconverter-enabled-attribute-syntax"></a><span data-ttu-id="5eea0-136">Sintassi degli attributi abilitata per TypeConverter</span><span class="sxs-lookup"><span data-stu-id="5eea0-136">TypeConverter Enabled Attribute Syntax</span></span>  
 <span data-ttu-id="5eea0-137">Se si fornisce un convertitore di tipi dedicato con attributi a livello di classe, la conversione di un tipo abilita la sintassi degli attributi per tutte le proprietà per le quali è necessario creare un'istanza del tipo in questione.</span><span class="sxs-lookup"><span data-stu-id="5eea0-137">If you provide a dedicated, attributed type converter at the class level, the applied type conversion enables attribute syntax for any property that needs to instantiate that type.</span></span> <span data-ttu-id="5eea0-138">Un convertitore di tipi non Abilita l'utilizzo dell'elemento oggetto del tipo. solo la presenza di un costruttore senza parametri per quel tipo Abilita l'utilizzo dell'elemento oggetto.</span><span class="sxs-lookup"><span data-stu-id="5eea0-138">A type converter does not enable object element usage of the type; only the presence of a parameterless constructor for that type enables object element usage.</span></span> <span data-ttu-id="5eea0-139">In genere, pertanto, le proprietà abilitate dal convertitore di tipi possono essere usate nella sintassi delle proprietà solo se il tipo stesso supporta anche la sintassi degli elementi oggetto.</span><span class="sxs-lookup"><span data-stu-id="5eea0-139">Therefore, properties that are type-converter enabled are generally speaking not usable in property syntax, unless the type itself also supports object element syntax.</span></span> <span data-ttu-id="5eea0-140">Eccezione: è possibile specificare la sintassi di elementi proprietà, ma l'elemento proprietà deve contenere una stringa.</span><span class="sxs-lookup"><span data-stu-id="5eea0-140">The exception to this is that you can specify a property element syntax, but have the property element contain a string.</span></span> <span data-ttu-id="5eea0-141">Questo utilizzo è effettivamente essenzialmente equivalente all'utilizzo della sintassi degli attributi e tale utilizzo non è comune a meno che non sia necessaria una gestione più efficace dello spazio vuoto del valore dell'attributo.</span><span class="sxs-lookup"><span data-stu-id="5eea0-141">That usage is really essentially equivalent to an attribute syntax usage, and such a usage is not common unless there is a need for more robust white-space handling of the attribute value.</span></span> <span data-ttu-id="5eea0-142">L'utilizzo degli elementi proprietà riportato di seguito, ad esempio, accetta una stringa e l'equivalente dell'utilizzo dell'attributo:</span><span class="sxs-lookup"><span data-stu-id="5eea0-142">For example, the following is a property element usage that takes a string, and the attribute usage equivalent:</span></span>  
  
 [!code-xaml[XamlOvwSupport#GoofyTCPE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofytcpe)]  
  
 [!code-xaml[XamlOvwSupport#GoofyTCPE2](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofytcpe2)]  
  
 <span data-ttu-id="5eea0-143">Esempi di proprietà in cui è consentita la sintassi degli attributi ma la sintassi dell'elemento proprietà che contiene un elemento oggetto non è consentita tramite XAML sono varie proprietà che accettano il tipo di <xref:System.Windows.Input.Cursor>.</span><span class="sxs-lookup"><span data-stu-id="5eea0-143">Examples of properties where attribute syntax is allowed but property element syntax that contains an object element is disallowed through XAML are various properties that take the <xref:System.Windows.Input.Cursor> type.</span></span> <span data-ttu-id="5eea0-144">La classe <xref:System.Windows.Input.Cursor> dispone di un convertitore di tipi dedicato <xref:System.Windows.Input.CursorConverter>, ma non espone un costruttore senza parametri, quindi la proprietà <xref:System.Windows.FrameworkElement.Cursor%2A> può essere impostata solo tramite la sintassi dell'attributo, anche se il tipo di <xref:System.Windows.Input.Cursor> effettivo è un tipo riferimento.</span><span class="sxs-lookup"><span data-stu-id="5eea0-144">The <xref:System.Windows.Input.Cursor> class has a dedicated type converter <xref:System.Windows.Input.CursorConverter>, but does not expose a parameterless constructor, so the <xref:System.Windows.FrameworkElement.Cursor%2A> property can only be set through attribute syntax even though the actual <xref:System.Windows.Input.Cursor> type is a reference type.</span></span>  
  
### <a name="per-property-type-converters"></a><span data-ttu-id="5eea0-145">Convertitori di tipi per proprietà</span><span class="sxs-lookup"><span data-stu-id="5eea0-145">Per-Property Type Converters</span></span>  
 <span data-ttu-id="5eea0-146">In alternativa, la proprietà stessa può dichiarare un convertitore di tipi a livello di proprietà.</span><span class="sxs-lookup"><span data-stu-id="5eea0-146">Alternatively, the property itself may declare a type converter at the property level.</span></span> <span data-ttu-id="5eea0-147">In questo modo viene abilitato un "linguaggio mini" che crea un'istanza di oggetti del tipo della proprietà inline, elaborando i valori stringa in ingresso dell'attributo come input per un'operazione di <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> basata sul tipo appropriato.</span><span class="sxs-lookup"><span data-stu-id="5eea0-147">This enables a "mini language" that instantiates objects of the type of the property inline, by processing incoming string values of the attribute as input for a <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> operation based on the appropriate type.</span></span> <span data-ttu-id="5eea0-148">In genere questa operazione viene eseguita per fornire una funzione di accesso pratica e non come unico mezzo per consentire l'impostazione di una proprietà in XAML.</span><span class="sxs-lookup"><span data-stu-id="5eea0-148">Typically this is done to provide a convenience accessor, and not as the sole means to enable setting a property in XAML.</span></span> <span data-ttu-id="5eea0-149">Tuttavia, è anche possibile usare convertitori di tipi per gli attributi in cui si vogliono usare i tipi CLR esistenti che non forniscono un costruttore senza parametri o un convertitore di tipi con attributi.</span><span class="sxs-lookup"><span data-stu-id="5eea0-149">However, it is also possible to use type converters for attributes where you want to use existing CLR types that do not supply either a parameterless constructor or an attributed type converter.</span></span> <span data-ttu-id="5eea0-150">Gli esempi dell'API [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] sono alcune proprietà che accettano il tipo di <xref:System.Globalization.CultureInfo>.</span><span class="sxs-lookup"><span data-stu-id="5eea0-150">Examples from the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] API are certain properties that take the <xref:System.Globalization.CultureInfo> type.</span></span> <span data-ttu-id="5eea0-151">In questo caso, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] utilizzato il tipo di <xref:System.Globalization.CultureInfo> Framework di Microsoft .NET esistente per migliorare gli scenari di compatibilità e migrazione utilizzati nelle versioni precedenti dei Framework, ma il tipo di <xref:System.Globalization.CultureInfo> non supportava i costruttori necessari o la conversione del tipo a livello di tipo in modo che sia possibile utilizzarli direttamente come valore di proprietà XAML.</span><span class="sxs-lookup"><span data-stu-id="5eea0-151">In this case, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] used the existing Microsoft .NET Framework <xref:System.Globalization.CultureInfo> type to better address compatibility and migration scenarios that were used in earlier versions of frameworks, but the <xref:System.Globalization.CultureInfo> type did not support the necessary constructors or type-level type conversion to be usable as a XAML property value directly.</span></span>  
  
 <span data-ttu-id="5eea0-152">Ogni volta che si espone una proprietà con utilizzo in XAML, in particolare se l'utente è un autore di controlli, è consigliabile supportare tale proprietà con una proprietà di dipendenza.</span><span class="sxs-lookup"><span data-stu-id="5eea0-152">Whenever you expose a property that has a XAML usage, particularly if you are a control author, you should strongly consider backing that property with a dependency property.</span></span> <span data-ttu-id="5eea0-153">Ciò è particolarmente vero se si usa l'implementazione [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] esistente del processore XAML, perché è possibile migliorare le prestazioni usando <xref:System.Windows.DependencyProperty> il backup.</span><span class="sxs-lookup"><span data-stu-id="5eea0-153">This is particularly true if you use the existing [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] implementation of the XAML processor, because you can improve performance by using <xref:System.Windows.DependencyProperty> backing.</span></span> <span data-ttu-id="5eea0-154">Una proprietà di dipendenza espone le funzionalità del sistema di proprietà relative alla proprietà in questione che gli utenti si aspettano da una proprietà accessibile tramite XAML,</span><span class="sxs-lookup"><span data-stu-id="5eea0-154">A dependency property will expose property system features for your property that users will come to expect for a XAML accessible property.</span></span> <span data-ttu-id="5eea0-155">ad esempio funzionalità quali l'animazione, il data binding e il supporto degli stili.</span><span class="sxs-lookup"><span data-stu-id="5eea0-155">This includes features such as animation, data binding, and style support.</span></span> <span data-ttu-id="5eea0-156">Per altre informazioni, vedere [Proprietà di dipendenza personalizzate](custom-dependency-properties.md) e [Caricamento XAML e proprietà di dipendenza](xaml-loading-and-dependency-properties.md).</span><span class="sxs-lookup"><span data-stu-id="5eea0-156">For more information, see [Custom Dependency Properties](custom-dependency-properties.md) and [XAML Loading and Dependency Properties](xaml-loading-and-dependency-properties.md).</span></span>  
  
### <a name="writing-and-attributing-a-type-converter"></a><span data-ttu-id="5eea0-157">Scrittura e assegnazione di un convertitore di tipi</span><span class="sxs-lookup"><span data-stu-id="5eea0-157">Writing and Attributing a Type Converter</span></span>  
 <span data-ttu-id="5eea0-158">Occasionalmente è necessario scrivere un <xref:System.ComponentModel.TypeConverter> classe derivata personalizzata per fornire la conversione del tipo per il tipo di proprietà.</span><span class="sxs-lookup"><span data-stu-id="5eea0-158">You occasionally will need to write a custom <xref:System.ComponentModel.TypeConverter> derived class to provide type conversion for your property type.</span></span> <span data-ttu-id="5eea0-159">Per istruzioni su come derivare da e creare un convertitore di tipi in grado di supportare gli utilizzi XAML e come applicare la <xref:System.ComponentModel.TypeConverterAttribute>, vedere [TypeConverter e XAML](typeconverters-and-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="5eea0-159">For instructions on how to derive from and create a type converter that can support XAML usages, and how to apply the <xref:System.ComponentModel.TypeConverterAttribute>, see [TypeConverters and XAML](typeconverters-and-xaml.md).</span></span>  
  
<a name="Requirements_for_Events_of_a_Custom_Class_as_XAML"></a>   
## <a name="requirements-for-xaml-event-handler-attribute-syntax-on-events-of-a-custom-class"></a><span data-ttu-id="5eea0-160">Requisiti per la sintassi degli attributi del gestore eventi XAML per gli eventi di una classe personalizzata</span><span class="sxs-lookup"><span data-stu-id="5eea0-160">Requirements for XAML Event Handler Attribute Syntax on Events of a Custom Class</span></span>  
 <span data-ttu-id="5eea0-161">Per essere utilizzabile come evento CLR, l'evento deve essere esposto come evento pubblico in una classe che supporta un costruttore senza parametri o in una classe astratta in cui è possibile accedere all'evento sulle classi derivate.</span><span class="sxs-lookup"><span data-stu-id="5eea0-161">To be usable as a CLR event, the event must be exposed as a public event on a class that supports a parameterless constructor, or on an abstract class where the event can be accessed on derived classes.</span></span> <span data-ttu-id="5eea0-162">Per essere utilizzato in modo pratico come un evento indirizzato, l'evento CLR deve implementare metodi espliciti `add` e `remove`, che aggiungono e rimuovono gestori per la firma dell'evento CLR e inoltrano tali gestori ai metodi <xref:System.Windows.UIElement.AddHandler%2A> e <xref:System.Windows.UIElement.RemoveHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="5eea0-162">In order to be used conveniently as a routed event, your CLR event should implement explicit `add` and `remove` methods, which add and remove handlers for the CLR event signature and forward those handlers to the <xref:System.Windows.UIElement.AddHandler%2A> and <xref:System.Windows.UIElement.RemoveHandler%2A> methods.</span></span> <span data-ttu-id="5eea0-163">Questi metodi aggiungono o rimuovono i gestori dall'archivio dei gestori degli eventi indirizzati per l'istanza a cui l'evento è associato.</span><span class="sxs-lookup"><span data-stu-id="5eea0-163">These methods add or remove the handlers to the routed event handler store on the instance that the event is attached to.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="5eea0-164">È possibile registrare i gestori direttamente per gli eventi indirizzati usando <xref:System.Windows.UIElement.AddHandler%2A>e non definire intenzionalmente un evento CLR che espone l'evento indirizzato.</span><span class="sxs-lookup"><span data-stu-id="5eea0-164">It is possible to register handlers directly for routed events using <xref:System.Windows.UIElement.AddHandler%2A>, and to deliberately not define a CLR event that exposes the routed event.</span></span> <span data-ttu-id="5eea0-165">Questa operazione non è in genere consigliata. In questo caso, infatti, per l'evento non è abilitata la sintassi degli attributi XAML per il collegamento di gestori e nella classe risultante il codice XAML relativo alle caratteristiche del tipo è meno chiaro.</span><span class="sxs-lookup"><span data-stu-id="5eea0-165">This is not generally recommended because the event will not enable XAML attribute syntax for attaching handlers, and your resulting class will offer a less transparent XAML view of that type's capabilities.</span></span>  
  
<a name="Collection_Properties"></a>   
## <a name="writing-collection-properties"></a><span data-ttu-id="5eea0-166">Scrittura delle proprietà delle raccolte</span><span class="sxs-lookup"><span data-stu-id="5eea0-166">Writing Collection Properties</span></span>  
 <span data-ttu-id="5eea0-167">Le proprietà che accettano un tipo di raccolta hanno una sintassi XAML che consente di specificare gli oggetti da aggiungere alla raccolta.</span><span class="sxs-lookup"><span data-stu-id="5eea0-167">Properties that take a collection type have a XAML syntax that enables you to specify objects that are added to the collection.</span></span> <span data-ttu-id="5eea0-168">Questa sintassi presenta due funzionalità di rilievo.</span><span class="sxs-lookup"><span data-stu-id="5eea0-168">This syntax has two notable features.</span></span>  
  
- <span data-ttu-id="5eea0-169">Nella sintassi dell'elemento oggetto non è necessario specificare l'oggetto che rappresenta l'oggetto Collection.</span><span class="sxs-lookup"><span data-stu-id="5eea0-169">The object that is the collection object does not need to be specified in object element syntax.</span></span> <span data-ttu-id="5eea0-170">Ogni volta che in XAML si specifica una proprietà che accetta un tipo di raccolta, tale tipo di raccolta è implicito.</span><span class="sxs-lookup"><span data-stu-id="5eea0-170">The presence of that collection type is implicit whenever you specify a property in XAML that takes a collection type.</span></span>  
  
- <span data-ttu-id="5eea0-171">Gli elementi figlio della proprietà della raccolta nel markup vengono elaborati in modo che diventino membri della raccolta.</span><span class="sxs-lookup"><span data-stu-id="5eea0-171">Child elements of the collection property in markup are processed to become members of the collection.</span></span> <span data-ttu-id="5eea0-172">In genere l'accesso del codice ai membri di una raccolta avviene tramite metodi di elenco o dizionario, ad esempio `Add`, oppure tramite un indicizzatore.</span><span class="sxs-lookup"><span data-stu-id="5eea0-172">Ordinarily, the code access to the members of a collection is performed through list/dictionary methods such as `Add`, or through an indexer.</span></span> <span data-ttu-id="5eea0-173">La sintassi XAML, tuttavia, non supporta metodi o indicizzatori, ad eccezione di XAML 2009, che supporta i metodi. L'uso di XAML 2009, però, limita i possibili utilizzi di WPF. Vedere [Funzionalità del linguaggio XAML 2009](../../../desktop-wpf/xaml-services/xaml-2009-language-features.md).</span><span class="sxs-lookup"><span data-stu-id="5eea0-173">But XAML syntax does not support methods or indexers (exception: XAML 2009 can support methods, but using XAML 2009 restricts the possible WPF usages; see [XAML 2009 Language Features](../../../desktop-wpf/xaml-services/xaml-2009-language-features.md)).</span></span> <span data-ttu-id="5eea0-174">Le raccolte sono ovviamente un requisito molto comune per la creazione di un albero di elementi. È quindi necessario individuare il modo più adatto per popolarle in XAML dichiarativo.</span><span class="sxs-lookup"><span data-stu-id="5eea0-174">Collections are obviously a very common requirement for building a tree of elements, and you need some way to populate these collections in declarative XAML.</span></span> <span data-ttu-id="5eea0-175">Pertanto, gli elementi figlio di una proprietà della raccolta vengono elaborati aggiungendoli alla raccolta che rappresenta il valore del tipo della proprietà.</span><span class="sxs-lookup"><span data-stu-id="5eea0-175">Therefore, child elements of a collection property are processed by adding them to the collection that is the collection property type value.</span></span>  
  
 <span data-ttu-id="5eea0-176">La definizione di proprietà di raccolta per l'implementazione dei servizi XAML di .NET Framework e quindi anche per il processore XAML di WPF è la seguente.</span><span class="sxs-lookup"><span data-stu-id="5eea0-176">The .NET Framework XAML Services implementation and thus the WPF XAML processor uses the following definition for what constitutes a collection property.</span></span> <span data-ttu-id="5eea0-177">Il tipo della proprietà deve soddisfare una delle condizioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="5eea0-177">The property type of the property must implement one of the following:</span></span>  
  
- <span data-ttu-id="5eea0-178">Implementa <xref:System.Collections.IList>.</span><span class="sxs-lookup"><span data-stu-id="5eea0-178">Implements <xref:System.Collections.IList>.</span></span>  
  
- <span data-ttu-id="5eea0-179">Implementa <xref:System.Collections.IDictionary> o l'equivalente generico (<xref:System.Collections.Generic.IDictionary%602>).</span><span class="sxs-lookup"><span data-stu-id="5eea0-179">Implements <xref:System.Collections.IDictionary> or the generic equivalent (<xref:System.Collections.Generic.IDictionary%602>).</span></span>  
  
- <span data-ttu-id="5eea0-180">Deriva da <xref:System.Array> (per altre informazioni sulle matrici in XAML, vedere estensione di [markup x:Array](../../../desktop-wpf/xaml-services/xarray-markup-extension.md)).</span><span class="sxs-lookup"><span data-stu-id="5eea0-180">Derives from <xref:System.Array> (for more information about arrays in XAML, see [x:Array Markup Extension](../../../desktop-wpf/xaml-services/xarray-markup-extension.md).)</span></span>  
  
- <span data-ttu-id="5eea0-181">Implementa <xref:System.Windows.Markup.IAddChild> (un'interfaccia definita da [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]).</span><span class="sxs-lookup"><span data-stu-id="5eea0-181">Implements <xref:System.Windows.Markup.IAddChild> (an interface defined by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]).</span></span>  
  
 <span data-ttu-id="5eea0-182">In CLR ognuno di questi tipi dispone di un metodo `Add`, usato dal processore XAML per aggiungere elementi alla raccolta sottostante durante la creazione dell'oggetto grafico.</span><span class="sxs-lookup"><span data-stu-id="5eea0-182">Each of these types in CLR has an `Add` method, which is used by the XAML processor to add items to the underlying collection when creating the object graph.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="5eea0-183">Le interfacce di `List` e `Dictionary` generiche (<xref:System.Collections.Generic.IList%601> e <xref:System.Collections.Generic.IDictionary%602>) non sono supportate per il rilevamento della raccolta da parte del processore XAML di [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span><span class="sxs-lookup"><span data-stu-id="5eea0-183">The generic `List` and `Dictionary` interfaces (<xref:System.Collections.Generic.IList%601> and <xref:System.Collections.Generic.IDictionary%602>) are not supported for collection detection by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML processor.</span></span> <span data-ttu-id="5eea0-184">Tuttavia, è possibile usare la classe <xref:System.Collections.Generic.List%601> come classe base, perché implementa direttamente <xref:System.Collections.IList> o <xref:System.Collections.Generic.Dictionary%602> come classe di base, perché implementa <xref:System.Collections.IDictionary> direttamente.</span><span class="sxs-lookup"><span data-stu-id="5eea0-184">However, you can use the <xref:System.Collections.Generic.List%601> class as a base class, because it implements <xref:System.Collections.IList> directly, or <xref:System.Collections.Generic.Dictionary%602> as a base class, because it implements <xref:System.Collections.IDictionary> directly.</span></span>  
  
 <span data-ttu-id="5eea0-185">Quando si dichiara una proprietà che accetta una raccolta, prestare attenzione alla modalità di inizializzazione del valore di questa proprietà nelle nuove istanze del tipo.</span><span class="sxs-lookup"><span data-stu-id="5eea0-185">When you declare a property that takes a collection, be cautious about how that property value is initialized in new instances of the type.</span></span> <span data-ttu-id="5eea0-186">Se non si implementa la proprietà come proprietà di dipendenza, è adeguato che la proprietà usi un campo sottostante che chiami il costruttore del tipo della raccolta.</span><span class="sxs-lookup"><span data-stu-id="5eea0-186">If you are not implementing the property as a dependency property, then having the property use a backing field that calls the collection type constructor is adequate.</span></span> <span data-ttu-id="5eea0-187">Se la proprietà è una proprietà di dipendenza, potrebbe essere necessario inizializzare la proprietà della raccolta come parte del costruttore del tipo predefinito.</span><span class="sxs-lookup"><span data-stu-id="5eea0-187">If your property is a dependency property, then you may need to initialize the collection property as part of the default type constructor.</span></span> <span data-ttu-id="5eea0-188">Ciò è dovuto al fatto che il valore predefinito di una proprietà di dipendenza proviene dai metadati e in genere è necessario evitare che il valore iniziale di una proprietà di una raccolta corrisponda a una raccolta condivisa statica.</span><span class="sxs-lookup"><span data-stu-id="5eea0-188">This is because a dependency property takes its default value from metadata, and you typically do not want the initial value of a collection property to be a static, shared collection.</span></span> <span data-ttu-id="5eea0-189">Deve esistere un'istanza della raccolta per ogni istanza del tipo che la contiene.</span><span class="sxs-lookup"><span data-stu-id="5eea0-189">There should be a collection instance per each containing type instance.</span></span> <span data-ttu-id="5eea0-190">Per altre informazioni, vedere [Proprietà Dependency personalizzate](custom-dependency-properties.md).</span><span class="sxs-lookup"><span data-stu-id="5eea0-190">For more information, see [Custom Dependency Properties](custom-dependency-properties.md).</span></span>  
  
 <span data-ttu-id="5eea0-191">Per la proprietà della raccolta è possibile implementare un tipo di raccolta personalizzato.</span><span class="sxs-lookup"><span data-stu-id="5eea0-191">You can implement a custom collection type for your collection property.</span></span> <span data-ttu-id="5eea0-192">A causa del trattamento implicito della proprietà della raccolta, non è necessario che il tipo di raccolta personalizzato fornisca un costruttore senza parametri per poter essere usato in modo implicito in XAML.</span><span class="sxs-lookup"><span data-stu-id="5eea0-192">Because of implicit collection property treatment, the custom collection type does not need to provide a parameterless constructor in order to be used in XAML implicitly.</span></span> <span data-ttu-id="5eea0-193">Tuttavia, è possibile specificare facoltativamente un costruttore senza parametri per il tipo di raccolta.</span><span class="sxs-lookup"><span data-stu-id="5eea0-193">However, you can optionally provide a parameterless constructor for the collection type.</span></span> <span data-ttu-id="5eea0-194">Questo modo di procedere può risultare utile.</span><span class="sxs-lookup"><span data-stu-id="5eea0-194">This can be a worthwhile practice.</span></span> <span data-ttu-id="5eea0-195">A meno che non si fornisca un costruttore senza parametri, non è possibile dichiarare in modo esplicito la raccolta come elemento oggetto.</span><span class="sxs-lookup"><span data-stu-id="5eea0-195">Unless you do provide a parameterless constructor, you cannot explicitly declare the collection as an object element.</span></span> <span data-ttu-id="5eea0-196">Alcuni autori di markup interpretano la dichiarazione esplicita di una raccolta come una questione di stile di markup.</span><span class="sxs-lookup"><span data-stu-id="5eea0-196">Some markup authors might prefer to see the explicit collection as a matter of markup style.</span></span> <span data-ttu-id="5eea0-197">Inoltre, un costruttore senza parametri può semplificare i requisiti di inizializzazione quando si creano nuovi oggetti che usano il tipo di raccolta come valore della proprietà.</span><span class="sxs-lookup"><span data-stu-id="5eea0-197">Also, a parameterless constructor can simplify the initialization requirements when you create new objects that use your collection type as a property value.</span></span>  
  
<a name="XAMLCONtent"></a>   
## <a name="declaring-xaml-content-properties"></a><span data-ttu-id="5eea0-198">Dichiarazione di proprietà di contenuto XAML</span><span class="sxs-lookup"><span data-stu-id="5eea0-198">Declaring XAML Content Properties</span></span>  
 <span data-ttu-id="5eea0-199">Nel linguaggio XAML è definito il concetto di proprietà di contenuto [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="5eea0-199">The XAML language defines the concept of a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] content property.</span></span> <span data-ttu-id="5eea0-200">Ogni classe utilizzabile nella sintassi per gli oggetti può avere una sola proprietà di contenuto XAML.</span><span class="sxs-lookup"><span data-stu-id="5eea0-200">Each class that is usable in object syntax can have exactly one XAML content property.</span></span> <span data-ttu-id="5eea0-201">Per dichiarare una proprietà come proprietà di contenuto XAML per la classe, applicare la <xref:System.Windows.Markup.ContentPropertyAttribute> come parte della definizione della classe.</span><span class="sxs-lookup"><span data-stu-id="5eea0-201">To declare a property to be the XAML content property for your class, apply the <xref:System.Windows.Markup.ContentPropertyAttribute> as part of the class definition.</span></span> <span data-ttu-id="5eea0-202">Specificare il nome della proprietà di contenuto XAML desiderata come <xref:System.Windows.Markup.ContentPropertyAttribute.Name%2A> nell'attributo.</span><span class="sxs-lookup"><span data-stu-id="5eea0-202">Specify the name of the intended XAML content property as the <xref:System.Windows.Markup.ContentPropertyAttribute.Name%2A> in the attribute.</span></span> <span data-ttu-id="5eea0-203">La proprietà viene specificata come stringa in base al nome, non come costrutto di reflection, ad esempio <xref:System.Reflection.PropertyInfo>.</span><span class="sxs-lookup"><span data-stu-id="5eea0-203">The property is specified as a string by name, not as a reflection construct such as <xref:System.Reflection.PropertyInfo>.</span></span>  
  
 <span data-ttu-id="5eea0-204">È possibile specificare una proprietà di raccolta come proprietà del contenuto XAML.</span><span class="sxs-lookup"><span data-stu-id="5eea0-204">You can specify a collection property to be the XAML content property.</span></span> <span data-ttu-id="5eea0-205">Il risultato è un utilizzo di tale proprietà in cui l'elemento oggetto può avere uno o più elementi figlio, senza alcun tag di elementi oggetto Collection o di elementi proprietà.</span><span class="sxs-lookup"><span data-stu-id="5eea0-205">This results in a usage for that property whereby the object element can have one or more child elements, without any intervening collection object elements or property element tags.</span></span> <span data-ttu-id="5eea0-206">Questi elementi vengono considerati come valore per la proprietà del contenuto XAML e vengono aggiunti all'istanza della raccolta sottostante.</span><span class="sxs-lookup"><span data-stu-id="5eea0-206">These elements are then treated as the value for the XAML content property and added to the backing collection instance.</span></span>  
  
 <span data-ttu-id="5eea0-207">Alcune proprietà del contenuto XAML esistenti usano il tipo di proprietà di `Object`.</span><span class="sxs-lookup"><span data-stu-id="5eea0-207">Some existing XAML content properties use the property type of `Object`.</span></span> <span data-ttu-id="5eea0-208">Ciò consente a una proprietà di contenuto XAML che può accettare valori primitivi, ad esempio un <xref:System.String>, nonché di accettare un singolo valore dell'oggetto di riferimento.</span><span class="sxs-lookup"><span data-stu-id="5eea0-208">This enables a XAML content property that can take primitive values such as a <xref:System.String> as well as taking a single reference object value.</span></span> <span data-ttu-id="5eea0-209">Se si segue questo modello, il tipo usato è responsabile della determinazione del tipo, nonché della gestione dei tipi possibili.</span><span class="sxs-lookup"><span data-stu-id="5eea0-209">If you follow this model, your type is responsible for type determination as well as the handling of possible types.</span></span> <span data-ttu-id="5eea0-210">Il motivo tipico di un tipo di contenuto <xref:System.Object> consiste nel supportare sia un mezzo semplice per aggiungere il contenuto dell'oggetto come stringa (che riceve un trattamento di presentazione predefinito), sia un mezzo avanzato per aggiungere il contenuto dell'oggetto che specifica una presentazione non predefinita o dati aggiuntivi.</span><span class="sxs-lookup"><span data-stu-id="5eea0-210">The typical reason for an <xref:System.Object> content type is to support both a simple means of adding object content as a string (which receives a default presentation treatment), or an advanced means of adding object content that specifies a non-default presentation or additional data.</span></span>  
  
<a name="Serializing"></a>   
## <a name="serializing-xaml"></a><span data-ttu-id="5eea0-211">Serializzazione di XAML</span><span class="sxs-lookup"><span data-stu-id="5eea0-211">Serializing XAML</span></span>  
 <span data-ttu-id="5eea0-212">Per alcuni scenari, ad esempio per gli autori di controlli, è anche necessario assicurarsi che qualsiasi rappresentazione di oggetti per cui può essere creata un'istanza in XAML possa anche essere serializzata di nuovo nel markup XAML equivalente.</span><span class="sxs-lookup"><span data-stu-id="5eea0-212">For certain scenarios, such as if you are a control author, you may also want to assure that any object representation that can be instantiated in XAML can also be serialized back to equivalent XAML markup.</span></span> <span data-ttu-id="5eea0-213">I requisiti di serializzazione non sono descritti in questo argomento.</span><span class="sxs-lookup"><span data-stu-id="5eea0-213">Serialization requirements are not described in this topic.</span></span> <span data-ttu-id="5eea0-214">Vedere [Cenni preliminari sulla modifica di controlli](../controls/control-authoring-overview.md) e [Struttura ad albero e serializzazione degli elementi](element-tree-and-serialization.md).</span><span class="sxs-lookup"><span data-stu-id="5eea0-214">See [Control Authoring Overview](../controls/control-authoring-overview.md) and [Element Tree and Serialization](element-tree-and-serialization.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="5eea0-215">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="5eea0-215">See also</span></span>

- [<span data-ttu-id="5eea0-216">Cenni preliminari su XAML (WPF)</span><span class="sxs-lookup"><span data-stu-id="5eea0-216">XAML Overview (WPF)</span></span>](../../../desktop-wpf/fundamentals/xaml.md)
- [<span data-ttu-id="5eea0-217">Proprietà di dipendenza personalizzate</span><span class="sxs-lookup"><span data-stu-id="5eea0-217">Custom Dependency Properties</span></span>](custom-dependency-properties.md)
- [<span data-ttu-id="5eea0-218">Cenni preliminari sulla modifica di controlli</span><span class="sxs-lookup"><span data-stu-id="5eea0-218">Control Authoring Overview</span></span>](../controls/control-authoring-overview.md)
- [<span data-ttu-id="5eea0-219">Cenni preliminari sugli elementi di base</span><span class="sxs-lookup"><span data-stu-id="5eea0-219">Base Elements Overview</span></span>](base-elements-overview.md)
- [<span data-ttu-id="5eea0-220">Caricamento XAML e proprietà di dipendenza</span><span class="sxs-lookup"><span data-stu-id="5eea0-220">XAML Loading and Dependency Properties</span></span>](xaml-loading-and-dependency-properties.md)
