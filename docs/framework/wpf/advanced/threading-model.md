---
title: Modello di threading
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- text on buttons [WPF], updating
- message processing [WPF], nested
- blocking operations [WPF]
- Common Language Runtime (CLR), locking mechanism
- locking mechanism of Common Language Runtime (CLR)
- threading model [WPF]
- Word [WPF], spelling checking
- button text [WPF], updating
- spelling checking in Word [WPF]
- asynchronous behavior [WPF], exposing
- nested message processing [WPF]
- reentrancy [WPF]
ms.assetid: 02d8fd00-8d7c-4604-874c-58e40786770b
ms.openlocfilehash: 550ba74c7ceba16c2040932918364ae2a59ea665
ms.sourcegitcommit: 13e79efdbd589cad6b1de634f5d6b1262b12ab01
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 01/28/2020
ms.locfileid: "76794277"
---
# <a name="threading-model"></a><span data-ttu-id="b1598-102">Modello di threading</span><span class="sxs-lookup"><span data-stu-id="b1598-102">Threading Model</span></span>
[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <span data-ttu-id="b1598-103">è stato progettato per semplificare il threading.</span><span class="sxs-lookup"><span data-stu-id="b1598-103">is designed to save developers from the difficulties of threading.</span></span> <span data-ttu-id="b1598-104">Di conseguenza, la maggior parte dei [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] sviluppatori non dovranno scrivere un'interfaccia che usa più di un thread.</span><span class="sxs-lookup"><span data-stu-id="b1598-104">As a result, the majority of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] developers won't have to write an interface that uses more than one thread.</span></span> <span data-ttu-id="b1598-105">Poiché i programmi con multithreading sono complessi ed è difficile eseguirne il debug, è preferibile evitarli quando sono disponibili soluzioni a thread singolo.</span><span class="sxs-lookup"><span data-stu-id="b1598-105">Because multithreaded programs are complex and difficult to debug, they should be avoided when single-threaded solutions exist.</span></span>

 <span data-ttu-id="b1598-106">Indipendentemente da quanto ben progettato, tuttavia, nessun framework di [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] sarà in grado di fornire una soluzione a thread singolo per ogni tipo di problema.</span><span class="sxs-lookup"><span data-stu-id="b1598-106">No matter how well architected, however, no [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] framework will ever be able to provide a single-threaded solution for every sort of problem.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="b1598-107">si avvicina, ma esistono ancora situazioni in cui più thread migliorano [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] la velocità di risposta o le prestazioni dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="b1598-107">comes close, but there are still situations where multiple threads improve [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] responsiveness or application performance.</span></span> <span data-ttu-id="b1598-108">Dopo aver illustrato alcune nozioni di base, questo documento analizza alcune di queste situazioni per concludere con la descrizione di alcuni aspetti più in dettaglio.</span><span class="sxs-lookup"><span data-stu-id="b1598-108">After discussing some background material, this paper explores some of these situations and then concludes with a discussion of some lower-level details.</span></span>

> [!NOTE]
> <span data-ttu-id="b1598-109">In questo argomento viene illustrato il threading utilizzando il metodo <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> per le chiamate asincrone.</span><span class="sxs-lookup"><span data-stu-id="b1598-109">This topic discusses threading by using the <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method for asynchronous calls.</span></span> <span data-ttu-id="b1598-110">È anche possibile effettuare chiamate asincrone chiamando il metodo <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A>, che accetta un <xref:System.Action> o <xref:System.Func%601> come parametro.</span><span class="sxs-lookup"><span data-stu-id="b1598-110">You can also make asynchronous calls by calling the <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method, which take an <xref:System.Action> or <xref:System.Func%601> as a parameter.</span></span>  <span data-ttu-id="b1598-111">Il metodo <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> restituisce un <xref:System.Windows.Threading.DispatcherOperation> o <xref:System.Windows.Threading.DispatcherOperation%601>, che dispone di una proprietà <xref:System.Windows.Threading.DispatcherOperation.Task%2A>.</span><span class="sxs-lookup"><span data-stu-id="b1598-111">The <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method returns a <xref:System.Windows.Threading.DispatcherOperation> or <xref:System.Windows.Threading.DispatcherOperation%601>, which has a <xref:System.Windows.Threading.DispatcherOperation.Task%2A> property.</span></span> <span data-ttu-id="b1598-112">È possibile usare la parola chiave `await` con il <xref:System.Windows.Threading.DispatcherOperation> o il <xref:System.Threading.Tasks.Task>associato.</span><span class="sxs-lookup"><span data-stu-id="b1598-112">You can use the `await` keyword with either the <xref:System.Windows.Threading.DispatcherOperation> or the associated <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="b1598-113">Se è necessario attendere in modo sincrono il <xref:System.Threading.Tasks.Task> restituito da un <xref:System.Windows.Threading.DispatcherOperation> o <xref:System.Windows.Threading.DispatcherOperation%601>, chiamare il metodo di estensione <xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A>.</span><span class="sxs-lookup"><span data-stu-id="b1598-113">If you need to wait synchronously for the <xref:System.Threading.Tasks.Task> that is returned by a <xref:System.Windows.Threading.DispatcherOperation> or <xref:System.Windows.Threading.DispatcherOperation%601>, call the <xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A> extension method.</span></span>  <span data-ttu-id="b1598-114">La chiamata di <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> comporterà un deadlock.</span><span class="sxs-lookup"><span data-stu-id="b1598-114">Calling <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> will result in a deadlock.</span></span> <span data-ttu-id="b1598-115">Per ulteriori informazioni sull'utilizzo di un <xref:System.Threading.Tasks.Task> per eseguire operazioni asincrone, vedere Parallelismo delle attività.</span><span class="sxs-lookup"><span data-stu-id="b1598-115">For more information about using a <xref:System.Threading.Tasks.Task> to perform asynchronous operations, see Task Parallelism.</span></span>  <span data-ttu-id="b1598-116">Il metodo <xref:System.Windows.Threading.Dispatcher.Invoke%2A> dispone inoltre di overload che accettano un <xref:System.Action> o <xref:System.Func%601> come parametro.</span><span class="sxs-lookup"><span data-stu-id="b1598-116">The <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method also has overloads that take an <xref:System.Action> or <xref:System.Func%601> as a parameter.</span></span>  <span data-ttu-id="b1598-117">È possibile usare il metodo <xref:System.Windows.Threading.Dispatcher.Invoke%2A> per eseguire chiamate sincrone passando un delegato, <xref:System.Action> o <xref:System.Func%601>.</span><span class="sxs-lookup"><span data-stu-id="b1598-117">You can use the <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method to make synchronous calls by passing in a delegate, <xref:System.Action> or <xref:System.Func%601>.</span></span>

<a name="threading_overview"></a>
## <a name="overview-and-the-dispatcher"></a><span data-ttu-id="b1598-118">Panoramica e dispatcher</span><span class="sxs-lookup"><span data-stu-id="b1598-118">Overview and the Dispatcher</span></span>
 <span data-ttu-id="b1598-119">In genere, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applicazioni iniziano con due thread: uno per la gestione del rendering e l'altro per la gestione della [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="b1598-119">Typically, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications start with two threads: one for handling rendering and another for managing the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="b1598-120">Il thread di rendering viene eseguito in modo efficace nascosto in background mentre il thread [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] riceve input, gestisce gli eventi, disegna lo schermo ed esegue il codice dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="b1598-120">The rendering thread effectively runs hidden in the background while the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread receives input, handles events, paints the screen, and runs application code.</span></span> <span data-ttu-id="b1598-121">La maggior parte delle applicazioni usa un singolo thread di [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)], anche se in alcune situazioni è preferibile usare diversi.</span><span class="sxs-lookup"><span data-stu-id="b1598-121">Most applications use a single [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread, although in some situations it is best to use several.</span></span> <span data-ttu-id="b1598-122">Questo aspetto verrà spiegato più avanti con un esempio.</span><span class="sxs-lookup"><span data-stu-id="b1598-122">We’ll discuss this with an example later.</span></span>

 <span data-ttu-id="b1598-123">Il thread di [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] Accoda gli elementi di lavoro all'interno di un oggetto denominato <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="b1598-123">The [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread queues work items inside an object called a <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="b1598-124">L'oggetto <xref:System.Windows.Threading.Dispatcher> seleziona gli elementi di lavoro in base alla priorità ed esegue ciascuno fino al completamento.</span><span class="sxs-lookup"><span data-stu-id="b1598-124">The <xref:System.Windows.Threading.Dispatcher> selects work items on a priority basis and runs each one to completion.</span></span>  <span data-ttu-id="b1598-125">Ogni thread di [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] deve avere almeno una <xref:System.Windows.Threading.Dispatcher>e ogni <xref:System.Windows.Threading.Dispatcher> può eseguire elementi di lavoro in un solo thread.</span><span class="sxs-lookup"><span data-stu-id="b1598-125">Every [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread must have at least one <xref:System.Windows.Threading.Dispatcher>, and each <xref:System.Windows.Threading.Dispatcher> can execute work items in exactly one thread.</span></span>

 <span data-ttu-id="b1598-126">Il trucco per la creazione di applicazioni reattive e intuitive è ottimizzare la velocità effettiva <xref:System.Windows.Threading.Dispatcher> mantenendo gli elementi di lavoro ridotti.</span><span class="sxs-lookup"><span data-stu-id="b1598-126">The trick to building responsive, user-friendly applications is to maximize the <xref:System.Windows.Threading.Dispatcher> throughput by keeping the work items small.</span></span> <span data-ttu-id="b1598-127">In questo modo gli elementi non vengono mai aggiornati nella coda <xref:System.Windows.Threading.Dispatcher> in attesa di elaborazione.</span><span class="sxs-lookup"><span data-stu-id="b1598-127">This way items never get stale sitting in the <xref:System.Windows.Threading.Dispatcher> queue waiting for processing.</span></span> <span data-ttu-id="b1598-128">Qualsiasi ritardo percepibile tra input e risposta può causare frustrazione in un utente.</span><span class="sxs-lookup"><span data-stu-id="b1598-128">Any perceivable delay between input and response can frustrate a user.</span></span>

 <span data-ttu-id="b1598-129">In che modo le applicazioni [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] dovrebbero gestire operazioni di grandi dimensioni?</span><span class="sxs-lookup"><span data-stu-id="b1598-129">How then are [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications supposed to handle big operations?</span></span> <span data-ttu-id="b1598-130">Cosa è necessario fare se il codice prevede calcoli complessi o l'esecuzione di query su un database in un server remoto?</span><span class="sxs-lookup"><span data-stu-id="b1598-130">What if your code involves a large calculation or needs to query a database on some remote server?</span></span> <span data-ttu-id="b1598-131">In genere, la risposta consiste nel gestire la grande operazione in un thread separato, lasciando il [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread libero per tendere agli elementi nella coda di <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="b1598-131">Usually, the answer is to handle the big operation in a separate thread, leaving the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread free to tend to items in the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="b1598-132">Al termine della grande operazione, può segnalare il risultato al thread [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] per la visualizzazione.</span><span class="sxs-lookup"><span data-stu-id="b1598-132">When the big operation is complete, it can report its result back to the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread for display.</span></span>

 <span data-ttu-id="b1598-133">In passato, Windows consente di accedere agli elementi di [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] solo dal thread che li ha creati.</span><span class="sxs-lookup"><span data-stu-id="b1598-133">Historically, Windows allows [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elements to be accessed only by the thread that created them.</span></span> <span data-ttu-id="b1598-134">Ciò significava che un thread in background responsabile di un'attività a esecuzione prolungata non poteva aggiornare una casella di testo dopo il suo completamento.</span><span class="sxs-lookup"><span data-stu-id="b1598-134">This means that a background thread in charge of some long-running task cannot update a text box when it is finished.</span></span> <span data-ttu-id="b1598-135">Questa operazione viene eseguita da Windows per garantire l'integrità dei componenti di [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="b1598-135">Windows does this to ensure the integrity of [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] components.</span></span> <span data-ttu-id="b1598-136">Una casella di riepilogo può apparire strana se il relativo contenuto viene aggiornato da un thread in background mentre viene disegnata.</span><span class="sxs-lookup"><span data-stu-id="b1598-136">A list box could look strange if its contents were updated by a background thread during painting.</span></span>

 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="b1598-137">include un meccanismo predefinito di esclusione reciproca che impone questo coordinamento.</span><span class="sxs-lookup"><span data-stu-id="b1598-137">has a built-in mutual exclusion mechanism that enforces this coordination.</span></span> <span data-ttu-id="b1598-138">La maggior parte delle classi in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] deriva da <xref:System.Windows.Threading.DispatcherObject>.</span><span class="sxs-lookup"><span data-stu-id="b1598-138">Most classes in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] derive from <xref:System.Windows.Threading.DispatcherObject>.</span></span> <span data-ttu-id="b1598-139">In fase di costruzione, un <xref:System.Windows.Threading.DispatcherObject> archivia un riferimento alla <xref:System.Windows.Threading.Dispatcher> collegata al thread attualmente in esecuzione.</span><span class="sxs-lookup"><span data-stu-id="b1598-139">At construction, a <xref:System.Windows.Threading.DispatcherObject> stores a reference to the <xref:System.Windows.Threading.Dispatcher> linked to the currently running thread.</span></span> <span data-ttu-id="b1598-140">In effetti, il <xref:System.Windows.Threading.DispatcherObject> associa al thread che la crea.</span><span class="sxs-lookup"><span data-stu-id="b1598-140">In effect, the <xref:System.Windows.Threading.DispatcherObject> associates with the thread that creates it.</span></span> <span data-ttu-id="b1598-141">Durante l'esecuzione del programma, un <xref:System.Windows.Threading.DispatcherObject> può chiamare il relativo metodo <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> pubblico.</span><span class="sxs-lookup"><span data-stu-id="b1598-141">During program execution, a <xref:System.Windows.Threading.DispatcherObject> can call its public <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> method.</span></span> <span data-ttu-id="b1598-142"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> esamina la <xref:System.Windows.Threading.Dispatcher> associata al thread corrente e la confronta con il riferimento <xref:System.Windows.Threading.Dispatcher> archiviato durante la costruzione.</span><span class="sxs-lookup"><span data-stu-id="b1598-142"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> examines the <xref:System.Windows.Threading.Dispatcher> associated with the current thread and compares it to the <xref:System.Windows.Threading.Dispatcher> reference stored during construction.</span></span> <span data-ttu-id="b1598-143">Se non corrispondono, <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> genera un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="b1598-143">If they don’t match, <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> throws an exception.</span></span> <span data-ttu-id="b1598-144"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> deve essere chiamato all'inizio di ogni metodo appartenente a una <xref:System.Windows.Threading.DispatcherObject>.</span><span class="sxs-lookup"><span data-stu-id="b1598-144"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> is intended to be called at the beginning of every method belonging to a <xref:System.Windows.Threading.DispatcherObject>.</span></span>

 <span data-ttu-id="b1598-145">Se solo un thread può modificare la [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)], in che modo i thread in background interagiscono con l'utente?</span><span class="sxs-lookup"><span data-stu-id="b1598-145">If only one thread can modify the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)], how do background threads interact with the user?</span></span> <span data-ttu-id="b1598-146">Un thread in background può richiedere al thread [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] di eseguire un'operazione per suo conto.</span><span class="sxs-lookup"><span data-stu-id="b1598-146">A background thread can ask the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread to perform an operation on its behalf.</span></span> <span data-ttu-id="b1598-147">Questa operazione viene eseguita registrando un elemento di lavoro con il <xref:System.Windows.Threading.Dispatcher> del thread di [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="b1598-147">It does this by registering a work item with the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="b1598-148">La classe <xref:System.Windows.Threading.Dispatcher> fornisce due metodi per la registrazione degli elementi di lavoro: <xref:System.Windows.Threading.Dispatcher.Invoke%2A> e <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</span><span class="sxs-lookup"><span data-stu-id="b1598-148">The <xref:System.Windows.Threading.Dispatcher> class provides two methods for registering work items: <xref:System.Windows.Threading.Dispatcher.Invoke%2A> and <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</span></span> <span data-ttu-id="b1598-149">Entrambi i metodi pianificano un delegato per l'esecuzione.</span><span class="sxs-lookup"><span data-stu-id="b1598-149">Both methods schedule a delegate for execution.</span></span> <span data-ttu-id="b1598-150"><xref:System.Windows.Threading.Dispatcher.Invoke%2A> è una chiamata sincrona, ovvero non restituisce un risultato fino a quando il thread di [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] non completa effettivamente l'esecuzione del delegato.</span><span class="sxs-lookup"><span data-stu-id="b1598-150"><xref:System.Windows.Threading.Dispatcher.Invoke%2A> is a synchronous call – that is, it doesn’t return until the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread actually finishes executing the delegate.</span></span> <span data-ttu-id="b1598-151"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> è asincrono e restituisce immediatamente un risultato.</span><span class="sxs-lookup"><span data-stu-id="b1598-151"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is asynchronous and returns immediately.</span></span>

 <span data-ttu-id="b1598-152">Il <xref:System.Windows.Threading.Dispatcher> Ordina gli elementi nella coda per priorità.</span><span class="sxs-lookup"><span data-stu-id="b1598-152">The <xref:System.Windows.Threading.Dispatcher> orders the elements in its queue by priority.</span></span> <span data-ttu-id="b1598-153">È possibile specificare dieci livelli quando si aggiunge un elemento alla coda <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="b1598-153">There are ten levels that may be specified when adding an element to the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="b1598-154">Queste priorità vengono gestite nell'enumerazione <xref:System.Windows.Threading.DispatcherPriority>.</span><span class="sxs-lookup"><span data-stu-id="b1598-154">These priorities are maintained in the <xref:System.Windows.Threading.DispatcherPriority> enumeration.</span></span> <span data-ttu-id="b1598-155">Informazioni dettagliate sui livelli di <xref:System.Windows.Threading.DispatcherPriority> sono disponibili nella documentazione di Windows SDK.</span><span class="sxs-lookup"><span data-stu-id="b1598-155">Detailed information about <xref:System.Windows.Threading.DispatcherPriority> levels can be found in the Windows SDK documentation.</span></span>

<a name="samples"></a>
## <a name="threads-in-action-the-samples"></a><span data-ttu-id="b1598-156">Thread in azione: esempi</span><span class="sxs-lookup"><span data-stu-id="b1598-156">Threads in Action: The Samples</span></span>

<a name="prime_number"></a>
### <a name="a-single-threaded-application-with-a-long-running-calculation"></a><span data-ttu-id="b1598-157">Applicazione a thread singolo con calcolo a esecuzione prolungata</span><span class="sxs-lookup"><span data-stu-id="b1598-157">A Single-Threaded Application with a Long-Running Calculation</span></span>
 <span data-ttu-id="b1598-158">La maggior parte dell'interfaccia utente grafica (GUI) dedica una grande parte del tempo di inattività durante l'attesa degli eventi generati in risposta alle interazioni dell'utente.</span><span class="sxs-lookup"><span data-stu-id="b1598-158">Most graphical user interfaces (GUIs) spend a large portion of their time idle while waiting for events that are generated in response to user interactions.</span></span> <span data-ttu-id="b1598-159">Con un'attenta programmazione questo tempo di inattività può essere usato in modo costruttivo, senza influire sulla velocità di risposta del [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="b1598-159">With careful programming this idle time can be used constructively, without affecting the responsiveness of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="b1598-160">Il modello di threading [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] non consente all'input di interrompere un'operazione che si verifica nel thread di [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="b1598-160">The [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] threading model doesn’t allow input to interrupt an operation happening in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="b1598-161">Ciò significa che è necessario assicurarsi di tornare al <xref:System.Windows.Threading.Dispatcher> periodicamente per elaborare gli eventi di input in sospeso prima di diventare obsoleti.</span><span class="sxs-lookup"><span data-stu-id="b1598-161">This means you must be sure to return to the <xref:System.Windows.Threading.Dispatcher> periodically to process pending input events before they get stale.</span></span>

 <span data-ttu-id="b1598-162">Si consideri l'esempio seguente:</span><span class="sxs-lookup"><span data-stu-id="b1598-162">Consider the following example:</span></span>

 ![Screenshot che mostra il threading dei numeri primi.](./media/threading-model/threading-prime-numbers.png)

 <span data-ttu-id="b1598-164">Questa semplice applicazione conta verso l'alto a partire da tre, cercando i numeri primi.</span><span class="sxs-lookup"><span data-stu-id="b1598-164">This simple application counts upwards from three, searching for prime numbers.</span></span> <span data-ttu-id="b1598-165">Quando l'utente fa clic sul pulsante **Start** , inizia la ricerca.</span><span class="sxs-lookup"><span data-stu-id="b1598-165">When the user clicks the **Start** button, the search begins.</span></span> <span data-ttu-id="b1598-166">Quando il programma trova un numero primo, aggiorna l'interfaccia utente con il risultato trovato.</span><span class="sxs-lookup"><span data-stu-id="b1598-166">When the program finds a prime, it updates the user interface with its discovery.</span></span> <span data-ttu-id="b1598-167">In qualsiasi momento, l'utente può interrompere la ricerca.</span><span class="sxs-lookup"><span data-stu-id="b1598-167">At any point, the user can stop the search.</span></span>

 <span data-ttu-id="b1598-168">Anche se è abbastanza semplice, la ricerca di numeri primi potrebbe continuare all'infinito e questo comporta alcune difficoltà.</span><span class="sxs-lookup"><span data-stu-id="b1598-168">Although simple enough, the prime number search could go on forever, which presents some difficulties.</span></span>  <span data-ttu-id="b1598-169">Se l'intera ricerca è stata gestita all'interno del gestore dell'evento click del pulsante, non si darebbe mai al thread di [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] la possibilità di gestire altri eventi.</span><span class="sxs-lookup"><span data-stu-id="b1598-169">If we handled the entire search inside of the click event handler of the button, we would never give the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread a chance to handle other events.</span></span> <span data-ttu-id="b1598-170">Il [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] non sarà in grado di rispondere ai messaggi di input o di elaborazione.</span><span class="sxs-lookup"><span data-stu-id="b1598-170">The [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] would be unable to respond to input or process messages.</span></span> <span data-ttu-id="b1598-171">L'interfaccia utente non verrebbe mai ridisegnata e i clic sui pulsanti non riceverebbero alcuna risposta.</span><span class="sxs-lookup"><span data-stu-id="b1598-171">It would never repaint and never respond to button clicks.</span></span>

 <span data-ttu-id="b1598-172">È possibile eseguire la ricerca dei numeri primi in un thread separato, ma in questo caso sarebbe necessario affrontare problemi di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="b1598-172">We could conduct the prime number search in a separate thread, but then we would need to deal with synchronization issues.</span></span> <span data-ttu-id="b1598-173">Con un approccio a thread singolo, è possibile aggiornare direttamente l'etichetta che indica il numero primo più grande trovato.</span><span class="sxs-lookup"><span data-stu-id="b1598-173">With a single-threaded approach, we can directly update the label that lists the largest prime found.</span></span>

 <span data-ttu-id="b1598-174">Se si suddivide l'attività di calcolo in blocchi gestibili, è possibile tornare periodicamente al <xref:System.Windows.Threading.Dispatcher> ed elaborare gli eventi.</span><span class="sxs-lookup"><span data-stu-id="b1598-174">If we break up the task of calculation into manageable chunks, we can periodically return to the <xref:System.Windows.Threading.Dispatcher> and process events.</span></span> <span data-ttu-id="b1598-175">Possiamo dare [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] la possibilità di ridisegnare ed elaborare l'input.</span><span class="sxs-lookup"><span data-stu-id="b1598-175">We can give [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] an opportunity to repaint and process input.</span></span>

 <span data-ttu-id="b1598-176">Il modo migliore per suddividere i tempi di elaborazione tra calcolo e gestione degli eventi consiste nel gestire il calcolo dal <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="b1598-176">The best way to split processing time between calculation and event handling is to manage calculation from the <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="b1598-177">Utilizzando il metodo <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>, è possibile pianificare i controlli dei numeri primi nella stessa coda da cui vengono tracciati [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] eventi.</span><span class="sxs-lookup"><span data-stu-id="b1598-177">By using the <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method, we can schedule prime number checks in the same queue that [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] events are drawn from.</span></span> <span data-ttu-id="b1598-178">Nell'esempio viene pianificato il controllo di un singolo numero primo per volta.</span><span class="sxs-lookup"><span data-stu-id="b1598-178">In our example, we schedule only a single prime number check at a time.</span></span> <span data-ttu-id="b1598-179">Al termine del controllo del numero primo, viene pianificato immediatamente il controllo successivo.</span><span class="sxs-lookup"><span data-stu-id="b1598-179">After the prime number check is complete, we schedule the next check immediately.</span></span> <span data-ttu-id="b1598-180">Questo controllo continua solo dopo che sono stati gestiti gli eventi [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] in sospeso.</span><span class="sxs-lookup"><span data-stu-id="b1598-180">This check proceeds only after pending [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] events have been handled.</span></span>

 ![Screenshot che mostra la coda del dispatcher.](./media/threading-model/threading-dispatcher-queue.png)

 <span data-ttu-id="b1598-182">Microsoft Word realizza il controllo ortografico usando questo meccanismo.</span><span class="sxs-lookup"><span data-stu-id="b1598-182">Microsoft Word accomplishes spell checking using this mechanism.</span></span> <span data-ttu-id="b1598-183">Il controllo ortografico viene eseguito in background utilizzando il tempo di inattività del thread [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="b1598-183">Spell checking is done in the background using the idle time of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="b1598-184">Di seguito è riportato il codice.</span><span class="sxs-lookup"><span data-stu-id="b1598-184">Let's take a look at the code.</span></span>

 <span data-ttu-id="b1598-185">L'esempio seguente mostra il codice XAML che crea l'interfaccia utente.</span><span class="sxs-lookup"><span data-stu-id="b1598-185">The following example shows the XAML that creates the user interface.</span></span>

 [!code-xaml[ThreadingPrimeNumbers#ThreadingPrimeNumberXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml#threadingprimenumberxaml)]

 <span data-ttu-id="b1598-186">L'esempio seguente mostra il code-behind.</span><span class="sxs-lookup"><span data-stu-id="b1598-186">The following example shows the code-behind.</span></span>

 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumbercodebehind)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumbercodebehind)]

 <span data-ttu-id="b1598-187">Nell'esempio seguente viene illustrato il gestore eventi per la <xref:System.Windows.Controls.Button>.</span><span class="sxs-lookup"><span data-stu-id="b1598-187">The following example shows the event handler for the <xref:System.Windows.Controls.Button>.</span></span>

 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberstartorstop)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberstartorstop)]

 <span data-ttu-id="b1598-188">Oltre ad aggiornare il testo nella <xref:System.Windows.Controls.Button>, questo gestore è responsabile della pianificazione del primo controllo dei numeri primi mediante l'aggiunta di un delegato alla coda di <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="b1598-188">Besides updating the text on the <xref:System.Windows.Controls.Button>, this handler is responsible for scheduling the first prime number check by adding a delegate to the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="b1598-189">A questo punto, dopo che il gestore dell'evento ha completato il proprio lavoro, il <xref:System.Windows.Threading.Dispatcher> selezionerà questo delegato per l'esecuzione.</span><span class="sxs-lookup"><span data-stu-id="b1598-189">Sometime after this event handler has completed its work, the <xref:System.Windows.Threading.Dispatcher> will select this delegate for execution.</span></span>

 <span data-ttu-id="b1598-190">Come indicato in precedenza, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> è il membro <xref:System.Windows.Threading.Dispatcher> usato per pianificare un delegato per l'esecuzione.</span><span class="sxs-lookup"><span data-stu-id="b1598-190">As we mentioned earlier, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is the <xref:System.Windows.Threading.Dispatcher> member used to schedule a delegate for execution.</span></span> <span data-ttu-id="b1598-191">In questo caso, si sceglie la priorità <xref:System.Windows.Threading.DispatcherPriority.SystemIdle>.</span><span class="sxs-lookup"><span data-stu-id="b1598-191">In this case, we choose the <xref:System.Windows.Threading.DispatcherPriority.SystemIdle> priority.</span></span> <span data-ttu-id="b1598-192">Il <xref:System.Windows.Threading.Dispatcher> eseguirà questo delegato solo quando non ci sono eventi importanti da elaborare.</span><span class="sxs-lookup"><span data-stu-id="b1598-192">The <xref:System.Windows.Threading.Dispatcher> will execute this delegate only when there are no important events to process.</span></span> <span data-ttu-id="b1598-193">La velocità di risposta dell'[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] è più importante del controllo dei numeri.</span><span class="sxs-lookup"><span data-stu-id="b1598-193">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] responsiveness is more important than number checking.</span></span> <span data-ttu-id="b1598-194">Viene anche passato un nuovo delegato che rappresenta la routine di controllo dei numeri.</span><span class="sxs-lookup"><span data-stu-id="b1598-194">We also pass a new delegate representing the number-checking routine.</span></span>

 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberchecknextnumber)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberchecknextnumber)]

 <span data-ttu-id="b1598-195">Questo metodo controlla se il numero dispari successivo è un numero primo.</span><span class="sxs-lookup"><span data-stu-id="b1598-195">This method checks if the next odd number is prime.</span></span> <span data-ttu-id="b1598-196">Se è primo, il metodo aggiorna direttamente il `bigPrime`<xref:System.Windows.Controls.TextBlock> per rifletterne l'individuazione.</span><span class="sxs-lookup"><span data-stu-id="b1598-196">If it is prime, the method directly updates the `bigPrime`<xref:System.Windows.Controls.TextBlock> to reflect its discovery.</span></span> <span data-ttu-id="b1598-197">Ciò è possibile perché il calcolo viene eseguito nello stesso thread usato per creare il componente.</span><span class="sxs-lookup"><span data-stu-id="b1598-197">We can do this because the calculation is occurring in the same thread that was used to create the component.</span></span> <span data-ttu-id="b1598-198">Se avessimo scelto di usare un thread separato per il calcolo, avremmo dovuto usare un meccanismo di sincronizzazione più complicato ed eseguire l'aggiornamento nel thread [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="b1598-198">Had we chosen to use a separate thread for the calculation, we would have to use a more complicated synchronization mechanism and execute the update in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="b1598-199">Questa situazione verrà illustrata più avanti.</span><span class="sxs-lookup"><span data-stu-id="b1598-199">We’ll demonstrate this situation next.</span></span>

 <span data-ttu-id="b1598-200">Per il codice sorgente completo per questo esempio, vedere l' [esempio di applicazione a thread singolo con calcolo a esecuzione prolungata](https://go.microsoft.com/fwlink/?LinkID=160038)</span><span class="sxs-lookup"><span data-stu-id="b1598-200">For the complete source code for this sample, see the [Single-Threaded Application with Long-Running Calculation Sample](https://go.microsoft.com/fwlink/?LinkID=160038)</span></span>

<a name="weather_sim"></a>
### <a name="handling-a-blocking-operation-with-a-background-thread"></a><span data-ttu-id="b1598-201">Gestione di un'operazione di blocco con un thread in background</span><span class="sxs-lookup"><span data-stu-id="b1598-201">Handling a Blocking Operation with a Background Thread</span></span>
 <span data-ttu-id="b1598-202">La gestione delle operazioni di blocco in un'applicazione grafica può essere complessa.</span><span class="sxs-lookup"><span data-stu-id="b1598-202">Handling blocking operations in a graphical application can be difficult.</span></span> <span data-ttu-id="b1598-203">Non è consigliabile chiamare metodi di blocco dai gestori eventi perché l'applicazione risulterebbe bloccata.</span><span class="sxs-lookup"><span data-stu-id="b1598-203">We don’t want to call blocking methods from event handlers because the application will appear to freeze up.</span></span> <span data-ttu-id="b1598-204">È possibile usare un thread separato per gestire queste operazioni, ma al termine è necessario eseguire la sincronizzazione con il thread di [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] perché non è possibile modificare direttamente l'interfaccia utente grafica dal thread di lavoro.</span><span class="sxs-lookup"><span data-stu-id="b1598-204">We can use a separate thread to handle these operations, but when we’re done, we have to synchronize with the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread because we can’t directly modify the GUI from our worker thread.</span></span> <span data-ttu-id="b1598-205">È possibile utilizzare <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> per inserire delegati nel <xref:System.Windows.Threading.Dispatcher> del thread [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="b1598-205">We can use <xref:System.Windows.Threading.Dispatcher.Invoke%2A> or <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> to insert delegates into the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="b1598-206">Alla fine, questi delegati verranno eseguiti con l'autorizzazione per modificare [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elementi.</span><span class="sxs-lookup"><span data-stu-id="b1598-206">Eventually, these delegates will be executed with permission to modify [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elements.</span></span>

 <span data-ttu-id="b1598-207">In questo esempio viene simulata una chiamata RPC (Remote Procedure Call) che recupera i dati delle previsioni meteo.</span><span class="sxs-lookup"><span data-stu-id="b1598-207">In this example, we mimic a remote procedure call that retrieves a weather forecast.</span></span> <span data-ttu-id="b1598-208">Viene usato un thread di lavoro separato per eseguire questa chiamata e si pianifica un metodo di aggiornamento nel <xref:System.Windows.Threading.Dispatcher> del thread [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] al termine dell'operazione.</span><span class="sxs-lookup"><span data-stu-id="b1598-208">We use a separate worker thread to execute this call, and we schedule an update method in the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread when we’re finished.</span></span>

 ![Screenshot che mostra l'interfaccia utente Meteo.](./media/threading-model/threading-weather-ui.png)

 [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweathercodebehind)]
 [!code-vb[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweathercodebehind)]

 <span data-ttu-id="b1598-210">Di seguito sono elencati alcuni dettagli da considerare.</span><span class="sxs-lookup"><span data-stu-id="b1598-210">The following are some of the details to be noted.</span></span>

- <span data-ttu-id="b1598-211">Creazione del gestore dei pulsanti</span><span class="sxs-lookup"><span data-stu-id="b1598-211">Creating the Button Handler</span></span>

     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherbuttonhandler)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherbuttonhandler)]

 <span data-ttu-id="b1598-212">Quando si fa clic sul pulsante, viene visualizzato il disegno dell'orologio e viene avviata l'animazione.</span><span class="sxs-lookup"><span data-stu-id="b1598-212">When the button is clicked, we display the clock drawing and start animating it.</span></span> <span data-ttu-id="b1598-213">Il pulsante viene disabilitato.</span><span class="sxs-lookup"><span data-stu-id="b1598-213">We disable the button.</span></span> <span data-ttu-id="b1598-214">Il metodo `FetchWeatherFromServer` viene richiamato in un nuovo thread, quindi viene restituito, consentendo al <xref:System.Windows.Threading.Dispatcher> di elaborare gli eventi mentre si è in attesa di raccogliere le previsioni meteorologiche.</span><span class="sxs-lookup"><span data-stu-id="b1598-214">We invoke the `FetchWeatherFromServer` method in a new thread, and then we return, allowing the <xref:System.Windows.Threading.Dispatcher> to process events while we wait to collect the weather forecast.</span></span>

- <span data-ttu-id="b1598-215">Recupero dei dati meteo</span><span class="sxs-lookup"><span data-stu-id="b1598-215">Fetching the Weather</span></span>

     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherfetchweather)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherfetchweather)]

 <span data-ttu-id="b1598-216">Per maggiore semplicità, l'esempio non contiene codice di rete.</span><span class="sxs-lookup"><span data-stu-id="b1598-216">To keep things simple, we don’t actually have any networking code in this example.</span></span> <span data-ttu-id="b1598-217">Viene invece simulato il ritardo dell'accesso di rete sospendendo il thread per quattro secondi.</span><span class="sxs-lookup"><span data-stu-id="b1598-217">Instead, we simulate the delay of network access by putting our new thread to sleep for four seconds.</span></span> <span data-ttu-id="b1598-218">In questo periodo, il thread di [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] originale è ancora in esecuzione e risponde agli eventi.</span><span class="sxs-lookup"><span data-stu-id="b1598-218">In this time, the original [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread is still running and responding to events.</span></span> <span data-ttu-id="b1598-219">Per illustrare questa situazione, viene lasciata in esecuzione un'animazione e i pulsanti di riduzione a icona e ingrandimento continuano a funzionare.</span><span class="sxs-lookup"><span data-stu-id="b1598-219">To show this, we’ve left an animation running, and the minimize and maximize buttons also continue to work.</span></span>

 <span data-ttu-id="b1598-220">Al termine del ritardo e abbiamo selezionato in modo casuale le previsioni meteorologiche, è il momento di riportare al thread [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="b1598-220">When the delay is finished, and we’ve randomly selected our weather forecast, it’s time to report back to the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="b1598-221">Questa operazione viene eseguita pianificando una chiamata a `UpdateUserInterface` nel thread [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] utilizzando <xref:System.Windows.Threading.Dispatcher>di tale thread.</span><span class="sxs-lookup"><span data-stu-id="b1598-221">We do this by scheduling a call to `UpdateUserInterface` in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread using that thread’s <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="b1598-222">Viene passata una stringa che descrive le condizioni meteo alla chiamata al metodo pianificata.</span><span class="sxs-lookup"><span data-stu-id="b1598-222">We pass a string describing the weather to this scheduled method call.</span></span>

- <span data-ttu-id="b1598-223">Aggiornamento del [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</span><span class="sxs-lookup"><span data-stu-id="b1598-223">Updating the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</span></span>

     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherupdateui)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherupdateui)]

 <span data-ttu-id="b1598-224">Quando il <xref:System.Windows.Threading.Dispatcher> nel thread [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] dispone di tempo, viene eseguita la chiamata pianificata a `UpdateUserInterface`.</span><span class="sxs-lookup"><span data-stu-id="b1598-224">When the <xref:System.Windows.Threading.Dispatcher> in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread has time, it executes the scheduled call to `UpdateUserInterface`.</span></span> <span data-ttu-id="b1598-225">Questo metodo interrompe l'animazione dell'orologio e sceglie un'immagine per descrivere le condizioni meteo.</span><span class="sxs-lookup"><span data-stu-id="b1598-225">This method stops the clock animation and chooses an image to describe the weather.</span></span> <span data-ttu-id="b1598-226">L'immagine viene visualizzata e il pulsante "Fetch Forecast" viene ripristinato.</span><span class="sxs-lookup"><span data-stu-id="b1598-226">It displays this image and restores the "fetch forecast" button.</span></span>

<a name="multi_browser"></a>
### <a name="multiple-windows-multiple-threads"></a><span data-ttu-id="b1598-227">Più finestre, più thread</span><span class="sxs-lookup"><span data-stu-id="b1598-227">Multiple Windows, Multiple Threads</span></span>
 <span data-ttu-id="b1598-228">Alcune applicazioni [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] richiedono più finestre di primo livello.</span><span class="sxs-lookup"><span data-stu-id="b1598-228">Some [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications require multiple top-level windows.</span></span> <span data-ttu-id="b1598-229">È perfettamente accettabile per una combinazione di thread/<xref:System.Windows.Threading.Dispatcher> gestire più finestre, ma a volte diversi thread offrono un processo migliore.</span><span class="sxs-lookup"><span data-stu-id="b1598-229">It is perfectly acceptable for one Thread/<xref:System.Windows.Threading.Dispatcher> combination to manage multiple windows, but sometimes several threads do a better job.</span></span> <span data-ttu-id="b1598-230">Ciò è particolarmente vero nel caso in cui ci sia la possibilità che una delle finestre monopolizzi il thread.</span><span class="sxs-lookup"><span data-stu-id="b1598-230">This is especially true if there is any chance that one of the windows will monopolize the thread.</span></span>

 <span data-ttu-id="b1598-231">Esplora risorse funziona in questo modo.</span><span class="sxs-lookup"><span data-stu-id="b1598-231">Windows Explorer works in this fashion.</span></span> <span data-ttu-id="b1598-232">Ogni nuova finestra di Esplora risorse appartiene al processo originale, ma viene creata sotto il controllo di un thread indipendente.</span><span class="sxs-lookup"><span data-stu-id="b1598-232">Each new Explorer window belongs to the original process, but it is created under the control of an independent thread.</span></span>

 <span data-ttu-id="b1598-233">Utilizzando un controllo [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<xref:System.Windows.Controls.Frame>, è possibile visualizzare le pagine Web.</span><span class="sxs-lookup"><span data-stu-id="b1598-233">By using a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<xref:System.Windows.Controls.Frame> control, we can display Web pages.</span></span> <span data-ttu-id="b1598-234">È possibile creare facilmente un sostituto semplice di Internet Explorer.</span><span class="sxs-lookup"><span data-stu-id="b1598-234">We can easily create a simple Internet Explorer substitute.</span></span> <span data-ttu-id="b1598-235">Si inizia con una funzionalità importante: la possibilità di aprire una nuova finestra.</span><span class="sxs-lookup"><span data-stu-id="b1598-235">We start with an important feature: the ability to open a new explorer window.</span></span> <span data-ttu-id="b1598-236">Quando l'utente fa clic sul pulsante "Nuova finestra", viene aperta una copia della finestra in un thread separato.</span><span class="sxs-lookup"><span data-stu-id="b1598-236">When the user clicks the "new window" button, we launch a copy of our window in a separate thread.</span></span> <span data-ttu-id="b1598-237">In questo modo, le operazioni a esecuzione prolungata o di blocco in una delle finestre non bloccheranno tutte le altre finestre.</span><span class="sxs-lookup"><span data-stu-id="b1598-237">This way, long-running or blocking operations in one of the windows won’t lock all the other windows.</span></span>

 <span data-ttu-id="b1598-238">In realtà, il modello di browser Web ha un proprio modello di threading complesso.</span><span class="sxs-lookup"><span data-stu-id="b1598-238">In reality, the Web browser model has its own complicated threading model.</span></span> <span data-ttu-id="b1598-239">È stato scelto questo esempio perché dovrebbe risultare familiare alla maggior parte dei lettori.</span><span class="sxs-lookup"><span data-stu-id="b1598-239">We’ve chosen it because it should be familiar to most readers.</span></span>

 <span data-ttu-id="b1598-240">L'esempio seguente mostra il codice.</span><span class="sxs-lookup"><span data-stu-id="b1598-240">The following example shows the code.</span></span>

 [!code-xaml[ThreadingMultipleBrowsers#ThreadingMultiBrowserXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml#threadingmultibrowserxaml)]

 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsercodebehind)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsercodebehind)]

 <span data-ttu-id="b1598-241">I segmenti di threading seguenti del codice sono i più interessanti in questo contesto:</span><span class="sxs-lookup"><span data-stu-id="b1598-241">The following threading segments of this code are the most interesting to us in this context:</span></span>

 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsernewwindow)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsernewwindow)]

 <span data-ttu-id="b1598-242">Questo metodo viene chiamato quando si fa clic sul pulsante "Nuova finestra".</span><span class="sxs-lookup"><span data-stu-id="b1598-242">This method is called when the "new window" button is clicked.</span></span> <span data-ttu-id="b1598-243">Il metodo crea un nuovo thread e lo avvia in modo asincrono.</span><span class="sxs-lookup"><span data-stu-id="b1598-243">It creates a new thread and starts it asynchronously.</span></span>

 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowserthreadstart)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowserthreadstart)]

 <span data-ttu-id="b1598-244">Questo metodo è il punto di partenza per il nuovo thread.</span><span class="sxs-lookup"><span data-stu-id="b1598-244">This method is the starting point for the new thread.</span></span> <span data-ttu-id="b1598-245">Viene creata una nuova finestra sotto il controllo di questo thread.</span><span class="sxs-lookup"><span data-stu-id="b1598-245">We create a new window under the control of this thread.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="b1598-246">crea automaticamente una nuova <xref:System.Windows.Threading.Dispatcher> per gestire il nuovo thread.</span><span class="sxs-lookup"><span data-stu-id="b1598-246">automatically creates a new <xref:System.Windows.Threading.Dispatcher> to manage the new thread.</span></span> <span data-ttu-id="b1598-247">Per rendere funzionale la finestra, è sufficiente avviare il <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="b1598-247">All we have to do to make the window functional is to start the <xref:System.Windows.Threading.Dispatcher>.</span></span>

<a name="stumbling_points"></a>
## <a name="technical-details-and-stumbling-points"></a><span data-ttu-id="b1598-248">Dettagli tecnici e difficoltà</span><span class="sxs-lookup"><span data-stu-id="b1598-248">Technical Details and Stumbling Points</span></span>

### <a name="writing-components-using-threading"></a><span data-ttu-id="b1598-249">Scrittura di componenti usando il threading</span><span class="sxs-lookup"><span data-stu-id="b1598-249">Writing Components Using Threading</span></span>
 <span data-ttu-id="b1598-250">La guida per gli sviluppatori di Microsoft .NET Framework descrive un modello per il modo in cui un componente può esporre il comportamento asincrono ai propri client. vedere [Cenni preliminari sul modello asincrono basato su eventi](../../../standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md).</span><span class="sxs-lookup"><span data-stu-id="b1598-250">The Microsoft .NET Framework Developer's Guide describes a pattern for how a component can expose asynchronous behavior to its clients (see [Event-based Asynchronous Pattern Overview](../../../standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md)).</span></span> <span data-ttu-id="b1598-251">Si supponga, ad esempio, di voler creare il pacchetto del `FetchWeatherFromServer` metodo in un componente riutilizzabile e non grafico.</span><span class="sxs-lookup"><span data-stu-id="b1598-251">For instance, suppose we wanted to package the `FetchWeatherFromServer` method into a reusable, nongraphical component.</span></span> <span data-ttu-id="b1598-252">Seguendo il modello di Microsoft .NET Framework standard, il risultato sarà simile al seguente.</span><span class="sxs-lookup"><span data-stu-id="b1598-252">Following the standard Microsoft .NET Framework pattern, this would look something like the following.</span></span>

 [!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent1)]
 [!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent1)]

 <span data-ttu-id="b1598-253">`GetWeatherAsync` userebbe una delle tecniche descritte in precedenza, ad esempio la creazione di un thread in background, per eseguire le attività in modo asincrono, senza bloccare il thread chiamante.</span><span class="sxs-lookup"><span data-stu-id="b1598-253">`GetWeatherAsync` would use one of the techniques described earlier, such as creating a background thread, to do the work asynchronously, not blocking the calling thread.</span></span>

 <span data-ttu-id="b1598-254">Una delle parti più importanti di questo modello è la chiamata al metodo *methodname*`Completed` sullo stesso thread che ha chiamato il metodo *MethodName*`Async` per iniziare.</span><span class="sxs-lookup"><span data-stu-id="b1598-254">One of the most important parts of this pattern is calling the *MethodName*`Completed` method on the same thread that called the *MethodName*`Async` method to begin with.</span></span> <span data-ttu-id="b1598-255">Questa operazione può essere eseguita in modo abbastanza semplice, archiviando <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>, ma in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] questo caso il componente non grafico può essere usato solo in applicazioni [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], non nei programmi Windows Forms o ASP.NET.</span><span class="sxs-lookup"><span data-stu-id="b1598-255">You could do this using [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] fairly easily, by storing <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>—but then the nongraphical component could only be used in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, not in Windows Forms or ASP.NET programs.</span></span>

 <span data-ttu-id="b1598-256">La classe <xref:System.Windows.Threading.DispatcherSynchronizationContext> risponde a questa esigenza, ovvero una versione semplificata di <xref:System.Windows.Threading.Dispatcher> che funziona anche con altri [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] Framework.</span><span class="sxs-lookup"><span data-stu-id="b1598-256">The <xref:System.Windows.Threading.DispatcherSynchronizationContext> class addresses this need—think of it as a simplified version of <xref:System.Windows.Threading.Dispatcher> that works with other [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] frameworks as well.</span></span>

 [!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent2)]
 [!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent2)]

### <a name="nested-pumping"></a><span data-ttu-id="b1598-257">Distribuzione annidata</span><span class="sxs-lookup"><span data-stu-id="b1598-257">Nested Pumping</span></span>
 <span data-ttu-id="b1598-258">In alcuni casi non è possibile bloccare completamente il thread di [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="b1598-258">Sometimes it is not feasible to completely lock up the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="b1598-259">Si prenda in considerazione il metodo <xref:System.Windows.MessageBox.Show%2A> della classe <xref:System.Windows.MessageBox>.</span><span class="sxs-lookup"><span data-stu-id="b1598-259">Let’s consider the <xref:System.Windows.MessageBox.Show%2A> method of the <xref:System.Windows.MessageBox> class.</span></span> <span data-ttu-id="b1598-260"><xref:System.Windows.MessageBox.Show%2A> non viene restituito fino a quando l'utente non fa clic sul pulsante OK.</span><span class="sxs-lookup"><span data-stu-id="b1598-260"><xref:System.Windows.MessageBox.Show%2A> doesn’t return until the user clicks the OK button.</span></span> <span data-ttu-id="b1598-261">Crea però una finestra che deve avere un ciclo di messaggi per essere interattiva.</span><span class="sxs-lookup"><span data-stu-id="b1598-261">It does, however, create a window that must have a message loop in order to be interactive.</span></span> <span data-ttu-id="b1598-262">Mentre è in attesa del clic dell'utente su OK, la finestra dell'applicazione originale non risponde all'input utente.</span><span class="sxs-lookup"><span data-stu-id="b1598-262">While we are waiting for the user to click OK, the original application window does not respond to user input.</span></span> <span data-ttu-id="b1598-263">Continua però a elaborare i messaggi di disegno dell'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="b1598-263">It does, however, continue to process paint messages.</span></span> <span data-ttu-id="b1598-264">La finestra originale ridisegna se stessa quando viene coperta e mostrata.</span><span class="sxs-lookup"><span data-stu-id="b1598-264">The original window redraws itself when covered and revealed.</span></span>

 ![Screenshot che mostra un MessageBox con un pulsante OK](./media/threading-model/threading-message-loop.png)

 <span data-ttu-id="b1598-266">Un thread deve essere responsabile della finestra di messaggio.</span><span class="sxs-lookup"><span data-stu-id="b1598-266">Some thread must be in charge of the message box window.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="b1598-267">potrebbe creare un nuovo thread solo per la finestra di messaggio, ma questo thread non sarebbe in grado di disegnare gli elementi disabilitati nella finestra originale (in base a quanto illustrato in precedenza in relazione all'esclusione reciproca).</span><span class="sxs-lookup"><span data-stu-id="b1598-267">could create a new thread just for the message box window, but this thread would be unable to paint the disabled elements in the original window (remember the earlier discussion of mutual exclusion).</span></span> <span data-ttu-id="b1598-268">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] utilizza invece un sistema di elaborazione dei messaggi annidato.</span><span class="sxs-lookup"><span data-stu-id="b1598-268">Instead, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses a nested message processing system.</span></span> <span data-ttu-id="b1598-269">La classe <xref:System.Windows.Threading.Dispatcher> include un metodo speciale denominato <xref:System.Windows.Threading.Dispatcher.PushFrame%2A>, che archivia il punto di esecuzione corrente di un'applicazione, quindi avvia un nuovo ciclo di messaggi.</span><span class="sxs-lookup"><span data-stu-id="b1598-269">The <xref:System.Windows.Threading.Dispatcher> class includes a special method called <xref:System.Windows.Threading.Dispatcher.PushFrame%2A>, which stores an application’s current execution point then begins a new message loop.</span></span> <span data-ttu-id="b1598-270">Al termine del ciclo di messaggi annidati, l'esecuzione riprende dopo la chiamata di <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> originale.</span><span class="sxs-lookup"><span data-stu-id="b1598-270">When the nested message loop finishes, execution resumes after the original <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> call.</span></span>

 <span data-ttu-id="b1598-271">In questo caso, <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> gestisce il contesto del programma alla chiamata a <xref:System.Windows.MessageBox.Show%2A?displayProperty=nameWithType>e avvia un nuovo ciclo di messaggi per ridisegnare la finestra di sfondo e gestire l'input della finestra di messaggio.</span><span class="sxs-lookup"><span data-stu-id="b1598-271">In this case, <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> maintains the program context at the call to <xref:System.Windows.MessageBox.Show%2A?displayProperty=nameWithType>, and it starts a new message loop to repaint the background window and handle input to the message box window.</span></span> <span data-ttu-id="b1598-272">Quando l'utente fa clic su OK e cancella la finestra popup, il ciclo annidato viene chiuso e il controllo riprende dopo la chiamata a <xref:System.Windows.MessageBox.Show%2A>.</span><span class="sxs-lookup"><span data-stu-id="b1598-272">When the user clicks OK and clears the pop-up window, the nested loop exits and control resumes after the call to <xref:System.Windows.MessageBox.Show%2A>.</span></span>

### <a name="stale-routed-events"></a><span data-ttu-id="b1598-273">Eventi indirizzati non aggiornati</span><span class="sxs-lookup"><span data-stu-id="b1598-273">Stale Routed Events</span></span>
 <span data-ttu-id="b1598-274">Il sistema di eventi indirizzati in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] notifica a interi alberi quando vengono generati eventi.</span><span class="sxs-lookup"><span data-stu-id="b1598-274">The routed event system in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] notifies entire trees when events are raised.</span></span>

 [!code-xaml[InputOvw#ThreadingArticleStaticRoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml#threadingarticlestaticroutedevent)]

 <span data-ttu-id="b1598-275">Quando viene premuto il pulsante sinistro del mouse sull'ellisse, viene eseguito `handler2`.</span><span class="sxs-lookup"><span data-stu-id="b1598-275">When the left mouse button is pressed over the ellipse, `handler2` is executed.</span></span> <span data-ttu-id="b1598-276">Al termine dell'`handler2`, l'evento viene passato all'oggetto <xref:System.Windows.Controls.Canvas>, che usa `handler1` per elaborarlo.</span><span class="sxs-lookup"><span data-stu-id="b1598-276">After `handler2` finishes, the event is passed along to the <xref:System.Windows.Controls.Canvas> object, which uses `handler1` to process it.</span></span> <span data-ttu-id="b1598-277">Questa situazione si verifica solo se `handler2` non contrassegna in modo esplicito l'oggetto evento come gestito.</span><span class="sxs-lookup"><span data-stu-id="b1598-277">This happens only if `handler2` does not explicitly mark the event object as handled.</span></span>

 <span data-ttu-id="b1598-278">È possibile che `handler2` l'elaborazione di questo evento venga eseguita da molto tempo.</span><span class="sxs-lookup"><span data-stu-id="b1598-278">It’s possible that `handler2` will take a great deal of time processing this event.</span></span> <span data-ttu-id="b1598-279">`handler2` possibile utilizzare <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> per avviare un ciclo di messaggi annidato che non restituisce per ore.</span><span class="sxs-lookup"><span data-stu-id="b1598-279">`handler2` might use <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> to begin a nested message loop that doesn’t return for hours.</span></span> <span data-ttu-id="b1598-280">Se `handler2` non contrassegna l'evento come gestito quando il ciclo di messaggi è completo, l'evento viene passato alla struttura ad albero anche se è molto vecchio.</span><span class="sxs-lookup"><span data-stu-id="b1598-280">If `handler2` does not mark the event as handled when this message loop is complete, the event is passed up the tree even though it is very old.</span></span>

### <a name="reentrancy-and-locking"></a><span data-ttu-id="b1598-281">Reentrancy e blocco</span><span class="sxs-lookup"><span data-stu-id="b1598-281">Reentrancy and Locking</span></span>
 <span data-ttu-id="b1598-282">Il meccanismo di blocco del Common Language Runtime (CLR) non si comporta esattamente come si può immaginare; si potrebbe aspettare che un thread smetta completamente l'operazione quando viene richiesto un blocco.</span><span class="sxs-lookup"><span data-stu-id="b1598-282">The locking mechanism of the common language runtime (CLR) doesn’t behave exactly as one might imagine; one might expect a thread to cease operation completely when requesting a lock.</span></span> <span data-ttu-id="b1598-283">In realtà, il thread continua a ricevere ed elaborare i messaggi con priorità alta.</span><span class="sxs-lookup"><span data-stu-id="b1598-283">In actuality, the thread continues to receive and process high-priority messages.</span></span> <span data-ttu-id="b1598-284">Questo consente di evitare i deadlock e rendere le interfacce un minimo reattive, ma introduce la possibilità di bug.</span><span class="sxs-lookup"><span data-stu-id="b1598-284">This helps prevent deadlocks and make interfaces minimally responsive, but it introduces the possibility for subtle bugs.</span></span>  <span data-ttu-id="b1598-285">Nella maggior parte dei casi non è necessario conoscere questo aspetto, ma in rari casi (in genere che coinvolgono i messaggi della finestra Win32 o i componenti COM STA) può essere utile sapere.</span><span class="sxs-lookup"><span data-stu-id="b1598-285">The vast majority of the time you don’t need to know anything about this, but under rare circumstances (usually involving Win32 window messages or COM STA components) this can be worth knowing.</span></span>

 <span data-ttu-id="b1598-286">La maggior parte delle interfacce non è compilata tenendo conto di thread safety perché gli sviluppatori utilizzano il presupposto che non venga mai eseguito l'accesso a una [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] da più di un thread.</span><span class="sxs-lookup"><span data-stu-id="b1598-286">Most interfaces are not built with thread safety in mind because developers work under the assumption that a [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] is never accessed by more than one thread.</span></span> <span data-ttu-id="b1598-287">In questo caso, il singolo thread può apportare modifiche ambientali in momenti imprevisti, causando gli effetti negativi che la <xref:System.Windows.Threading.DispatcherObject> meccanismo di esclusione reciproca dovrebbe risolvere.</span><span class="sxs-lookup"><span data-stu-id="b1598-287">In this case, that single thread may make environmental changes at unexpected times, causing those ill effects that the <xref:System.Windows.Threading.DispatcherObject> mutual exclusion mechanism is supposed to solve.</span></span> <span data-ttu-id="b1598-288">Si consideri lo pseudocodice seguente:</span><span class="sxs-lookup"><span data-stu-id="b1598-288">Consider the following pseudocode:</span></span>

 <span data-ttu-id="b1598-289">![Diagramma che mostra la rientranza del threading.](./media/threading-model/threading-reentrancy.png "ThreadingReentrancy")</span><span class="sxs-lookup"><span data-stu-id="b1598-289">![Diagram that shows threading reentrancy.](./media/threading-model/threading-reentrancy.png "ThreadingReentrancy")</span></span>

 <span data-ttu-id="b1598-290">Nella maggior parte dei casi questo è il momento giusto, ma in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] casi in cui tali rientranze impreviste possono effettivamente causare problemi.</span><span class="sxs-lookup"><span data-stu-id="b1598-290">Most of the time that’s the right thing, but there are times in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] where such unexpected reentrancy can really cause problems.</span></span> <span data-ttu-id="b1598-291">Quindi, in determinati momenti chiave, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] chiama <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>, che modifica l'istruzione di blocco per il thread in modo da utilizzare il blocco [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] rientrante, anziché il consueto blocco CLR.</span><span class="sxs-lookup"><span data-stu-id="b1598-291">So, at certain key times, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] calls <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>, which changes the lock instruction for that thread to use the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] reentrancy-free lock, instead of the usual CLR lock.</span></span>

 <span data-ttu-id="b1598-292">Perché il team CLR ha scelto questo comportamento?</span><span class="sxs-lookup"><span data-stu-id="b1598-292">So why did the CLR team choose this behavior?</span></span> <span data-ttu-id="b1598-293">La scelta ha a che fare con gli oggetti COM STA e il thread di finalizzazione.</span><span class="sxs-lookup"><span data-stu-id="b1598-293">It had to do with COM STA objects and the finalization thread.</span></span> <span data-ttu-id="b1598-294">Quando un oggetto viene sottoposto a Garbage Collection, il relativo `Finalize` metodo viene eseguito sul thread del finalizzatore dedicato, non sul thread [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="b1598-294">When an object is garbage collected, its `Finalize` method is run on the dedicated finalizer thread, not the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="b1598-295">Il problema risiede nel fatto che un oggetto COM STA creato nel thread di [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] può essere eliminato solo sul thread di [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="b1598-295">And therein lies the problem, because a COM STA object that was created on the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread can only be disposed on the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="b1598-296">CLR esegue l'equivalente di un <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> (in questo caso utilizzando Win32 `SendMessage`).</span><span class="sxs-lookup"><span data-stu-id="b1598-296">The CLR does the equivalent of a <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> (in this case using Win32’s `SendMessage`).</span></span> <span data-ttu-id="b1598-297">Tuttavia, se il thread di [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] è occupato, il thread del finalizzatore viene bloccato e l'oggetto COM STA non può essere eliminato, il che crea una perdita di memoria grave.</span><span class="sxs-lookup"><span data-stu-id="b1598-297">But if the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread is busy, the finalizer thread is stalled and the COM STA object can’t be disposed, which creates a serious memory leak.</span></span> <span data-ttu-id="b1598-298">Quindi, il team CLR ha fatto la chiamata complessa per far funzionare i blocchi nel modo in cui fanno.</span><span class="sxs-lookup"><span data-stu-id="b1598-298">So the CLR team made the tough call to make locks work the way they do.</span></span>

 <span data-ttu-id="b1598-299">L'attività per [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] consiste nel evitare una rientranza imprevista senza reintrodurre la perdita di memoria, motivo per cui non è possibile bloccare la rientranza in tutto il mondo.</span><span class="sxs-lookup"><span data-stu-id="b1598-299">The task for [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is to avoid unexpected reentrancy without reintroducing the memory leak, which is why we don’t block reentrancy everywhere.</span></span>

## <a name="see-also"></a><span data-ttu-id="b1598-300">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="b1598-300">See also</span></span>

- [<span data-ttu-id="b1598-301">Esempio di applicazione a thread singolo con calcolo a esecuzione prolungata</span><span class="sxs-lookup"><span data-stu-id="b1598-301">Single-Threaded Application with Long-Running Calculation Sample</span></span>](https://go.microsoft.com/fwlink/?LinkID=160038)
