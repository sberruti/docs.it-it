---
title: Ambiti dei nomi XAML WPF
ms.date: 03/30/2017
helpviewer_keywords:
- namescopes [WPF]
- styles [WPF], namescopes in
- templates [WPF], namescopes in
- APIs [WPF], name-related
- name-related APIs
- XAML [WPF], namescopes
- classes [WPF], FrameworkContentElement
ms.assetid: 52bbf4f2-15fc-40d4-837b-bb4c21ead7d4
ms.openlocfilehash: 97889b302aac06e118c93f2d000b0eeeed8b71bb
ms.sourcegitcommit: f8c36054eab877de4d40a705aacafa2552ce70e9
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 12/31/2019
ms.locfileid: "75559937"
---
# <a name="wpf-xaml-namescopes"></a><span data-ttu-id="c85c2-102">Ambiti dei nomi XAML WPF</span><span class="sxs-lookup"><span data-stu-id="c85c2-102">WPF XAML Namescopes</span></span>
<span data-ttu-id="c85c2-103">Un ambito dei nomi XAML è un concetto che identifica gli oggetti definiti in XAML.</span><span class="sxs-lookup"><span data-stu-id="c85c2-103">XAML namescopes are a concept that identifies objects that are defined in XAML.</span></span> <span data-ttu-id="c85c2-104">I nomi in un ambito dei nomi XAML possono essere usati per stabilire relazioni tra i nomi definiti da XAML degli oggetti e i rispettivi equivalenti di istanza in un albero di oggetti.</span><span class="sxs-lookup"><span data-stu-id="c85c2-104">The names in a XAML namescope can be used to establish relationships between the XAML-defined names of objects and their instance equivalents in an object tree.</span></span> <span data-ttu-id="c85c2-105">In genere gli ambiti dei nomi nel codice gestito [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] vengono creati durante il caricamento degli elementi radice delle singole pagine XAML per un'applicazione XAML.</span><span class="sxs-lookup"><span data-stu-id="c85c2-105">Typically, XAML namescopes in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] managed code are created when loading the individual XAML page roots for a XAML application.</span></span> <span data-ttu-id="c85c2-106">I NameScope XAML come oggetto di programmazione sono definiti dall'interfaccia <xref:System.Windows.Markup.INameScope> e vengono implementati anche dalla classe pratica <xref:System.Windows.NameScope>.</span><span class="sxs-lookup"><span data-stu-id="c85c2-106">XAML namescopes as the programming object are defined by the <xref:System.Windows.Markup.INameScope> interface and are also implemented by the practical class <xref:System.Windows.NameScope>.</span></span>  

<a name="Namescopes_in_Loaded_XAML_Applications"></a>   
## <a name="namescopes-in-loaded-xaml-applications"></a><span data-ttu-id="c85c2-107">Ambiti dei nomi in applicazioni XAML caricate</span><span class="sxs-lookup"><span data-stu-id="c85c2-107">Namescopes in Loaded XAML Applications</span></span>  
 <span data-ttu-id="c85c2-108">In un più ampio contesto di programmazione o informatico i concetti di programmazione includono spesso il principio di identificatore o nome univoco, che può essere usato per accedere a un oggetto.</span><span class="sxs-lookup"><span data-stu-id="c85c2-108">In a broader programming or computer science context, programming concepts often include the principle of a unique identifier or name that can be used to access an object.</span></span> <span data-ttu-id="c85c2-109">Per i sistemi che usano identificatori o nomi, l'ambito dei nomi definisce i limiti entro i quali un processo o una tecnica individuerà se è necessario un oggetto con tale nome oppure i limiti entro i quali viene applicata l'univocità dei nomi di identificazione.</span><span class="sxs-lookup"><span data-stu-id="c85c2-109">For systems that use identifiers or names, the namescope defines the boundaries within which a process or technique will search if an object of that name is requested, or the boundaries wherein uniqueness of identifying names is enforced.</span></span> <span data-ttu-id="c85c2-110">Questi principi generali si applicano agli ambiti dei nomi XAML.</span><span class="sxs-lookup"><span data-stu-id="c85c2-110">These general principles are true for XAML namescopes.</span></span> <span data-ttu-id="c85c2-111">In WPF gli ambiti dei nomi XAML vengono creati nell'elemento radice per una pagina XAML quando questa viene caricata.</span><span class="sxs-lookup"><span data-stu-id="c85c2-111">In WPF, XAML namescopes are created on the root element for a XAML page when the page is loaded.</span></span> <span data-ttu-id="c85c2-112">Ogni nome specificato nella pagina XAML che inizia in corrispondenza della radice della pagina viene aggiunto a un ambito dei nomi XAML pertinente.</span><span class="sxs-lookup"><span data-stu-id="c85c2-112">Each name specified within the XAML page starting at the page root is added to a pertinent XAML namescope.</span></span>  
  
 <span data-ttu-id="c85c2-113">In XAML WPF gli elementi che sono elementi radice comuni (ad esempio <xref:System.Windows.Controls.Page>e <xref:System.Windows.Window>) controllano sempre un ambito dei nomi XAML.</span><span class="sxs-lookup"><span data-stu-id="c85c2-113">In WPF XAML, elements that are common root elements (such as <xref:System.Windows.Controls.Page>, and <xref:System.Windows.Window>) always control a XAML namescope.</span></span> <span data-ttu-id="c85c2-114">Se un elemento, ad esempio <xref:System.Windows.FrameworkElement> o <xref:System.Windows.FrameworkContentElement> è l'elemento radice della pagina nel markup, un processore di [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] aggiunge una radice <xref:System.Windows.Controls.Page> in modo implicito affinché il <xref:System.Windows.Controls.Page> possa fornire un NameScope XAML funzionante.</span><span class="sxs-lookup"><span data-stu-id="c85c2-114">If an element such as <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement> is the root element of the page in markup, a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] processor adds a <xref:System.Windows.Controls.Page> root implicitly so that the <xref:System.Windows.Controls.Page> can provide a working XAML namescope.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="c85c2-115">Le azioni di compilazione di WPF creano un ambito dei nomi XAML per una produzione XAML anche se non è definito alcun attributo `Name` o `x:Name` in alcun elemento nel markup [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="c85c2-115">WPF build actions create a XAML namescope for a XAML production even if no `Name` or `x:Name` attributes are defined on any elements in the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] markup.</span></span>  
  
 <span data-ttu-id="c85c2-116">Se si prova a usare lo stesso nome due volte in un ambito dei nomi XAML, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="c85c2-116">If you try to use the same name twice in any XAML namescope, an exception is raised.</span></span> <span data-ttu-id="c85c2-117">Per codice XAML WPF che include code-behind e che fa parte di un'applicazione compilata, l'eccezione viene generata in fase di compilazione dalle azioni di compilazione di WPF, quando viene creata la classe generata per la pagina durante la compilazione iniziale del markup.</span><span class="sxs-lookup"><span data-stu-id="c85c2-117">For WPF XAML that has code-behind and is part of a compiled application, the exception is raised at build time by WPF build actions, when creating the generated class for the page during the initial markup compile.</span></span> <span data-ttu-id="c85c2-118">Per codice XAML non compilato dal markup tramite alcuna azione di compilazione, potrebbero essere generate eccezioni correlate a problemi dell'ambito dei nomi XAML durante il caricamento di XAML.</span><span class="sxs-lookup"><span data-stu-id="c85c2-118">For XAML that is not markup-compiled by any build action, exceptions related to XAML namescope issues might be raised when the XAML is loaded.</span></span> <span data-ttu-id="c85c2-119">I progettisti XAML possono anche prevedere i problemi relativi all'ambito dei nomi XAML in fase di progettazione.</span><span class="sxs-lookup"><span data-stu-id="c85c2-119">XAML designers might also anticipate XAML namescope issues at design time.</span></span>  
  
### <a name="adding-objects-to-runtime-object-trees"></a><span data-ttu-id="c85c2-120">Aggiunta di oggetti all'albero di oggetti di runtime</span><span class="sxs-lookup"><span data-stu-id="c85c2-120">Adding Objects to Runtime Object Trees</span></span>  
 <span data-ttu-id="c85c2-121">Il momento in cui XAML viene analizzato rappresenta il momento in cui viene creato e definito un ambito dei nomi XAML WPF.</span><span class="sxs-lookup"><span data-stu-id="c85c2-121">The moment that XAML is parsed represents the moment in time that a WPF XAML namescope is created and defined.</span></span> <span data-ttu-id="c85c2-122">Se si aggiunge un oggetto a un albero di oggetti in un momento successivo all'analisi del codice XAML che ha prodotto l'albero, un valore `Name` o `x:Name` nel nuovo oggetto non aggiorna automaticamente le informazioni in un ambito dei nomi XAML.</span><span class="sxs-lookup"><span data-stu-id="c85c2-122">If you add an object to an object tree at a point in time after the XAML that produced that tree was parsed, a `Name` or `x:Name` value on the new object does not automatically update the information in a XAML namescope.</span></span> <span data-ttu-id="c85c2-123">Per aggiungere un nome per un oggetto in un NameScope XAML WPF dopo il caricamento di XAML, è necessario chiamare l'implementazione appropriata di <xref:System.Windows.Markup.INameScope.RegisterName%2A> nell'oggetto che definisce l'ambito dei nomi XAML, che in genere è la radice della pagina XAML.</span><span class="sxs-lookup"><span data-stu-id="c85c2-123">To add a name for an object into a WPF XAML namescope after XAML is loaded, you must call the appropriate implementation of <xref:System.Windows.Markup.INameScope.RegisterName%2A> on the object that defines the XAML namescope, which is typically the XAML page root.</span></span> <span data-ttu-id="c85c2-124">Se il nome non è registrato, il nome non può fare riferimento all'oggetto aggiunto tramite metodi come <xref:System.Windows.FrameworkElement.FindName%2A>e non è possibile usare tale nome per la destinazione dell'animazione.</span><span class="sxs-lookup"><span data-stu-id="c85c2-124">If the name is not registered, the added object cannot be referenced by name through methods such as <xref:System.Windows.FrameworkElement.FindName%2A>, and you cannot use that name for animation targeting.</span></span>  
  
 <span data-ttu-id="c85c2-125">Lo scenario più comune per gli sviluppatori di applicazioni è che si utilizzerà <xref:System.Windows.FrameworkElement.RegisterName%2A> per registrare i nomi nell'ambito dei nomi XAML nella radice corrente della pagina.</span><span class="sxs-lookup"><span data-stu-id="c85c2-125">The most common scenario for application developers is that you will use <xref:System.Windows.FrameworkElement.RegisterName%2A> to register names into the XAML namescope on the current root of the page.</span></span> <span data-ttu-id="c85c2-126"><xref:System.Windows.FrameworkElement.RegisterName%2A> fa parte di uno scenario importante per gli storyboard destinati a oggetti per le animazioni.</span><span class="sxs-lookup"><span data-stu-id="c85c2-126"><xref:System.Windows.FrameworkElement.RegisterName%2A> is part of an important scenario for storyboards that target objects for animations.</span></span> <span data-ttu-id="c85c2-127">Per altre informazioni, vedere [Cenni preliminari sugli storyboard](../graphics-multimedia/storyboards-overview.md).</span><span class="sxs-lookup"><span data-stu-id="c85c2-127">For more information, see [Storyboards Overview](../graphics-multimedia/storyboards-overview.md).</span></span>  
  
 <span data-ttu-id="c85c2-128">Se si chiama <xref:System.Windows.FrameworkElement.RegisterName%2A> su un oggetto diverso dall'oggetto che definisce l'ambito dei nomi XAML, il nome viene ancora registrato nell'ambito dei nomi XAML in cui è contenuto l'oggetto chiamante, come se si fosse chiamato <xref:System.Windows.FrameworkElement.RegisterName%2A> sull'oggetto che definisce l'ambito dei nomi XAML.</span><span class="sxs-lookup"><span data-stu-id="c85c2-128">If you call <xref:System.Windows.FrameworkElement.RegisterName%2A> on an object other than the object that defines the XAML namescope, the name is still registered to the XAML namescope that the calling object is held within, as if you had called <xref:System.Windows.FrameworkElement.RegisterName%2A> on the XAML namescope defining object.</span></span>  
  
### <a name="xaml-namescopes-in-code"></a><span data-ttu-id="c85c2-129">Ambiti dei nomi XAML nel codice</span><span class="sxs-lookup"><span data-stu-id="c85c2-129">XAML Namescopes in Code</span></span>  
 <span data-ttu-id="c85c2-130">È possibile creare e quindi usare ambiti dei nomi XAML nel codice.</span><span class="sxs-lookup"><span data-stu-id="c85c2-130">You can create and then use XAML namescopes in code.</span></span> <span data-ttu-id="c85c2-131">Le API e i concetti interessati dalla creazione di ambiti dei nomi XAML sono gli stessi, anche per l'utilizzo di codice puro, perché il processore XAML per [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] usa questi concetti e API quando elabora il codice XAML stesso.</span><span class="sxs-lookup"><span data-stu-id="c85c2-131">The APIs and the concepts involved in XAML namescope creation are the same even for a pure code usage, because the XAML processor for [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses these APIs and concepts when it processes XAML itself.</span></span> <span data-ttu-id="c85c2-132">I concetti e le API hanno prevalentemente lo scopo di trovare oggetti in base al nome all'interno di un albero di oggetti definito parzialmente o interamente in XAML.</span><span class="sxs-lookup"><span data-stu-id="c85c2-132">The concepts and API exist mainly for the purpose of being able to find objects by name within an object tree that is typically defined partially or entirely in XAML.</span></span>  
  
 <span data-ttu-id="c85c2-133">Per le applicazioni create a livello di codice e non da codice XAML caricato, l'oggetto che definisce un ambito dei nomi XAML deve implementare <xref:System.Windows.Markup.INameScope>, o essere una classe derivata <xref:System.Windows.FrameworkElement> o <xref:System.Windows.FrameworkContentElement>, per supportare la creazione di un ambito dei nomi XAML nelle relative istanze.</span><span class="sxs-lookup"><span data-stu-id="c85c2-133">For applications that are created programmatically, and not from loaded XAML, the object that defines a XAML namescope must implement <xref:System.Windows.Markup.INameScope>, or be a <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement> derived class, in order to support creation of a XAML namescope on its instances.</span></span>  
  
 <span data-ttu-id="c85c2-134">Inoltre, per qualsiasi elemento che non viene caricato ed elaborato da un processore XAML, l'ambito dei nomi XAML per l'oggetto non viene creato o inizializzato per impostazione predefinita.</span><span class="sxs-lookup"><span data-stu-id="c85c2-134">Also, for any element that is not loaded and processed by a XAML processor, the XAML namescope for the object is not created or initialized by default.</span></span> <span data-ttu-id="c85c2-135">È necessario creare un nuovo ambito dei nomi XAML per qualsiasi oggetto in cui si intende successivamente registrare nomi.</span><span class="sxs-lookup"><span data-stu-id="c85c2-135">You must explicitly create a new XAML namescope for any object that you intend to register names into subsequently.</span></span> <span data-ttu-id="c85c2-136">Per creare un ambito dei nomi XAML, chiamare il metodo statico <xref:System.Windows.NameScope.SetNameScope%2A>.</span><span class="sxs-lookup"><span data-stu-id="c85c2-136">To create a XAML namescope, you call the static <xref:System.Windows.NameScope.SetNameScope%2A> method.</span></span> <span data-ttu-id="c85c2-137">Specificare l'oggetto che ne sarà proprietario come parametro di `dependencyObject` e una nuova chiamata al costruttore <xref:System.Windows.NameScope.%23ctor%2A> come parametro `value`.</span><span class="sxs-lookup"><span data-stu-id="c85c2-137">Specify the object that will own it as the `dependencyObject` parameter, and a new <xref:System.Windows.NameScope.%23ctor%2A> constructor call as the `value` parameter.</span></span>  
  
 <span data-ttu-id="c85c2-138">Se l'oggetto fornito come `dependencyObject` per <xref:System.Windows.NameScope.SetNameScope%2A> non è un'implementazione <xref:System.Windows.Markup.INameScope>, <xref:System.Windows.FrameworkElement> o <xref:System.Windows.FrameworkContentElement>, la chiamata di <xref:System.Windows.FrameworkElement.RegisterName%2A> su tutti gli elementi figlio non avrà alcun effetto.</span><span class="sxs-lookup"><span data-stu-id="c85c2-138">If the object provided as `dependencyObject` for <xref:System.Windows.NameScope.SetNameScope%2A> is not a <xref:System.Windows.Markup.INameScope> implementation, <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>, calling <xref:System.Windows.FrameworkElement.RegisterName%2A> on any child elements will have no effect.</span></span> <span data-ttu-id="c85c2-139">Se non è possibile creare in modo esplicito il nuovo ambito dei nomi XAML, le chiamate a <xref:System.Windows.FrameworkElement.RegisterName%2A> genereranno un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="c85c2-139">If you fail to create the new XAML namescope explicitly, then calls to <xref:System.Windows.FrameworkElement.RegisterName%2A> will raise an exception.</span></span>  
  
 <span data-ttu-id="c85c2-140">Per un esempio dell'uso di API di ambito dei nomi XAML nel codice, vedere [Definire un ambito dei nomi](../graphics-multimedia/how-to-define-a-name-scope.md).</span><span class="sxs-lookup"><span data-stu-id="c85c2-140">For an example of using XAML namescope APIs in code, see [Define a Name Scope](../graphics-multimedia/how-to-define-a-name-scope.md).</span></span>  
  
<a name="Namescopes_in_Styles_and_Templates"></a>   
## <a name="xaml-namescopes-in-styles-and-templates"></a><span data-ttu-id="c85c2-141">Ambiti dei nomi XAML in stili e modelli</span><span class="sxs-lookup"><span data-stu-id="c85c2-141">XAML Namescopes in Styles and Templates</span></span>  
 <span data-ttu-id="c85c2-142">Gli stili e i modelli in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] permettono di riutilizzare e riapplicare contenuto in modo diretto.</span><span class="sxs-lookup"><span data-stu-id="c85c2-142">Styles and templates in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] provide the ability to reuse and reapply content in a straightforward way.</span></span> <span data-ttu-id="c85c2-143">Tuttavia, stili e modelli potrebbero includere anche elementi con nomi XAML definiti a livello del modello.</span><span class="sxs-lookup"><span data-stu-id="c85c2-143">However, styles and templates might also include elements with XAML names defined at the template level.</span></span> <span data-ttu-id="c85c2-144">Questo stesso modello potrebbe essere usato più volte in una pagina.</span><span class="sxs-lookup"><span data-stu-id="c85c2-144">That same template might be used multiple times in a page.</span></span> <span data-ttu-id="c85c2-145">Per questo motivo, gli stili e i modelli definiscono entrambi ambiti dei nomi XAML propri, indipendentemente dalla posizione in un albero di oggetti in cui viene applicato lo stile o il modello.</span><span class="sxs-lookup"><span data-stu-id="c85c2-145">For this reason, styles and templates both define their own XAML namescopes, independent of whatever location in an object tree where the style or template is applied.</span></span>  
  
 <span data-ttu-id="c85c2-146">Si consideri l'esempio seguente:</span><span class="sxs-lookup"><span data-stu-id="c85c2-146">Consider the following example:</span></span>  
  
 [!code-xaml[XamlOvwSupport#NameScopeTemplates](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page6.xaml#namescopetemplates)]  
  
 <span data-ttu-id="c85c2-147">Qui viene applicato lo stesso modello a due diversi pulsanti.</span><span class="sxs-lookup"><span data-stu-id="c85c2-147">Here, the same template is applied to two different buttons.</span></span> <span data-ttu-id="c85c2-148">Se i modelli non avessero ambiti dei nomi XAML discreti, il nome `TheBorder` usato nel modello causerebbe un conflitto di nomi nell'ambito dei nomi XAML.</span><span class="sxs-lookup"><span data-stu-id="c85c2-148">If templates did not have discrete XAML namescopes, the `TheBorder` name used in the template would cause a name collision in the XAML namescope.</span></span> <span data-ttu-id="c85c2-149">Poiché la creazione di ogni istanza del modello ha un ambito dei nomi XAML proprio, in questo esempio l'ambito dei nomi di ogni modello di cui è stata creata un'istanza contiene esattamente un solo nome.</span><span class="sxs-lookup"><span data-stu-id="c85c2-149">Each instantiation of the template has its own XAML namescope, so in this example each instantiated template's XAML namescope would contain exactly one name.</span></span>  
  
 <span data-ttu-id="c85c2-150">Anche gli stili definiscono un ambito dei nomi XAML proprio, per lo più in modo che alle parti degli storyboard possano essere assegnati nomi specifici.</span><span class="sxs-lookup"><span data-stu-id="c85c2-150">Styles also define their own XAML namescope, mostly so that parts of storyboards can have particular names assigned.</span></span> <span data-ttu-id="c85c2-151">Questi nomi permettono comportamenti specifici dei controlli destinati a elementi con questi nomi, anche se il modello è stato ridefinito come parte della personalizzazione del controllo.</span><span class="sxs-lookup"><span data-stu-id="c85c2-151">These names enable control specific behaviors that will target elements of that name, even if the template was re-defined as part of control customization.</span></span>  
  
 <span data-ttu-id="c85c2-152">A causa della presenza di ambiti dei nomi XAML separati, la ricerca di elementi denominati in un modello è più complessa rispetto all'individuazione di un elemento denominato senza modello in una pagina.</span><span class="sxs-lookup"><span data-stu-id="c85c2-152">Because of the separate XAML namescopes, finding named elements in a template is more challenging than finding a non-templated named element in a page.</span></span> <span data-ttu-id="c85c2-153">Per prima cosa è necessario determinare il modello applicato, ottenendo il valore della proprietà <xref:System.Windows.Controls.Control.Template%2A> del controllo in cui viene applicato il modello.</span><span class="sxs-lookup"><span data-stu-id="c85c2-153">You first need to determine the applied template, by getting the <xref:System.Windows.Controls.Control.Template%2A> property value of the control where the template is applied.</span></span> <span data-ttu-id="c85c2-154">Viene quindi chiamata la versione del modello di <xref:System.Windows.FrameworkTemplate.FindName%2A>, passando il controllo in cui è stato applicato il modello come secondo parametro.</span><span class="sxs-lookup"><span data-stu-id="c85c2-154">Then, you call the template version of <xref:System.Windows.FrameworkTemplate.FindName%2A>, passing the control where the template was applied as the second parameter.</span></span>  
  
 <span data-ttu-id="c85c2-155">Se si è un autore del controllo e si genera una convenzione in cui un particolare elemento denominato in un modello applicato è la destinazione per un comportamento definito dal controllo stesso, è possibile usare il metodo <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> dal codice di implementazione del controllo.</span><span class="sxs-lookup"><span data-stu-id="c85c2-155">If you are a control author and you are generating a convention where a particular named element in an applied template is the target for a behavior that is defined by the control itself, you can use the <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> method from your control implementation code.</span></span> <span data-ttu-id="c85c2-156">Il metodo <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> è protetto, quindi solo l'autore del controllo può accedervi.</span><span class="sxs-lookup"><span data-stu-id="c85c2-156">The <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> method is protected, so only the control author has access to it.</span></span>  
  
 <span data-ttu-id="c85c2-157">Se si utilizza un modello ed è necessario ottenere l'ambito dei nomi XAML in cui viene applicato il modello, ottenere il valore di <xref:System.Windows.FrameworkElement.TemplatedParent%2A>, quindi chiamare <xref:System.Windows.FrameworkElement.FindName%2A>.</span><span class="sxs-lookup"><span data-stu-id="c85c2-157">If you are working from within a template, and need to get to the XAML namescope where the template is applied, get the value of <xref:System.Windows.FrameworkElement.TemplatedParent%2A>, and then call <xref:System.Windows.FrameworkElement.FindName%2A> there.</span></span> <span data-ttu-id="c85c2-158">Un esempio di questa situazione è quando si scrive l'implementazione del gestore eventi in cui l'evento verrà generato da un elemento in un modello applicato.</span><span class="sxs-lookup"><span data-stu-id="c85c2-158">An example of working within the template would be if you are writing the event handler implementation where the event will be raised from an element in an applied template.</span></span>  
  
<a name="Namescopes_and_Name_related_APIs"></a>   
## <a name="xaml-namescopes-and-name-related-apis"></a><span data-ttu-id="c85c2-159">Ambiti dei nomi XAML e API correlate ai nomi</span><span class="sxs-lookup"><span data-stu-id="c85c2-159">XAML Namescopes and Name-related APIs</span></span>  
 <span data-ttu-id="c85c2-160"><xref:System.Windows.FrameworkElement> dispone di metodi <xref:System.Windows.FrameworkElement.FindName%2A>, <xref:System.Windows.FrameworkElement.RegisterName%2A> e <xref:System.Windows.FrameworkElement.UnregisterName%2A>.</span><span class="sxs-lookup"><span data-stu-id="c85c2-160"><xref:System.Windows.FrameworkElement> has <xref:System.Windows.FrameworkElement.FindName%2A>, <xref:System.Windows.FrameworkElement.RegisterName%2A> and <xref:System.Windows.FrameworkElement.UnregisterName%2A> methods.</span></span> <span data-ttu-id="c85c2-161">Se l'oggetto in cui vengono chiamati questi metodi è proprietario di un ambito dei nomi XAML, i metodi chiamano nei metodi dell'ambito dei nomi XAML pertinente.</span><span class="sxs-lookup"><span data-stu-id="c85c2-161">If the object you call these methods on owns a XAML namescope, the methods call into the methods of the relevant XAML namescope.</span></span> <span data-ttu-id="c85c2-162">In caso contrario, l'elemento padre viene controllato per verificare se è proprietario di un ambito dei nomi XAML e questo processo continua in modo ricorsivo fino a quando non viene trovato un ambito dei nomi XAML. A causa del comportamento del processore XAML, esiste sicuramente un ambito dei nomi XAML nella radice.</span><span class="sxs-lookup"><span data-stu-id="c85c2-162">Otherwise, the parent element is checked to see if it owns a XAML namescope, and this process continues recursively until a XAML namescope is found (because of the XAML processor behavior, there is guaranteed to be a XAML namescope at the root).</span></span> <span data-ttu-id="c85c2-163"><xref:System.Windows.FrameworkContentElement> ha comportamenti analoghi, ad eccezione del fatto che nessun <xref:System.Windows.FrameworkContentElement> avrà mai un ambito dei nomi XAML.</span><span class="sxs-lookup"><span data-stu-id="c85c2-163"><xref:System.Windows.FrameworkContentElement> has analogous behaviors, with the exception that no <xref:System.Windows.FrameworkContentElement> will ever own a XAML namescope.</span></span> <span data-ttu-id="c85c2-164">I metodi sono disponibili in <xref:System.Windows.FrameworkContentElement>, in modo che le chiamate possano essere successivamente trasmesse a un elemento padre <xref:System.Windows.FrameworkElement>.</span><span class="sxs-lookup"><span data-stu-id="c85c2-164">The methods exist on <xref:System.Windows.FrameworkContentElement> so that the calls can be forwarded eventually to a <xref:System.Windows.FrameworkElement> parent element.</span></span>  
  
 <span data-ttu-id="c85c2-165"><xref:System.Windows.NameScope.SetNameScope%2A> viene utilizzato per eseguire il mapping di un nuovo ambito dei nomi XAML a un oggetto esistente.</span><span class="sxs-lookup"><span data-stu-id="c85c2-165"><xref:System.Windows.NameScope.SetNameScope%2A> is used to map a new XAML namescope to an existing object.</span></span> <span data-ttu-id="c85c2-166">È possibile chiamare <xref:System.Windows.NameScope.SetNameScope%2A> più di una volta per reimpostare o deselezionare l'ambito dei nomi XAML, ma questo non è un utilizzo comune.</span><span class="sxs-lookup"><span data-stu-id="c85c2-166">You can call <xref:System.Windows.NameScope.SetNameScope%2A> more than once in order to reset or clear the XAML namescope, but that is not a common usage.</span></span> <span data-ttu-id="c85c2-167">Inoltre, <xref:System.Windows.NameScope.GetNameScope%2A> non viene in genere utilizzato dal codice.</span><span class="sxs-lookup"><span data-stu-id="c85c2-167">Also, <xref:System.Windows.NameScope.GetNameScope%2A> is not typically used from code.</span></span>  
  
### <a name="xaml-namescope-implementations"></a><span data-ttu-id="c85c2-168">Implementazioni di ambiti dei nomi XAML</span><span class="sxs-lookup"><span data-stu-id="c85c2-168">XAML Namescope Implementations</span></span>  
 <span data-ttu-id="c85c2-169">Le classi seguenti implementano <xref:System.Windows.Markup.INameScope> direttamente:</span><span class="sxs-lookup"><span data-stu-id="c85c2-169">The following classes implement <xref:System.Windows.Markup.INameScope> directly:</span></span>  
  
- <xref:System.Windows.NameScope>  
  
- <xref:System.Windows.Style>  
  
- <xref:System.Windows.ResourceDictionary>  
  
- <xref:System.Windows.FrameworkTemplate>  
  
 <span data-ttu-id="c85c2-170"><xref:System.Windows.ResourceDictionary> non utilizza nomi o ambiti dei nomi XAML; USA invece chiavi, perché si tratta di un'implementazione del dizionario.</span><span class="sxs-lookup"><span data-stu-id="c85c2-170"><xref:System.Windows.ResourceDictionary> does not use XAML names or namescopes ; it uses keys instead, because it is a dictionary implementation.</span></span> <span data-ttu-id="c85c2-171">L'unico motivo per cui <xref:System.Windows.ResourceDictionary> implementa <xref:System.Windows.Markup.INameScope> è la possibilità di generare eccezioni al codice utente che consentono di chiarire la distinzione tra un vero e proprio ambito dei nomi XAML e il modo in cui un <xref:System.Windows.ResourceDictionary> gestisce le chiavi e garantisce inoltre che gli ambiti dei nomi XAML non vengano applicati a un <xref:System.Windows.ResourceDictionary> dagli elementi padre.</span><span class="sxs-lookup"><span data-stu-id="c85c2-171">The only reason that <xref:System.Windows.ResourceDictionary> implements <xref:System.Windows.Markup.INameScope> is so it can raise exceptions to user code that help clarify the distinction between a true XAML namescope and how a <xref:System.Windows.ResourceDictionary> handles keys, and also to assure that XAML namescopes are not applied to a <xref:System.Windows.ResourceDictionary> by parent elements.</span></span>  
  
 <span data-ttu-id="c85c2-172"><xref:System.Windows.FrameworkTemplate> e <xref:System.Windows.Style> implementano <xref:System.Windows.Markup.INameScope> tramite definizioni esplicite dell'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="c85c2-172"><xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style> implement <xref:System.Windows.Markup.INameScope> through explicit interface definitions.</span></span> <span data-ttu-id="c85c2-173">Le implementazioni esplicite consentono a questi ambiti dei nomi XAML di comportarsi convenzionalmente quando si accede tramite l'interfaccia <xref:System.Windows.Markup.INameScope>, ovvero come gli ambiti dei nomi XAML vengono comunicati da [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] processi interni.</span><span class="sxs-lookup"><span data-stu-id="c85c2-173">The explicit implementations allow these XAML namescopes to behave conventionally when they are accessed through the <xref:System.Windows.Markup.INameScope> interface, which is how XAML namescopes are communicated by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] internal processes.</span></span> <span data-ttu-id="c85c2-174">Tuttavia, le definizioni esplicite dell'interfaccia non fanno parte della superficie API convenzionale di <xref:System.Windows.FrameworkTemplate> e <xref:System.Windows.Style>, perché raramente è necessario chiamare i metodi di <xref:System.Windows.Markup.INameScope> su <xref:System.Windows.FrameworkTemplate> e <xref:System.Windows.Style> direttamente e usare invece altre API come <xref:System.Windows.FrameworkElement.GetTemplateChild%2A>.</span><span class="sxs-lookup"><span data-stu-id="c85c2-174">But the explicit interface definitions are not part of the conventional API surface of <xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style>, because you seldom need to call the <xref:System.Windows.Markup.INameScope> methods on <xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style> directly, and instead would use other API such as <xref:System.Windows.FrameworkElement.GetTemplateChild%2A>.</span></span>  
  
 <span data-ttu-id="c85c2-175">Le classi seguenti definiscono il proprio ambito dei nomi XAML, usando la classe helper <xref:System.Windows.NameScope?displayProperty=nameWithType> e connettendosi all'implementazione del NameScope XAML tramite la <xref:System.Windows.NameScope.NameScope%2A?displayProperty=nameWithType> proprietà associata:</span><span class="sxs-lookup"><span data-stu-id="c85c2-175">The following classes define their own XAML namescope, by using the <xref:System.Windows.NameScope?displayProperty=nameWithType> helper class and connecting to its XAML namescope implementation through the <xref:System.Windows.NameScope.NameScope%2A?displayProperty=nameWithType> attached property:</span></span>  
  
- <xref:System.Windows.FrameworkElement>  
  
- <xref:System.Windows.FrameworkContentElement>  
  
## <a name="see-also"></a><span data-ttu-id="c85c2-176">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="c85c2-176">See also</span></span>

- [<span data-ttu-id="c85c2-177">Spazi dei nomi XAML e mapping dello spazio dei nomi per XAML WPF</span><span class="sxs-lookup"><span data-stu-id="c85c2-177">XAML Namespaces and Namespace Mapping for WPF XAML</span></span>](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)
- [<span data-ttu-id="c85c2-178">Direttiva x:Name</span><span class="sxs-lookup"><span data-stu-id="c85c2-178">x:Name Directive</span></span>](../../../desktop-wpf/xaml-services/xname-directive.md)
