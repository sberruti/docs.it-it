---
title: Controllo delle versioni dei servizi
ms.date: 03/30/2017
ms.assetid: 37575ead-d820-4a67-8059-da11a2ab48e2
ms.openlocfilehash: ea5e80e33d1b29e01e6d1867c50bb3bb973b01c3
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 03/12/2020
ms.locfileid: "79183118"
---
# <a name="service-versioning"></a><span data-ttu-id="5ce3d-102">Controllo delle versioni dei servizi</span><span class="sxs-lookup"><span data-stu-id="5ce3d-102">Service Versioning</span></span>
<span data-ttu-id="5ce3d-103">Dopo la distribuzione iniziale e, potenzialmente, più volte durante il loro ciclo di vita, potrebbe essere necessario cambiare i servizi (e gli endpoint che espongono) per molteplici ragioni, ad esempio perché cambiano le esigenze aziendali, i requisiti IT o per risolvere altri problemi.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-103">After initial deployment, and potentially several times during their lifetime, services (and the endpoints they expose) may need to be changed for a variety of reasons, such as changing business needs, information technology requirements, or to address other issues.</span></span> <span data-ttu-id="5ce3d-104">Ogni modifica introduce una nuova versione del servizio.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-104">Each change introduces a new version of the service.</span></span> <span data-ttu-id="5ce3d-105">In questo argomento viene illustrato come considerare il controllo delle versioni in Windows Communication Foundation (WCF).</span><span class="sxs-lookup"><span data-stu-id="5ce3d-105">This topic explains how to consider versioning in Windows Communication Foundation (WCF).</span></span>  
  
## <a name="four-categories-of-service-changes"></a><span data-ttu-id="5ce3d-106">Quattro categorie di modifiche del servizio</span><span class="sxs-lookup"><span data-stu-id="5ce3d-106">Four Categories of Service Changes</span></span>  
 <span data-ttu-id="5ce3d-107">Le modifiche richieste ai servizi possono essere classificate in quattro categorie:</span><span class="sxs-lookup"><span data-stu-id="5ce3d-107">The changes to services that may be required can be classified into four categories:</span></span>  
  
- <span data-ttu-id="5ce3d-108">Modifiche del contratto: ad esempio, potrebbe venire aggiunta un'operazione, oppure potrebbe venire aggiunto o modificato un elemento dati in un messaggio.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-108">Contract changes: For example, an operation might be added, or a data element in a message might be added or changed.</span></span>  
  
- <span data-ttu-id="5ce3d-109">Modifiche dell'indirizzo: ad esempio, un servizio viene spostato in un percorso diverso in cui gli endpoint hanno nuovi indirizzi.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-109">Address changes: For example, a service moves to a different location where endpoints have new addresses.</span></span>  
  
- <span data-ttu-id="5ce3d-110">Modifiche dell'associazione: ad esempio, cambia un meccanismo di sicurezza, oppure cambiano le sue impostazioni.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-110">Binding changes: For example, a security mechanism changes or its settings change.</span></span>  
  
- <span data-ttu-id="5ce3d-111">Modifiche dell'implementazione: ad esempio, cambia l'implementazione del metodo interno.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-111">Implementation changes: For example, when an internal method implementation changes.</span></span>  
  
 <span data-ttu-id="5ce3d-112">Alcune di queste modifiche sono chiamate di "interruzione" e altre di "non di interruzione".</span><span class="sxs-lookup"><span data-stu-id="5ce3d-112">Some of these changes are called "breaking" and others are "nonbreaking."</span></span> <span data-ttu-id="5ce3d-113">Una modifica è *un'interdurantel',* se tutti i messaggi che sarebbero stati elaborati correttamente nella versione precedente vengono elaborati correttamente nella nuova versione.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-113">A change is *nonbreaking* if all messages that would have been processed successfully in the previous version are processed successfully in the new version.</span></span> <span data-ttu-id="5ce3d-114">Qualsiasi modifica che non soddisfa tale criterio è una modifica *sostanziale.*</span><span class="sxs-lookup"><span data-stu-id="5ce3d-114">Any change that does not meet that criterion is a *breaking* change.</span></span>  
  
## <a name="service-orientation-and-versioning"></a><span data-ttu-id="5ce3d-115">Orientamento del servizio e controllo delle versioni</span><span class="sxs-lookup"><span data-stu-id="5ce3d-115">Service Orientation and Versioning</span></span>  
 <span data-ttu-id="5ce3d-116">Uno dei principi dell'orientamento del servizio è che servizi e client sono autonomi (o indipendenti).</span><span class="sxs-lookup"><span data-stu-id="5ce3d-116">One of the tenets of service orientation is that services and clients are autonomous (or independent).</span></span> <span data-ttu-id="5ce3d-117">Tra le altre cose, ciò implica che gli sviluppatori del servizio non possono presupporre di controllare né conoscere tutti i client del servizio.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-117">Among other things, this implies that service developers cannot assume that they control or even know about all service clients.</span></span> <span data-ttu-id="5ce3d-118">In tal modo non si dovrà ricreare e ridistribuire tutti i client quando un servizio cambia versione.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-118">This eliminates the option of rebuilding and redeploying all clients when a service changes versions.</span></span> <span data-ttu-id="5ce3d-119">In questo argomento si presume che il servizio aderisca a questo principio e che pertanto debba essere modificato o sottoposto al controllo della versione indipendentemente dai propri client.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-119">This topic assumes the service adheres to this tenet and therefore must be changed or "versioned" independent of its clients.</span></span>  
  
 <span data-ttu-id="5ce3d-120">Nei casi in cui non sia possibile evitare una modifica imprevista che può determinare interruzioni, un'applicazione può scegliere di ignorare questo principio e richiedere che i client vengano ricreati e ridistribuiti con una nuova versione del servizio.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-120">In cases where a breaking change is unexpected and cannot be avoided, an application may choose to ignore this tenet and require that clients be rebuilt and redeployed with a new version of the service.</span></span>  
  
## <a name="contract-versioning"></a><span data-ttu-id="5ce3d-121">Controllo delle versioni dei contratti</span><span class="sxs-lookup"><span data-stu-id="5ce3d-121">Contract Versioning</span></span>  
 <span data-ttu-id="5ce3d-122">I contratti utilizzati da un client non devono necessariamente essere uguali a quelli utilizzati dal servizio. È sufficiente che siano compatibili.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-122">Contracts used by a client do not need to be the same as the contract used by the service; they need only to be compatible.</span></span>  
  
 <span data-ttu-id="5ce3d-123">Per i contratti di servizio, compatibilità significa che è possibile aggiungere nuove operazioni esposte dal servizio, ma non rimuovere o modificare semanticamente le operazioni esistenti.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-123">For service contracts, compatibility means new operations exposed by the service can be added but existing operations cannot be removed or changed semantically.</span></span>  
  
 <span data-ttu-id="5ce3d-124">Per i contratti dati, compatibilità significa che è possibile aggiungere nuove definizioni del tipo di schema, ma non modificare quelle esistenti in modo tale da causare interruzioni.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-124">For data contracts, compatibility means new schema type definitions can be added but existing schema type definitions cannot be changed in breaking ways.</span></span> <span data-ttu-id="5ce3d-125">Le modifiche che possono determinare interruzioni potrebbero includere la rimozione di membri dati o la modifica del loro tipo di dati in modo incompatibile.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-125">Breaking changes might include removing data members or changing their data type incompatibly.</span></span> <span data-ttu-id="5ce3d-126">Questa funzionalità consente al servizio una certa libertà di modifica della versione dei propri contratti senza interrompere i client.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-126">This feature allows the service some latitude in changing the version of its contracts without breaking clients.</span></span> <span data-ttu-id="5ce3d-127">Nelle due sezioni successive vengono illustrate le modifiche unbreaking e breaking che possono essere apportate ai dati WCF e ai contratti di servizio.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-127">The next two sections explain nonbreaking and breaking changes that can be made to WCF data and service contracts.</span></span>  
  
## <a name="data-contract-versioning"></a><span data-ttu-id="5ce3d-128">Controllo delle versioni dei contratti dati</span><span class="sxs-lookup"><span data-stu-id="5ce3d-128">Data Contract Versioning</span></span>  
 <span data-ttu-id="5ce3d-129">Contenuto della sezione viene illustrato il controllo delle versioni dei dati quando si utilizzano le classi <xref:System.Runtime.Serialization.DataContractSerializer> e <xref:System.Runtime.Serialization.DataContractAttribute>.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-129">This section deals with data versioning when using the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.DataContractAttribute> classes.</span></span>  
  
### <a name="strict-versioning"></a><span data-ttu-id="5ce3d-130">Controllo delle versioni rigoroso</span><span class="sxs-lookup"><span data-stu-id="5ce3d-130">Strict Versioning</span></span>  
 <span data-ttu-id="5ce3d-131">In numerosi scenari in cui la modifica delle versioni rappresenta un problema, lo sviluppatore del servizio non ha il controllo dei client e pertanto non può fare ipotesi su come reagirebbero alle modifiche nell'XML del messaggio o nello schema.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-131">In many scenarios when changing versions is an issue, the service developer does not have control over the clients and therefore cannot make assumptions about how they would react to changes in the message XML or schema.</span></span> <span data-ttu-id="5ce3d-132">In questi casi, è necessario garantire che i nuovi messaggi vengano convalidati rispetto al vecchio schema, per due ragioni:</span><span class="sxs-lookup"><span data-stu-id="5ce3d-132">In these cases, you must guarantee that the new messages will validate against the old schema, for two reasons:</span></span>  
  
- <span data-ttu-id="5ce3d-133">I vecchi client sono stati sviluppati presupponendo che lo schema non sarebbe cambiato.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-133">The old clients were developed with the assumption that the schema will not change.</span></span> <span data-ttu-id="5ce3d-134">Potrebbero non riuscire a elaborare messaggi per i quali non sono mai stati progettati.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-134">They may fail to process messages that they were never designed for.</span></span>  
  
- <span data-ttu-id="5ce3d-135">I vecchi client potrebbero eseguire la convalida effettiva dello schema rispetto al vecchio schema ancora prima di tentare di elaborare i messaggi.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-135">The old clients may perform actual schema validation against the old schema before even attempting to process the messages.</span></span>  
  
 <span data-ttu-id="5ce3d-136">L'approccio consigliato in questi scenari è trattare i contratti dati esistenti come immutabili e creare quelli nuovi con nomi completi XML univoci.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-136">The recommended approach in such scenarios is to treat existing data contracts as immutable and create new ones with unique XML qualified names.</span></span> <span data-ttu-id="5ce3d-137">Lo sviluppatore del servizio aggiungerebbe quindi i nuovi metodi a un contratto di servizio esistente oppure creerebbe un nuovo contratto di servizio con metodi che utilizzano il nuovo contratto dati.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-137">The service developer would then either add new methods to an existing service contract or create a new service contract with methods that use the new data contract.</span></span>  
  
 <span data-ttu-id="5ce3d-138">Spesso accade che uno sviluppatore del servizio abbia la necessità di scrivere una logica di business che deve essere eseguita in tutte le versioni di un contratto dati oltre a un codice business specifico per ogni versione del contratto dati.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-138">It will often be the case that a service developer needs to write some business logic that should run within all versions of a data contract plus version-specific business code for each version of the data contract.</span></span> <span data-ttu-id="5ce3d-139">Nell'appendice alla fine dell'argomento viene illustrato come utilizzare le interfacce per soddisfare questa esigenza.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-139">The appendix at the end of this topic explains how interfaces can be used to satisfy this need.</span></span>  
  
### <a name="lax-versioning"></a><span data-ttu-id="5ce3d-140">Controllo delle versioni Lax</span><span class="sxs-lookup"><span data-stu-id="5ce3d-140">Lax Versioning</span></span>  
 <span data-ttu-id="5ce3d-141">In molti altri scenari, lo sviluppatore del servizio può presumere che l'aggiunta di un nuovo membro facoltativo al contratto dati non causerà l'interruzione dei client esistenti.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-141">In many other scenarios, the service developer can make the assumption that adding a new, optional member to the data contract will not break existing clients.</span></span> <span data-ttu-id="5ce3d-142">A tale fine, deve controllare se i client esistenti non stanno eseguendo la convalida dello schema e ignorano i membri dati sconosciuti.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-142">This requires the service developer to investigate whether existing clients are not performing schema validation and that they ignore unknown data members.</span></span> <span data-ttu-id="5ce3d-143">In questi scenari, è possibile sfruttare le funzionalità del contratto dati per aggiungere nuovi membri in modo da non causare interruzioni.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-143">In these scenarios, it is possible to take advantage of data contract features for adding new members in a nonbreaking way.</span></span> <span data-ttu-id="5ce3d-144">Lo sviluppatore del servizio può fare tranquillamente questa ipotesi se le funzionalità del contratto dati per il controllo delle versioni sono già state utilizzate per la prima versione del servizio.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-144">The service developer can make this assumption with confidence if the data contract features for versioning were already used for the first version of the service.</span></span>  
  
 <span data-ttu-id="5ce3d-145">WCF, ASP.NET servizi Web e molti altri stack di servizi Web supportano il controllo delle versioni *lax,* ovvero non generano eccezioni per i nuovi membri dati sconosciuti nei dati ricevuti.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-145">WCF, ASP.NET Web Services, and many other Web service stacks support *lax versioning*: that is, they do not throw exceptions for new unknown data members in received data.</span></span>  
  
 <span data-ttu-id="5ce3d-146">Accade di credere erroneamente che l'aggiunta di un nuovo membro non interromperà i client esistenti.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-146">It is easy to mistakenly believe that adding a new member will not break existing clients.</span></span> <span data-ttu-id="5ce3d-147">Se non si è certi che tutti i client possano gestire il controllo delle versioni lax, è consigliabile utilizzare le indicazioni sul controllo delle versioni strict e trattare i contratti dati come immutabili.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-147">If you are unsure that all clients can handle lax versioning, the recommendation is to use the strict versioning guidelines and treat data contracts as immutable.</span></span>  
  
 <span data-ttu-id="5ce3d-148">Per istruzioni dettagliate sul controllo delle versioni dei contratti dati, vedere [Procedure consigliate:](best-practices-data-contract-versioning.md)controllo delle versioni dei contratti dati .</span><span class="sxs-lookup"><span data-stu-id="5ce3d-148">For detailed guidelines for both lax and strict versioning of data contracts, see [Best Practices: Data Contract Versioning](best-practices-data-contract-versioning.md).</span></span>  
  
### <a name="distinguishing-between-data-contract-and-net-types"></a><span data-ttu-id="5ce3d-149">Distinzione tra contratto dati e tipi .NET</span><span class="sxs-lookup"><span data-stu-id="5ce3d-149">Distinguishing Between Data Contract and .NET Types</span></span>  
 <span data-ttu-id="5ce3d-150">È possibile progettare una struttura o una classe .NET come contratto dati applicando l'attributo <xref:System.Runtime.Serialization.DataContractAttribute> alla classe.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-150">A .NET class or structure can be projected as a data contract by applying the <xref:System.Runtime.Serialization.DataContractAttribute> attribute to the class.</span></span> <span data-ttu-id="5ce3d-151">Il tipo .NET e le sue proiezioni del contratto dati sono due argomenti distinti.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-151">The .NET type and its data contract projections are two distinct matters.</span></span> <span data-ttu-id="5ce3d-152">È possibile avere più tipi .NET con la stessa proiezione del contratto dati.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-152">It is possible to have multiple .NET types with the same data contract projection.</span></span> <span data-ttu-id="5ce3d-153">Questa distinzione è particolarmente utile per consentire di modificare il tipo .NET mantenendo il contratto dati progettato e quindi mantenendo la compatibilità con i client esistenti anche nel senso più rigoroso del termine.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-153">This distinction is especially useful in allowing you to change the .NET type while maintaining the projected data contract, thereby maintaining compatibility with existing clients even in the strict sense of the word.</span></span> <span data-ttu-id="5ce3d-154">Per mantenere questa distinzione tra il tipo .NET e il contratto dati è necessario eseguire sempre due operazioni:</span><span class="sxs-lookup"><span data-stu-id="5ce3d-154">There are two things you should always do to maintain this distinction between .NET type and data contract:</span></span>  
  
- <span data-ttu-id="5ce3d-155">Specificare un <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> e un <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A>.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-155">Specify a <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> and <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A>.</span></span> <span data-ttu-id="5ce3d-156">È necessario specificare sempre il nome e lo spazio dei nomi del contratto dati per impedire che il nome del tipo .NET e lo spazio dei nomi vengano esposti nel contratto.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-156">You should always specify the name and namespace of your data contract to prevent your .NET type’s name and namespace from being exposed in the contract.</span></span> <span data-ttu-id="5ce3d-157">In questo modo, se in seguito si decide di modificare lo spazio dei nomi .NET o il nome del tipo, il contratto dati rimarrà invariato.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-157">This way, if you decide later to change the .NET namespace or type name, your data contract remains the same.</span></span>  
  
- <span data-ttu-id="5ce3d-158">Specificare <xref:System.Runtime.Serialization.DataMemberAttribute.Name%2A>.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-158">Specify <xref:System.Runtime.Serialization.DataMemberAttribute.Name%2A>.</span></span> <span data-ttu-id="5ce3d-159">È necessario specificare sempre il nome dei propri membri dati per impedire che il nome del proprio membro .NET venga esposto nel contratto.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-159">You should always specify the name of your data members to prevent your .NET member name from being exposed in the contract.</span></span> <span data-ttu-id="5ce3d-160">In tal modo, se in seguito si decide di modificare il nome .NET del membro, il contratto dati rimarrà invariato.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-160">This way, if you decide later to change the .NET name of the member, your data contract remains the same.</span></span>  
  
### <a name="changing-or-removing-members"></a><span data-ttu-id="5ce3d-161">Modifica o rimozione di membri</span><span class="sxs-lookup"><span data-stu-id="5ce3d-161">Changing or Removing Members</span></span>  
 <span data-ttu-id="5ce3d-162">La modifica del nome o del tipo di dati di un membro o la rimozione di membri dati è un'operazione che può determinare interruzioni anche se è consentito il controllo lax delle versioni.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-162">Changing the name or data type of a member, or removing data members is a breaking change even if lax versioning is allowed.</span></span> <span data-ttu-id="5ce3d-163">Se tali operazioni sono necessarie, creare un nuovo contratto dati.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-163">If this is necessary, create a new data contract.</span></span>  
  
 <span data-ttu-id="5ce3d-164">Se la compatibilità del servizio è molto importante, è possibile ignorare i membri dati inutilizzati nel codice e lasciarli dove sono.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-164">If service compatibility is of high importance, you might consider ignoring unused data members in your code and leave them in place.</span></span> <span data-ttu-id="5ce3d-165">Se si suddivide un membro dati in più membri, si potrebbe lasciare il membro esistente nel punto in cui si trova come proprietà in grado di eseguire la separazione e la riaggregazione richieste per i client di livello inferiore (i client che non vengono aggiornati alla versione più recente).</span><span class="sxs-lookup"><span data-stu-id="5ce3d-165">If you are splitting up a data member into multiple members, you might consider leaving the existing member in place as a property that can perform the required splitting and re-aggregation for down-level clients (clients that are not upgraded to the latest version).</span></span>  
  
 <span data-ttu-id="5ce3d-166">Analogamente, le modifiche al nome del contratto dati o allo spazio dei nomi determinano interruzioni.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-166">Similarly, changes to the data contract’s name or namespace are breaking changes.</span></span>  
  
### <a name="round-trips-of-unknown-data"></a><span data-ttu-id="5ce3d-167">Sequenze di andata e ritorno di dati sconosciuti</span><span class="sxs-lookup"><span data-stu-id="5ce3d-167">Round-Trips of Unknown Data</span></span>  
 <span data-ttu-id="5ce3d-168">In alcuni scenari, è necessario far compiere una sequenza di "andata e ritorno" ai dati sconosciuti provenienti dai membri aggiunti in una nuova versione.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-168">In some scenarios, there is a need to "round-trip" unknown data that comes from members added in a new version.</span></span> <span data-ttu-id="5ce3d-169">Un servizio "versionNew", ad esempio, invia i dati con alcuni membri appena aggiunti a un client "versionOld".</span><span class="sxs-lookup"><span data-stu-id="5ce3d-169">For example, a "versionNew" service sends data with some newly added members to a "versionOld" client.</span></span> <span data-ttu-id="5ce3d-170">Il client ignora i membri appena aggiunti durante l'elaborazione del messaggio, ma invia nuovamente gli stessi dati, compresi i membri appena aggiunti, al servizio versionNew.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-170">The client ignores the newly added members when processing the message, but it resends that same data, including the newly added members, back to the versionNew service.</span></span> <span data-ttu-id="5ce3d-171">Uno scenario tipico è rappresentato da aggiornamenti dei dati in cui i dati vengono recuperati dal servizio, modificati e restituiti.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-171">The typical scenario for this is data updates where data is retrieved from the service, changed, and returned.</span></span>  
  
 <span data-ttu-id="5ce3d-172">Per consentire sequenze di andata e ritorno per un particolare tipo, quest'ultimo deve implementare l'interfaccia <xref:System.Runtime.Serialization.IExtensibleDataObject>.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-172">To enable round-tripping for a particular type, the type must implement the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface.</span></span> <span data-ttu-id="5ce3d-173">L'interfaccia contiene una proprietà, <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A>, che restituisce il tipo <xref:System.Runtime.Serialization.ExtensionDataObject>.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-173">The interface contains one property, <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> that returns the <xref:System.Runtime.Serialization.ExtensionDataObject> type.</span></span> <span data-ttu-id="5ce3d-174">La proprietà viene utilizzata per archiviare qualsiasi dato da versioni future del contratto dati che è sconosciuto alla versione corrente.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-174">The property is used to store any data from future versions of the data contract that is unknown to the current version.</span></span> <span data-ttu-id="5ce3d-175">Questi dati sono opachi al client, ma quando l'istanza viene serializzata, il contenuto della proprietà <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> viene scritto assieme al resto dei dati dei membri del contratto dati.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-175">This data is opaque to the client, but when the instance is serialized, the content of the <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> property is written with the rest of the data contract members' data.</span></span>  
  
 <span data-ttu-id="5ce3d-176">È consigliabile che tutti i tipi implementino questa interfaccia per accogliere i membri futuri sconosciuti e nuovi.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-176">It is recommended that all your types implement this interface to accommodate new and unknown future members.</span></span>  
  
### <a name="data-contract-libraries"></a><span data-ttu-id="5ce3d-177">Librerie di contratti dati</span><span class="sxs-lookup"><span data-stu-id="5ce3d-177">Data Contract Libraries</span></span>  
 <span data-ttu-id="5ce3d-178">Possono esistere librerie di contratti dati in cui un contratto viene pubblicato in un repository centrale e gli implementatori del servizio e del tipo implementano ed espongono i contratti dati da quel repository.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-178">There may be libraries of data contracts where a contract is published to a central repository, and service and type implementers implement and expose data contracts from that repository.</span></span> <span data-ttu-id="5ce3d-179">In questo caso, quando si pubblica un contratto dati nel repository, non si ha alcun controllo su chi crea i tipi che l'implementano.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-179">In that case, when you publish a data contract to the repository, you have no control over who creates types that implement it.</span></span> <span data-ttu-id="5ce3d-180">Non è pertanto possibile modificare il contratto dopo che è stato pubblicato, che sarà quindi di fatto immutabile.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-180">Thus, you cannot modify the contract once it is published, rendering it effectively immutable.</span></span>  
  
### <a name="when-using-the-xmlserializer"></a><span data-ttu-id="5ce3d-181">Utilizzo di XmlSerializer</span><span class="sxs-lookup"><span data-stu-id="5ce3d-181">When Using the XmlSerializer</span></span>  
 <span data-ttu-id="5ce3d-182">Gli stessi principi di controllo delle versioni si applicano quando si utilizza la classe <xref:System.Xml.Serialization.XmlSerializer>.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-182">The same versioning principles apply when using the <xref:System.Xml.Serialization.XmlSerializer> class.</span></span> <span data-ttu-id="5ce3d-183">Quando è richiesto un controllo rigoroso delle versioni, trattare i contratti dati come immutabili e creare i nuovi contratti dati con nomi completi univoci per le nuove versioni.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-183">When strict versioning is required, treat data contracts as immutable and create new data contracts with unique, qualified names for the new versions.</span></span> <span data-ttu-id="5ce3d-184">Quando si è certi che è possibile utilizzare il controllo lax delle versioni, è possibile aggiungere nuovi membri serializzabili nelle nuove versioni ma non modificare o rimuovere i membri esistenti.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-184">When you are sure that lax versioning can be used, you can add new serializable members in new versions but not change or remove existing members.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="5ce3d-185"><xref:System.Xml.Serialization.XmlSerializer> utilizza gli attributi <xref:System.Xml.Serialization.XmlAnyElementAttribute> e <xref:System.Xml.Serialization.XmlAnyAttributeAttribute> per supportare sequenze di andata e ritorno di dati sconosciuti.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-185">The <xref:System.Xml.Serialization.XmlSerializer> uses the <xref:System.Xml.Serialization.XmlAnyElementAttribute> and <xref:System.Xml.Serialization.XmlAnyAttributeAttribute> attributes to support round-tripping of unknown data.</span></span>  
  
## <a name="message-contract-versioning"></a><span data-ttu-id="5ce3d-186">Controllo delle versioni dei contratti di messaggio</span><span class="sxs-lookup"><span data-stu-id="5ce3d-186">Message Contract Versioning</span></span>  
 <span data-ttu-id="5ce3d-187">Le linee guida per il controllo delle versioni dei contratti di messaggio sono molto simili al controllo delle versioni dei contratti dati.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-187">The guidelines for message contract versioning are very similar to versioning data contracts.</span></span> <span data-ttu-id="5ce3d-188">Se è richiesto il controllo rigoroso delle versioni, non modificare il corpo del messaggio, ma creare un nuovo contratto di messaggio con un nome completo univoco.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-188">If strict versioning is required, you should not change your message body but instead create a new message contract with a unique qualified name.</span></span> <span data-ttu-id="5ce3d-189">Se si sa che è possibile utilizzare il controllo lax delle versioni, è possibile aggiungere nuove parti al corpo del messaggio ma non modificare o rimuove quelle esistenti.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-189">If you know that you can use lax versioning, you can add new message body parts but not change or remove existing ones.</span></span> <span data-ttu-id="5ce3d-190">Questo materiale sussidiario si applica sia ai contratti di messaggio bare che a quelli wrapped.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-190">This guidance applies both to bare and wrapped message contracts.</span></span>  
  
 <span data-ttu-id="5ce3d-191">È sempre possibile aggiungere intestazioni messaggio, anche se è utilizzato il controllo strict delle versioni.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-191">Message headers can always be added, even if strict versioning is in use.</span></span> <span data-ttu-id="5ce3d-192">Il flag MustUnderstand può influire sul controllo delle versioni.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-192">The MustUnderstand flag may affect versioning.</span></span> <span data-ttu-id="5ce3d-193">In generale, il modello di controllo delle versioni per le intestazioni in WCF è come descritto nella specifica SOAP.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-193">In general, the versioning model for headers in WCF is as described in the SOAP specification.</span></span>  
  
## <a name="service-contract-versioning"></a><span data-ttu-id="5ce3d-194">Controllo delle versioni dei contratti di servizio</span><span class="sxs-lookup"><span data-stu-id="5ce3d-194">Service Contract Versioning</span></span>  
 <span data-ttu-id="5ce3d-195">Anche il controllo delle versioni dei contratti di servizio implica operazioni di aggiunta, modifica e rimozione, in modo analogo a quello dei contratti dati.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-195">Similar to data contract versioning, service contract versioning also involves adding, changing, and removing operations.</span></span>  
  
### <a name="specifying-name-namespace-and-action"></a><span data-ttu-id="5ce3d-196">Specifica di nome, spazio dei nomi e azione</span><span class="sxs-lookup"><span data-stu-id="5ce3d-196">Specifying Name, Namespace, and Action</span></span>  
 <span data-ttu-id="5ce3d-197">Per impostazione predefinita, il nome di un contratto di servizio è il nome dell'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-197">By default, the name of a service contract is the name of the interface.</span></span> <span data-ttu-id="5ce3d-198">Il relativohttp://tempuri.orgspazio dei nomi predefinito èhttp://tempuri.org/contractname/methodname" ", e l'azione di ogni operazione è " ".</span><span class="sxs-lookup"><span data-stu-id="5ce3d-198">Its default namespace is "http://tempuri.org", and each operation’s action is "http://tempuri.org/contractname/methodname".</span></span> <span data-ttu-id="5ce3d-199">È consigliabile specificare in modo esplicito un nome e uno spazio deihttp://tempuri.orgnomi per il contratto di servizio e un'azione per ogni operazione per evitare l'utilizzo di " " e per impedire che i nomi di interfaccia e metodo vengano esposti nel contratto del servizio.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-199">It is recommended that you explicitly specify a name and namespace for the service contract, and an action for each operation to avoid using "http://tempuri.org" and to prevent interface and method names from being exposed in the service’s contract.</span></span>  
  
### <a name="adding-parameters-and-operations"></a><span data-ttu-id="5ce3d-200">Aggiunta di parametri e operazioni</span><span class="sxs-lookup"><span data-stu-id="5ce3d-200">Adding Parameters and Operations</span></span>  
 <span data-ttu-id="5ce3d-201">L'aggiunta di operazioni del servizio esposte dal servizio è una modifica che non provoca interruzioni perché non è necessario che i client esistenti si occupino delle nuove operazioni.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-201">Adding service operations exposed by the service is a nonbreaking change because existing clients need not be concerned about those new operations.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="5ce3d-202">L'aggiunta di operazioni a un contratto di callback duplex è una modifica che può provocare interruzioni.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-202">Adding operations to a duplex callback contract is a breaking change.</span></span>  
  
### <a name="changing-operation-parameter-or-return-types"></a><span data-ttu-id="5ce3d-203">Modifica del parametro dell'operazione o tipi restituiti</span><span class="sxs-lookup"><span data-stu-id="5ce3d-203">Changing Operation Parameter or Return Types</span></span>  
 <span data-ttu-id="5ce3d-204">La modifica del parametro o dei tipi restituiti in genere determina interruzioni a meno che il nuovo tipo non implementi lo stesso contratto dati implementato dal vecchio tipo.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-204">Changing parameter or return types generally is a breaking change unless the new type implements the same data contract implemented by the old type.</span></span> <span data-ttu-id="5ce3d-205">Per apportare questa modifica, aggiungere una nuova operazione al contratto di servizio o definire un nuovo contratto di servizio.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-205">To make such a change, add a new operation to the service contract or define a new service contract.</span></span>  
  
### <a name="removing-operations"></a><span data-ttu-id="5ce3d-206">Rimozione di operazioni</span><span class="sxs-lookup"><span data-stu-id="5ce3d-206">Removing Operations</span></span>  
 <span data-ttu-id="5ce3d-207">Anche la rimozione di operazioni è una modifica che determina interruzioni.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-207">Removing operations is also a breaking change.</span></span> <span data-ttu-id="5ce3d-208">Per apportare tale modifica, definire un nuovo contratto di servizio ed esporlo su un nuovo endpoint.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-208">To make such a change, define a new service contract and expose it on a new endpoint.</span></span>  
  
### <a name="fault-contracts"></a><span data-ttu-id="5ce3d-209">Contratti di errore</span><span class="sxs-lookup"><span data-stu-id="5ce3d-209">Fault Contracts</span></span>  
 <span data-ttu-id="5ce3d-210">L'attributo <xref:System.ServiceModel.FaultContractAttribute> consente a un sviluppatore di contratti di servizio di specificare informazioni sugli errori che possono essere restituiti dalle operazioni del contratto.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-210">The <xref:System.ServiceModel.FaultContractAttribute> attribute enables a service contract developer to specify information about faults that can be returned from the contract's operations.</span></span>  
  
 <span data-ttu-id="5ce3d-211">L'elenco degli errori descritti nel contratto di un servizio non è considerato completo.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-211">The list of faults described in a service's contract is not considered exhaustive.</span></span> <span data-ttu-id="5ce3d-212">In qualsiasi momento, un'operazione può restituire errori che non sono descritti nel suo contratto.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-212">At any time, an operation may return faults that are not described in its contract.</span></span> <span data-ttu-id="5ce3d-213">La modifica de set di errori descritti nel contratto non è pertanto considerata una modifica che determina interruzioni.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-213">Therefore changing the set of faults described in the contract is not considered breaking.</span></span> <span data-ttu-id="5ce3d-214">Questo è il caso, ad esempio, dell'aggiunta di un nuovo errore al contratto utilizzando <xref:System.ServiceModel.FaultContractAttribute> o della rimozione di un errore esistente dal contratto.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-214">For example, adding a new fault to the contract using the <xref:System.ServiceModel.FaultContractAttribute> or removing an existing fault from the contract.</span></span>  
  
### <a name="service-contract-libraries"></a><span data-ttu-id="5ce3d-215">Librerie di contratti di servizio</span><span class="sxs-lookup"><span data-stu-id="5ce3d-215">Service Contract Libraries</span></span>  
 <span data-ttu-id="5ce3d-216">Le organizzazioni possono avere librerie di contratti in cui un contratto viene pubblicato in un repository centrale e il servizio implementa i contratti da quel repository.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-216">Organizations may have libraries of contracts where a contract is published to a central repository and service implementers implement contracts from that repository.</span></span> <span data-ttu-id="5ce3d-217">In questo caso, quando si pubblica un contratto di servizio nel repository, non si ha alcun controllo su chi crea i servizi che l'implementano.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-217">In this case, when you publish a service contract to the repository you have no control over who creates services that implement it.</span></span> <span data-ttu-id="5ce3d-218">Non è pertanto possibile modificare il contratto di servizio dopo che è stato pubblicato, rendendolo di fatto immutabile.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-218">Therefore, you cannot modify the service contract once published, rendering it effectively immutable.</span></span> <span data-ttu-id="5ce3d-219">WCF supporta l'ereditarietà del contratto, che può essere utilizzata per creare un nuovo contratto che estende i contratti esistenti.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-219">WCF supports contract inheritance, which can be used to create a new contract that extends existing contracts.</span></span> <span data-ttu-id="5ce3d-220">Per utilizzare questa funzionalità, definire una nuova interfaccia del contratto di servizio che eredita dalla vecchia interfaccia del contratto di servizio, quindi aggiungere metodi alla nuova interfaccia.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-220">To use this feature, define a new service contract interface that inherits from the old service contract interface, then add methods to the new interface.</span></span> <span data-ttu-id="5ce3d-221">Modificare quindi il servizio che implementa il vecchio contratto per implementare quello nuovo e modificare la definizione dell'endpoint "versionOld" per utilizzare il nuovo contratto.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-221">You then change the service that implements the old contract to implement the new contract and change the "versionOld" endpoint definition to use the new contract.</span></span> <span data-ttu-id="5ce3d-222">Ai client "versionOld", l'endpoint continuerà a sembrare come se esponesse il contratto "versionOld"; ai client "versionNew", l'endpoint sembrerà esporre il contratto "versionNew".</span><span class="sxs-lookup"><span data-stu-id="5ce3d-222">To "versionOld" clients, the endpoint will continue to appear as exposing the "versionOld" contract; to "versionNew" clients, the endpoint will appear to expose the "versionNew" contract.</span></span>  
  
## <a name="address-and-binding-versioning"></a><span data-ttu-id="5ce3d-223">Controllo delle versioni di associazioni e indirizzi</span><span class="sxs-lookup"><span data-stu-id="5ce3d-223">Address and Binding Versioning</span></span>  
 <span data-ttu-id="5ce3d-224">Le modifiche all'indirizzo endpoint e all'associazione sono modifiche che possono determinare interruzioni a meno che i client non siano in grado di scoprire dinamicamente il nuovo indirizzo endpoint o la nuova associazione.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-224">Changes to endpoint address and binding are breaking changes unless clients are capable of dynamically discovering the new endpoint address or binding.</span></span> <span data-ttu-id="5ce3d-225">Per implementare questa funzionalità è possibile usare un Registro di sistema UDDI (Universal Discovery Description and Integration) e il modello di chiamata UDDI in cui un client tenta di comunicare con un endpoint e, in caso di errore, esegue una query nel registro di sistema UDDI noto, per cercare i metadati dell'endpoint corrente.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-225">One mechanism for implementing this capability is by using a Universal Discovery Description and Integration (UDDI) registry and the UDDI Invocation Pattern where a client attempts to communicate with an endpoint and, upon failure, queries a well-known UDDI registry for the current endpoint metadata.</span></span> <span data-ttu-id="5ce3d-226">Il client utilizza quindi l'indirizzo e l'associazione da questi metadati per comunicare con l'endpoint.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-226">The client then uses the address and binding from this metadata to communicate with the endpoint.</span></span> <span data-ttu-id="5ce3d-227">Se la comunicazione riesce, il client memorizza nella cache le informazioni sull'indirizzo e sull'associazione per utilizzarle in seguito.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-227">If this communication succeeds, the client caches the address and binding information for future use.</span></span>  
  
## <a name="routing-service-and-versioning"></a><span data-ttu-id="5ce3d-228">Servizio di routing e controllo delle versioni</span><span class="sxs-lookup"><span data-stu-id="5ce3d-228">Routing Service and Versioning</span></span>  
 <span data-ttu-id="5ce3d-229">Se le modifiche apportate a un servizio sono in grado di determinare interruzioni e sono necessarie due o più versioni diverse di un servizio in esecuzione contemporanea, è possibile utilizzare il servizio di routing WCF per indirizzare messaggi all'istanza del servizio appropriata.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-229">If the changes made to a service are breaking changes and you need to have two or more different versions of a service running simultaneously you can use the WCF Routing Service to route messages to the appropriate service instance.</span></span> <span data-ttu-id="5ce3d-230">Il servizio di routing WCF utilizza il routing basato sul contenuto, ovvero informazioni contenute nel messaggio, per determinare l'indirizzamento del messaggio stesso.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-230">The WCF Routing Service uses content-based routing, in other words, it uses information within the message to determine where to route the message.</span></span> <span data-ttu-id="5ce3d-231">Per ulteriori informazioni sul servizio di routing WCF, vedere [Servizio di routing](./feature-details/routing-service.md).</span><span class="sxs-lookup"><span data-stu-id="5ce3d-231">For more information about the WCF Routing Service see [Routing Service](./feature-details/routing-service.md).</span></span> <span data-ttu-id="5ce3d-232">Per un esempio di come utilizzare il servizio di routing WCF per il controllo delle versioni del servizio, vedere [procedura: controllo delle versioni del servizio](./feature-details/how-to-service-versioning.md).</span><span class="sxs-lookup"><span data-stu-id="5ce3d-232">For an example of how to use the WCF Routing Service for service versioning see [How To: Service Versioning](./feature-details/how-to-service-versioning.md).</span></span>  
  
## <a name="appendix"></a><span data-ttu-id="5ce3d-233">Appendice</span><span class="sxs-lookup"><span data-stu-id="5ce3d-233">Appendix</span></span>  
 <span data-ttu-id="5ce3d-234">Quando è richiesto un controllo rigoroso delle versioni dei contratti dati, trattare questi ultimi come immutabili e creare nuovi contratti dati quando è necessario apportare modifiche.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-234">The general data contract versioning guidance when strict versioning is needed is to treat data contracts as immutable and create new ones when changes are required.</span></span> <span data-ttu-id="5ce3d-235">È necessario creare una nuova classe per ogni nuovo contratto dati, pertanto è richiesto un meccanismo che eviti di prendere il codice esistente scritto secondo la vecchia classe del contratto dati e riscriverli secondo quella nuova del contratto dati.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-235">A new class needs to be created for each new data contract, so a mechanism is needed to avoid having to take existing code that was written in terms of the old data contract class and rewrite it in terms of the new data contract class.</span></span>  
  
 <span data-ttu-id="5ce3d-236">Questo meccanismo consiste nell'utilizzare le interfacce per definire i membri di ogni contratto dati e scrivere il codice di implementazione interno in termini di interfacce piuttosto che classi del contratto dati che implementano le interfacce.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-236">One such mechanism is to use interfaces to define the members of each data contract and write internal implementation code in terms of the interfaces rather than the data contract classes that implement the interfaces.</span></span> <span data-ttu-id="5ce3d-237">Nel codice seguente per la versione 1 di un servizio vengono illustrati un'interfaccia `IPurchaseOrderV1` e un oggetto `PurchaseOrderV1`:</span><span class="sxs-lookup"><span data-stu-id="5ce3d-237">The following code for version 1 of a service shows an `IPurchaseOrderV1` interface and a `PurchaseOrderV1`:</span></span>  
  
```csharp  
public interface IPurchaseOrderV1  
{  
    string OrderId { get; set; }  
    string CustomerId { get; set; }  
}  
  
[DataContract(  
Name = "PurchaseOrder",  
Namespace = "http://examples.microsoft.com/WCF/2005/10/PurchaseOrder")]  
public class PurchaseOrderV1 : IPurchaseOrderV1  
{  
    [DataMember(...)]  
    public string OrderId {...}  
    [DataMember(...)]  
    public string CustomerId {...}  
}  
```  
  
 <span data-ttu-id="5ce3d-238">Mentre le operazioni del contratto di servizio verrebbero scritte come `PurchaseOrderV1`, la logica di business effettiva sarebbe `IPurchaseOrderV1`.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-238">While the service contract’s operations would be written in terms of `PurchaseOrderV1`, the actual business logic would be in terms of `IPurchaseOrderV1`.</span></span> <span data-ttu-id="5ce3d-239">Quindi, nella versione 2, ci sarebbero una nuova interfaccia `IPurchaseOrderV2` e una nuova classe `PurchaseOrderV2`, come illustrato nel codice seguente:</span><span class="sxs-lookup"><span data-stu-id="5ce3d-239">Then, in version 2, there would be a new `IPurchaseOrderV2` interface and a new `PurchaseOrderV2` class as shown in the following code:</span></span>  
  
```csharp
public interface IPurchaseOrderV2  
{  
    DateTime OrderDate { get; set; }  
}

[DataContract(
Name = "PurchaseOrder",  
Namespace = "http://examples.microsoft.com/WCF/2006/02/PurchaseOrder")]  
public class PurchaseOrderV2 : IPurchaseOrderV1, IPurchaseOrderV2  
{  
    [DataMember(...)]  
    public string OrderId {...}  
    [DataMember(...)]  
    public string CustomerId {...}  
    [DataMember(...)]  
    public DateTime OrderDate { ... }  
}  
```  
  
 <span data-ttu-id="5ce3d-240">Il contratto di servizio verrebbe aggiornato per includere le nuove operazioni che sono scritte come `PurchaseOrderV2`.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-240">The service contract would be updated to include new operations that are written in terms of `PurchaseOrderV2`.</span></span> <span data-ttu-id="5ce3d-241">La logica di business esistente scritta in termini di `IPurchaseOrderV1` continuerebbe a funzionare per `PurchaseOrderV2` e la nuova logica di business che richiede la proprietà `OrderDate` verrebbe scritta come `IPurchaseOrderV2`.</span><span class="sxs-lookup"><span data-stu-id="5ce3d-241">Existing business logic written in terms of `IPurchaseOrderV1` would continue to work for `PurchaseOrderV2` and new business logic that needs the `OrderDate` property would be written in terms of `IPurchaseOrderV2`.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="5ce3d-242">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="5ce3d-242">See also</span></span>

- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Runtime.Serialization.DataContractAttribute>
- <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A>
- <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A>
- <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A>
- <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A>
- <xref:System.Runtime.Serialization.IExtensibleDataObject>
- <xref:System.Runtime.Serialization.ExtensionDataObject>
- <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A>
- <xref:System.Xml.Serialization.XmlSerializer>
- [<span data-ttu-id="5ce3d-243">Data Contract Equivalence</span><span class="sxs-lookup"><span data-stu-id="5ce3d-243">Data Contract Equivalence</span></span>](./feature-details/data-contract-equivalence.md)
- [<span data-ttu-id="5ce3d-244">Callback di serializzazione a tolleranza di versione</span><span class="sxs-lookup"><span data-stu-id="5ce3d-244">Version-Tolerant Serialization Callbacks</span></span>](./feature-details/version-tolerant-serialization-callbacks.md)
