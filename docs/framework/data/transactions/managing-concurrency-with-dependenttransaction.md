---
title: Gestione della concorrenza con DependentTransaction
ms.date: 03/30/2017
ms.assetid: b85a97d8-8e02-4555-95df-34c8af095148
ms.openlocfilehash: a8ddcab4b065c3400f9f9f7ec9ce04befdd0f29b
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 03/12/2020
ms.locfileid: "79174381"
---
# <a name="managing-concurrency-with-dependenttransaction"></a><span data-ttu-id="b2ca9-102">Gestione della concorrenza con DependentTransaction</span><span class="sxs-lookup"><span data-stu-id="b2ca9-102">Managing Concurrency with DependentTransaction</span></span>
<span data-ttu-id="b2ca9-103">Il metodo <xref:System.Transactions.Transaction> consente di clonare un oggetto <xref:System.Transactions.Transaction.DependentClone%2A>.</span><span class="sxs-lookup"><span data-stu-id="b2ca9-103">The <xref:System.Transactions.Transaction> object is created using the <xref:System.Transactions.Transaction.DependentClone%2A> method.</span></span> <span data-ttu-id="b2ca9-104">L'unico scopo di questo metodo è impedire il commit della transazione mentre altri blocchi di codice (ad esempio un thread di lavoro) stanno agendo su di essa.</span><span class="sxs-lookup"><span data-stu-id="b2ca9-104">Its sole purpose is to guarantee that the transaction cannot commit while some other pieces of code (for example, a worker thread) are still performing work on the transaction.</span></span> <span data-ttu-id="b2ca9-105">Quando le operazioni eseguite all'interno della transazione clonata sono state completate e il sistema è pronto ad eseguirne il commit, la transazione clonata può utilizzare il metodo <xref:System.Transactions.DependentTransaction.Complete%2A> per informare il creatore della transazione originale in merito.</span><span class="sxs-lookup"><span data-stu-id="b2ca9-105">When the work done within the cloned transaction is complete and ready to be committed, it can notify the creator of the transaction using the <xref:System.Transactions.DependentTransaction.Complete%2A> method.</span></span> <span data-ttu-id="b2ca9-106">In questo modo è possibile preservare la coerenza e la correttezza dei dati.</span><span class="sxs-lookup"><span data-stu-id="b2ca9-106">Thus, you can preserve the consistency and correctness of data.</span></span>  
  
 <span data-ttu-id="b2ca9-107">La classe <xref:System.Transactions.DependentTransaction> può inoltre essere utilizzata per gestire la concorrenza tra attività asincrone.</span><span class="sxs-lookup"><span data-stu-id="b2ca9-107">The <xref:System.Transactions.DependentTransaction> class can also be used to manage concurrency between asynchronous tasks.</span></span> <span data-ttu-id="b2ca9-108">In questo scenario, la transazione padre può continuare a eseguire qualsiasi codice mentre la transazione duplicata dipendente agisce sulle proprie attività.</span><span class="sxs-lookup"><span data-stu-id="b2ca9-108">In this scenario, the parent can continue to execute any code while the dependent clone works on its own tasks.</span></span> <span data-ttu-id="b2ca9-109">In altre parole, l'esecuzione della transazione padre può procedere liberamente anche durante l'esecuzione della transazione dipendente.</span><span class="sxs-lookup"><span data-stu-id="b2ca9-109">In other words, the parent's execution is not blocked until the dependent completes.</span></span>  
  
## <a name="creating-a-dependent-clone"></a><span data-ttu-id="b2ca9-110">Creazione di un clone dipendente</span><span class="sxs-lookup"><span data-stu-id="b2ca9-110">Creating a Dependent Clone</span></span>  
 <span data-ttu-id="b2ca9-111">Per creare una transazione dipendente, chiamare il metodo <xref:System.Transactions.Transaction.DependentClone%2A> e passare l'enumerazione <xref:System.Transactions.DependentCloneOption> come parametro.</span><span class="sxs-lookup"><span data-stu-id="b2ca9-111">To create a dependent transaction, call the <xref:System.Transactions.Transaction.DependentClone%2A> method and pass the <xref:System.Transactions.DependentCloneOption> enumeration as a parameter.</span></span> <span data-ttu-id="b2ca9-112">Questo parametro definisce il comportamento della transazione nel caso in cui il metodo `Commit` venga chiamato nella transazione padre prima che il clone dipendente chiami il metodo <xref:System.Transactions.DependentTransaction.Complete%2A> per indicare che è pronto per il commit.</span><span class="sxs-lookup"><span data-stu-id="b2ca9-112">This parameter defines the behavior of the transaction if `Commit` is called on the parent transaction before the dependent clone indicates that it is ready for the transaction to commit (by calling the <xref:System.Transactions.DependentTransaction.Complete%2A> method).</span></span> <span data-ttu-id="b2ca9-113">Di seguito sono elencati i valori validi di questo parametro e le relative descrizioni.</span><span class="sxs-lookup"><span data-stu-id="b2ca9-113">The following values are valid for this parameter:</span></span>  
  
- <span data-ttu-id="b2ca9-114">Il valore <xref:System.Transactions.DependentCloneOption.BlockCommitUntilComplete> consente di creare una transazione dipendente che blocca il processo di commit della transazione padre finché non scade il timeout di quest'ultima o finché il metodo <xref:System.Transactions.DependentTransaction.Complete%2A> non viene chiamato in tutte le transazioni dipendenti a indicarne il completamento.</span><span class="sxs-lookup"><span data-stu-id="b2ca9-114"><xref:System.Transactions.DependentCloneOption.BlockCommitUntilComplete> creates a dependent transaction that blocks the commit process of the parent transaction until the parent transaction times out, or until <xref:System.Transactions.DependentTransaction.Complete%2A> is called on all dependents indicating their completion.</span></span> <span data-ttu-id="b2ca9-115">Ciò è utile quando il client desidera che la transazione padre esegua il commit solo dopo il completamento delle transazioni dipendenti.</span><span class="sxs-lookup"><span data-stu-id="b2ca9-115">This is useful when the client does not want the parent transaction to commit until the dependent transactions have completed.</span></span> <span data-ttu-id="b2ca9-116">Se la transazione padre termina la propria esecuzione prima delle transazioni dipendenti e chiama il metodo <xref:System.Transactions.CommittableTransaction.Commit%2A> sulla transazione, il processo di commit viene bloccato in un stato che consente l'esecuzione di operazioni aggiuntive relative alla transazione e la creazione di nuove integrazioni finché tutte le transazioni dipendenti non chiamano il metodo <xref:System.Transactions.DependentTransaction.Complete%2A>.</span><span class="sxs-lookup"><span data-stu-id="b2ca9-116">If the parent finishes its work earlier than the dependent transaction and calls <xref:System.Transactions.CommittableTransaction.Commit%2A> on the transaction, the commit process is blocked in a state where additional work can be done on the transaction and new enlistments can be created, until all of the dependents call <xref:System.Transactions.DependentTransaction.Complete%2A>.</span></span> <span data-ttu-id="b2ca9-117">Il processo di commit della transazione inizia non appena tutte le transazioni dipendenti terminano la propria esecuzione e chiamano il metodo <xref:System.Transactions.DependentTransaction.Complete%2A>.</span><span class="sxs-lookup"><span data-stu-id="b2ca9-117">As soon as all of them have finished their work and call <xref:System.Transactions.DependentTransaction.Complete%2A>, the commit process for the transaction begins.</span></span>  
  
- <span data-ttu-id="b2ca9-118">Il valore <xref:System.Transactions.DependentCloneOption.RollbackIfNotComplete>, invece, crea una transazione dipendente che viene interrotta automaticamente se il metodo <xref:System.Transactions.CommittableTransaction.Commit%2A> viene chiamato sulla transazione padre prima che il metodo <xref:System.Transactions.DependentTransaction.Complete%2A> venga chiamato sulla transazione dipendente.</span><span class="sxs-lookup"><span data-stu-id="b2ca9-118"><xref:System.Transactions.DependentCloneOption.RollbackIfNotComplete>, on the other hand, creates a dependent transaction that automatically aborts if <xref:System.Transactions.CommittableTransaction.Commit%2A> is called on the parent transaction before <xref:System.Transactions.DependentTransaction.Complete%2A> is called.</span></span> <span data-ttu-id="b2ca9-119">In questo caso, il sistema esegue il rollback di qualsiasi operazione svolta nella transazione dipendente nell'intervallo di durata di un'unica transazione e nessuna entità ha la possibilità di eseguire il commit parziale della transazione dipendente.</span><span class="sxs-lookup"><span data-stu-id="b2ca9-119">In this case, all the work done in the dependent transaction is intact within one transaction lifetime, and no one has a chance to commit just a portion of it.</span></span>  
  
 <span data-ttu-id="b2ca9-120">Quando l'applicazione termina le proprie operazioni relative alla transazione dipendente, è necessario chiamare il metodo <xref:System.Transactions.DependentTransaction.Complete%2A> una sola volta. In caso contrario, viene generata un'eccezione <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="b2ca9-120">The <xref:System.Transactions.DependentTransaction.Complete%2A> method must be called only once when your application finishes its work on the dependent transaction; otherwise, a <xref:System.InvalidOperationException> is thrown.</span></span> <span data-ttu-id="b2ca9-121">Dopo l'esecuzione di questa chiamata, evitare l'esecuzione di altre operazioni sulla transazione o verrà generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="b2ca9-121">After this call is invoked, you must not attempt any additional work on the transaction, or an exception is thrown.</span></span>  
  
 <span data-ttu-id="b2ca9-122">Nell'esempio di codice seguente viene mostrato come creare una transazione dipendente per gestire due attività simultanee clonando una transazione dipendente e passandola a un thread di lavoro.</span><span class="sxs-lookup"><span data-stu-id="b2ca9-122">The following code example shows how to create a dependent transaction to manage two concurrent tasks by cloning a dependent transaction and passing it to a worker thread.</span></span>  
  
```csharp  
public class WorkerThread  
{  
    public void DoWork(DependentTransaction dependentTransaction)  
    {  
        Thread thread = new Thread(ThreadMethod);  
        thread.Start(dependentTransaction);
    }  
  
    public void ThreadMethod(object transaction)
    {
        DependentTransaction dependentTransaction = transaction as DependentTransaction;  
        Debug.Assert(dependentTransaction != null);
        try  
        {  
            using(TransactionScope ts = new TransactionScope(dependentTransaction))  
            {  
                /* Perform transactional work here */
                ts.Complete();  
            }  
        }  
        finally  
        {  
            dependentTransaction.Complete();
             dependentTransaction.Dispose();
        }  
    }  
  
//Client code
using(TransactionScope scope = new TransactionScope())  
{  
    Transaction currentTransaction = Transaction.Current;  
    DependentTransaction dependentTransaction;
    dependentTransaction = currentTransaction.DependentClone(DependentCloneOption.BlockCommitUntilComplete);  
    WorkerThread workerThread = new WorkerThread();  
    workerThread.DoWork(dependentTransaction);  
    /* Do some transactional work here, then: */  
    scope.Complete();  
}  
```  
  
 <span data-ttu-id="b2ca9-123">Il codice client crea un ambito transazionale che imposta anch'esso la transazione di ambiente.</span><span class="sxs-lookup"><span data-stu-id="b2ca9-123">The client code creates a transactional scope that also sets the ambient transaction.</span></span> <span data-ttu-id="b2ca9-124">Anziché passare la transazione di ambiente al thread di lavoro</span><span class="sxs-lookup"><span data-stu-id="b2ca9-124">You should not pass the ambient transaction to the worker thread.</span></span> <span data-ttu-id="b2ca9-125">è necessario clonare la transazione corrente (di ambiente) chiamando il metodo <xref:System.Transactions.Transaction.DependentClone%2A> nella transazione corrente e quindi passare la transazione dipendente al thread di lavoro.</span><span class="sxs-lookup"><span data-stu-id="b2ca9-125">Instead, you should clone the current (ambient) transaction by calling the <xref:System.Transactions.Transaction.DependentClone%2A> method on the current transaction, and pass the dependent to the worker thread.</span></span>  
  
 <span data-ttu-id="b2ca9-126">Il metodo `ThreadMethod` viene eseguito nel nuovo thread.</span><span class="sxs-lookup"><span data-stu-id="b2ca9-126">The `ThreadMethod` method executes on the new thread.</span></span> <span data-ttu-id="b2ca9-127">Il client avvia un nuovo thread, passando la transazione dipendente come parametro `ThreadMethod`.</span><span class="sxs-lookup"><span data-stu-id="b2ca9-127">The client starts a new thread, passing the dependent transaction as the `ThreadMethod` parameter.</span></span>  
  
 <span data-ttu-id="b2ca9-128">Poiché la transazione dipendente viene creata con il valore <xref:System.Transactions.DependentCloneOption.BlockCommitUntilComplete>, il commit della transazione può avvenire solo dopo il completamento di tutte le operazioni transazionali nel secondo thread e dopo che il metodo <xref:System.Transactions.DependentTransaction.Complete%2A> sia stato chiamato sulla transazione dipendente.</span><span class="sxs-lookup"><span data-stu-id="b2ca9-128">Because the dependent transaction is created with <xref:System.Transactions.DependentCloneOption.BlockCommitUntilComplete>, you are guaranteed that the transaction cannot be committed until all of the transactional work done on the second thread is finished and <xref:System.Transactions.DependentTransaction.Complete%2A> is called on the dependent transaction.</span></span> <span data-ttu-id="b2ca9-129">Ciò significa che se l'ambito del client termina (quando tenta di `using` eliminare l'oggetto <xref:System.Transactions.DependentTransaction.Complete%2A> transazione alla fine dell'istruzione) prima che il nuovo thread chiami la transazione dipendente, il codice client si blocca fino a quando viene <xref:System.Transactions.DependentTransaction.Complete%2A> chiamato sul dipendente.</span><span class="sxs-lookup"><span data-stu-id="b2ca9-129">This means that if the client's scope ends (when it tries to dispose of the transaction object at the end of the `using` statement) before the new thread calls <xref:System.Transactions.DependentTransaction.Complete%2A> on the dependent transaction, the client code blocks until <xref:System.Transactions.DependentTransaction.Complete%2A> is called on the dependent.</span></span> <span data-ttu-id="b2ca9-130">A questo punto, la transazione può concludere la procedura di commit o di interruzione.</span><span class="sxs-lookup"><span data-stu-id="b2ca9-130">Then the transaction can finish committing or aborting.</span></span>  
  
## <a name="concurrency-issues"></a><span data-ttu-id="b2ca9-131">Problemi di concorrenza</span><span class="sxs-lookup"><span data-stu-id="b2ca9-131">Concurrency Issues</span></span>  
 <span data-ttu-id="b2ca9-132">Quando si utilizza la classe <xref:System.Transactions.DependentTransaction> occorre prendere in considerazione alcuni problemi di concorrenza aggiuntivi:</span><span class="sxs-lookup"><span data-stu-id="b2ca9-132">There are a few additional concurrency issues that you need to be aware of when using the <xref:System.Transactions.DependentTransaction> class:</span></span>  
  
- <span data-ttu-id="b2ca9-133">Se il thread di lavoro esegue il rollback della transazione ma la transazione padre tenta di eseguirne il commit, viene generata un'eccezione <xref:System.Transactions.TransactionAbortedException>.</span><span class="sxs-lookup"><span data-stu-id="b2ca9-133">If the worker thread rolls back the transaction but the parent tries to commit it, a <xref:System.Transactions.TransactionAbortedException> is thrown.</span></span>  
  
- <span data-ttu-id="b2ca9-134">È necessario creare un nuovo clone dipendente per ogni thread di lavoro della transazione.</span><span class="sxs-lookup"><span data-stu-id="b2ca9-134">You should create a new dependent clone for each worker thread in the transaction.</span></span> <span data-ttu-id="b2ca9-135">Evitare di passare lo stesso clone dipendente a più thread, in quando solo uno di essi è in grado di chiamare il metodo <xref:System.Transactions.DependentTransaction.Complete%2A> sul clone.</span><span class="sxs-lookup"><span data-stu-id="b2ca9-135">Do not pass the same dependent clone to multiple threads, because only one of them can call <xref:System.Transactions.DependentTransaction.Complete%2A> on it.</span></span>  
  
- <span data-ttu-id="b2ca9-136">Se il thread di lavoro genera un nuovo thread di lavoro, assicurarsi di creare un clone dipendente a partire dal clone dipendente e di passarlo al nuovo thread.</span><span class="sxs-lookup"><span data-stu-id="b2ca9-136">If the worker thread spawns a new worker thread, make sure to create a dependent clone from the dependent clone and pass it to the new thread.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="b2ca9-137">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="b2ca9-137">See also</span></span>

- <xref:System.Transactions.DependentTransaction>
