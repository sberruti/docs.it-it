---
title: Metodo ICorProfilerInfo2::DoStackSnapshot
ms.date: 03/30/2017
api_name:
- ICorProfilerInfo2.DoStackSnapshot
api_location:
- mscorwks.dll
api_type:
- COM
f1_keywords:
- ICorProfilerInfo2::DoStackSnapshot
helpviewer_keywords:
- ICorProfilerInfo2::DoStackSnapshot method [.NET Framework profiling]
- DoStackSnapshot method [.NET Framework profiling]
ms.assetid: 287b11e9-7c52-4a13-ba97-751203fa97f4
topic_type:
- apiref
ms.openlocfilehash: 5d90f414a945d346ca7721745ea7d86cb24a085c
ms.sourcegitcommit: 7e2128d4a4c45b4274bea3b8e5760d4694569ca1
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 01/14/2020
ms.locfileid: "75936860"
---
# <a name="icorprofilerinfo2dostacksnapshot-method"></a><span data-ttu-id="f5bff-102">Metodo ICorProfilerInfo2::DoStackSnapshot</span><span class="sxs-lookup"><span data-stu-id="f5bff-102">ICorProfilerInfo2::DoStackSnapshot Method</span></span>
<span data-ttu-id="f5bff-103">Esamina i frame gestiti nello stack per il thread specificato e invia le informazioni al profiler tramite un callback.</span><span class="sxs-lookup"><span data-stu-id="f5bff-103">Walks the managed frames on the stack for the specified thread, and sends information to the profiler through a callback.</span></span>  
  
## <a name="syntax"></a><span data-ttu-id="f5bff-104">Sintassi</span><span class="sxs-lookup"><span data-stu-id="f5bff-104">Syntax</span></span>  
  
```cpp  
HRESULT DoStackSnapshot(  
    [in] ThreadID thread,  
    [in] StackSnapshotCallback *callback,  
    [in] ULONG32 infoFlags,  
    [in] void *clientData,  
    [in, size_is(contextSize), length_is(contextSize)] BYTE context[],  
    [in] ULONG32 contextSize);  
```  
  
## <a name="parameters"></a><span data-ttu-id="f5bff-105">Parametri</span><span class="sxs-lookup"><span data-stu-id="f5bff-105">Parameters</span></span>  
 `thread`  
 <span data-ttu-id="f5bff-106">in ID del thread di destinazione.</span><span class="sxs-lookup"><span data-stu-id="f5bff-106">[in] The ID of the target thread.</span></span>  
  
 <span data-ttu-id="f5bff-107">Il passaggio di un valore null in `thread` restituisce uno snapshot del thread corrente.</span><span class="sxs-lookup"><span data-stu-id="f5bff-107">Passing null in `thread` yields a snapshot of the current thread.</span></span> <span data-ttu-id="f5bff-108">Se viene passato un `ThreadID` di un thread diverso, il Common Language Runtime (CLR) sospende il thread, esegue lo snapshot e riprende.</span><span class="sxs-lookup"><span data-stu-id="f5bff-108">If a `ThreadID` of a different thread is passed, the common language runtime (CLR) suspends that thread, performs the snapshot, and resumes.</span></span>  
  
 `callback`  
 <span data-ttu-id="f5bff-109">in Puntatore all'implementazione del metodo [StackSnapshotCallback](../../../../docs/framework/unmanaged-api/profiling/stacksnapshotcallback-function.md) , che viene chiamato da CLR per fornire al profiler informazioni su ogni frame gestito e ogni esecuzione di frame non gestiti.</span><span class="sxs-lookup"><span data-stu-id="f5bff-109">[in] A pointer to the implementation of the [StackSnapshotCallback](../../../../docs/framework/unmanaged-api/profiling/stacksnapshotcallback-function.md) method, which is called by the CLR to provide the profiler with information on each managed frame and each run of unmanaged frames.</span></span>  
  
 <span data-ttu-id="f5bff-110">Il `StackSnapshotCallback` metodo viene implementato dal writer del profiler.</span><span class="sxs-lookup"><span data-stu-id="f5bff-110">The `StackSnapshotCallback` method is implemented by the profiler writer.</span></span>  
  
 `infoFlags`  
 <span data-ttu-id="f5bff-111">in Valore dell'enumerazione [COR_PRF_SNAPSHOT_INFO](../../../../docs/framework/unmanaged-api/profiling/cor-prf-snapshot-info-enumeration.md) , che specifica la quantità di dati da restituire per ogni frame da `StackSnapshotCallback`.</span><span class="sxs-lookup"><span data-stu-id="f5bff-111">[in] A value of the [COR_PRF_SNAPSHOT_INFO](../../../../docs/framework/unmanaged-api/profiling/cor-prf-snapshot-info-enumeration.md) enumeration, which specifies the amount of data to be passed back for each frame by `StackSnapshotCallback`.</span></span>  
  
 `clientData`  
 <span data-ttu-id="f5bff-112">in Puntatore ai dati client, che viene passato direttamente alla funzione di callback `StackSnapshotCallback`.</span><span class="sxs-lookup"><span data-stu-id="f5bff-112">[in] A pointer to the client data, which is passed straight through to the `StackSnapshotCallback` callback function.</span></span>  
  
 `context`  
 <span data-ttu-id="f5bff-113">in Puntatore a una struttura `CONTEXT` Win32 utilizzata per il seeding del percorso dello stack.</span><span class="sxs-lookup"><span data-stu-id="f5bff-113">[in] A pointer to a Win32 `CONTEXT` structure, which is used to seed the stack walk.</span></span> <span data-ttu-id="f5bff-114">La struttura di `CONTEXT` Win32 contiene i valori dei registri della CPU e rappresenta lo stato della CPU in un determinato momento.</span><span class="sxs-lookup"><span data-stu-id="f5bff-114">The Win32 `CONTEXT` structure contains values of the CPU registers and represents the state of the CPU at a particular moment in time.</span></span>  
  
 <span data-ttu-id="f5bff-115">Il valore di inizializzazione consente a CLR di determinare dove iniziare il percorso dello stack, se la parte superiore dello stack è codice di supporto non gestito; in caso contrario, il valore di inizializzazione viene ignorato.</span><span class="sxs-lookup"><span data-stu-id="f5bff-115">The seed helps the CLR determine where to begin the stack walk, if the top of the stack is unmanaged helper code; otherwise, the seed is ignored.</span></span> <span data-ttu-id="f5bff-116">È necessario specificare un valore di inizializzazione per un percorso asincrono.</span><span class="sxs-lookup"><span data-stu-id="f5bff-116">A seed must be supplied for an asynchronous walk.</span></span> <span data-ttu-id="f5bff-117">Se si sta eseguendo un percorso sincrono, non è necessario alcun valore di inizializzazione.</span><span class="sxs-lookup"><span data-stu-id="f5bff-117">If you are doing a synchronous walk, no seed is necessary.</span></span>  
  
 <span data-ttu-id="f5bff-118">Il parametro `context` è valido solo se il flag COR_PRF_SNAPSHOT_CONTEXT è stato passato nel parametro `infoFlags`.</span><span class="sxs-lookup"><span data-stu-id="f5bff-118">The `context` parameter is valid only if the COR_PRF_SNAPSHOT_CONTEXT flag was passed in the `infoFlags` parameter.</span></span>  
  
 `contextSize`  
 <span data-ttu-id="f5bff-119">in Dimensioni della struttura di `CONTEXT`, a cui fa riferimento il parametro di `context`.</span><span class="sxs-lookup"><span data-stu-id="f5bff-119">[in] The size of the `CONTEXT` structure, which is referenced by the `context` parameter.</span></span>  
  
## <a name="remarks"></a><span data-ttu-id="f5bff-120">Note</span><span class="sxs-lookup"><span data-stu-id="f5bff-120">Remarks</span></span>  
 <span data-ttu-id="f5bff-121">Il passaggio di null per `thread` restituisce uno snapshot del thread corrente.</span><span class="sxs-lookup"><span data-stu-id="f5bff-121">Passing null for `thread` yields a snapshot of the current thread.</span></span> <span data-ttu-id="f5bff-122">Gli snapshot possono essere presi da altri thread solo se il thread di destinazione è sospeso al momento.</span><span class="sxs-lookup"><span data-stu-id="f5bff-122">Snapshots can be taken of other threads only if the target thread is suspended at the time.</span></span>  
  
 <span data-ttu-id="f5bff-123">Quando il profiler vuole esaminare lo stack, chiama `DoStackSnapshot`.</span><span class="sxs-lookup"><span data-stu-id="f5bff-123">When the profiler wants to walk the stack, it calls `DoStackSnapshot`.</span></span> <span data-ttu-id="f5bff-124">Prima che CLR torni da tale chiamata, chiama il `StackSnapshotCallback` più volte, una volta per ogni frame gestito (o per l'esecuzione di frame non gestiti) nello stack.</span><span class="sxs-lookup"><span data-stu-id="f5bff-124">Before the CLR returns from that call, it calls your `StackSnapshotCallback` several times, once for each managed frame (or run of unmanaged frames) on the stack.</span></span> <span data-ttu-id="f5bff-125">Quando vengono rilevati frame non gestiti, è necessario eseguirli manualmente.</span><span class="sxs-lookup"><span data-stu-id="f5bff-125">When unmanaged frames are encountered, you must walk them yourself.</span></span>  
  
 <span data-ttu-id="f5bff-126">L'ordine in cui viene camminato lo stack è il contrario rispetto alla modalità di push dei frame nello stack: primo fotogramma (ultimo push), principale (primo push).</span><span class="sxs-lookup"><span data-stu-id="f5bff-126">The order in which the stack is walked is the reverse of how the frames were pushed onto the stack: leaf (last-pushed) frame first, main (first-pushed) frame last.</span></span>  
  
 <span data-ttu-id="f5bff-127">Per altre informazioni su come programmare il profiler per l'analisi degli stack gestiti, vedere [analisi dello stack del profiler nella .NET Framework 2,0: Nozioni di base e oltre](https://docs.microsoft.com/previous-versions/dotnet/articles/bb264782(v=msdn.10)).</span><span class="sxs-lookup"><span data-stu-id="f5bff-127">For more information about how to program the profiler to walk managed stacks, see [Profiler Stack Walking in the .NET Framework 2.0: Basics and Beyond](https://docs.microsoft.com/previous-versions/dotnet/articles/bb264782(v=msdn.10)).</span></span>  
  
 <span data-ttu-id="f5bff-128">Un percorso stack può essere sincrono o asincrono, come illustrato nelle sezioni seguenti.</span><span class="sxs-lookup"><span data-stu-id="f5bff-128">A stack walk can be synchronous or asynchronous, as explained in the following sections.</span></span>  
  
## <a name="synchronous-stack-walk"></a><span data-ttu-id="f5bff-129">Percorso stack sincrono</span><span class="sxs-lookup"><span data-stu-id="f5bff-129">Synchronous Stack Walk</span></span>  
 <span data-ttu-id="f5bff-130">Un percorso stack sincrono prevede l'analisi dello stack del thread corrente in risposta a un callback.</span><span class="sxs-lookup"><span data-stu-id="f5bff-130">A synchronous stack walk involves walking the stack of the current thread in response to a callback.</span></span> <span data-ttu-id="f5bff-131">Non richiede il seeding o la sospensione.</span><span class="sxs-lookup"><span data-stu-id="f5bff-131">It does not require seeding or suspending.</span></span>  
  
 <span data-ttu-id="f5bff-132">Si esegue una chiamata sincrona quando, in risposta a CLR che chiama uno dei metodi [ICorProfilerCallback](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md) (o [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md)) del profiler, si chiama `DoStackSnapshot` per scorrere lo stack del thread corrente.</span><span class="sxs-lookup"><span data-stu-id="f5bff-132">You make a synchronous call when, in response to the CLR calling one of your profiler's [ICorProfilerCallback](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-interface.md) (or [ICorProfilerCallback2](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback2-interface.md)) methods, you call `DoStackSnapshot` to walk the stack of the current thread.</span></span> <span data-ttu-id="f5bff-133">Questa operazione è utile quando si desidera visualizzare l'aspetto dello stack in una notifica, ad esempio [ICorProfilerCallback:: ObjectAllocated](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-objectallocated-method.md).</span><span class="sxs-lookup"><span data-stu-id="f5bff-133">This is useful when you want to see what the stack looks like at a notification such as [ICorProfilerCallback::ObjectAllocated](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-objectallocated-method.md).</span></span> <span data-ttu-id="f5bff-134">È sufficiente chiamare `DoStackSnapshot` dall'interno del metodo `ICorProfilerCallback`, passando null nei parametri `context` e `thread`.</span><span class="sxs-lookup"><span data-stu-id="f5bff-134">You just call `DoStackSnapshot` from within your `ICorProfilerCallback` method, passing null in the `context` and `thread` parameters.</span></span>  
  
## <a name="asynchronous-stack-walk"></a><span data-ttu-id="f5bff-135">Percorso stack asincrono</span><span class="sxs-lookup"><span data-stu-id="f5bff-135">Asynchronous Stack Walk</span></span>  
 <span data-ttu-id="f5bff-136">Un percorso stack asincrono comporta l'analisi dello stack di un thread diverso o l'analisi dello stack del thread corrente, non in risposta a un callback, ma il hijack del puntatore all'istruzione del thread corrente.</span><span class="sxs-lookup"><span data-stu-id="f5bff-136">An asynchronous stack walk entails walking the stack of a different thread, or walking the stack of the current thread, not in response to a callback, but by hijacking the current thread's instruction pointer.</span></span> <span data-ttu-id="f5bff-137">Un percorso asincrono richiede un valore di inizializzazione se il primo dello stack è codice non gestito che non fa parte di una chiamata a platform invoke (PInvoke) o COM, ma codice di supporto in CLR stesso.</span><span class="sxs-lookup"><span data-stu-id="f5bff-137">An asynchronous walk requires a seed if the top of the stack is unmanaged code that is not part of a platform invoke (PInvoke) or COM call, but helper code in the CLR itself.</span></span> <span data-ttu-id="f5bff-138">Ad esempio, il codice che esegue la compilazione JIT (just-in-Time) o Garbage Collection è codice helper.</span><span class="sxs-lookup"><span data-stu-id="f5bff-138">For example, code that does just-in-time (JIT) compiling or garbage collection is helper code.</span></span>  
  
 <span data-ttu-id="f5bff-139">Si ottiene un valore di inizializzazione sospendendo direttamente il thread di destinazione e spostando il relativo stack fino a trovare il frame gestito in primo piano.</span><span class="sxs-lookup"><span data-stu-id="f5bff-139">You obtain a seed by directly suspending the target thread and walking its stack yourself, until you find the topmost managed frame.</span></span> <span data-ttu-id="f5bff-140">Dopo la sospensione del thread di destinazione, ottenere il contesto di registro corrente del thread di destinazione.</span><span class="sxs-lookup"><span data-stu-id="f5bff-140">After the target thread is suspended, get the target thread's current register context.</span></span> <span data-ttu-id="f5bff-141">Determinare quindi se il contesto del registro punta a codice non gestito chiamando [ICorProfilerInfo:: GetFunctionFromIP](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-getfunctionfromip-method.md) , se restituisce un `FunctionID` uguale a zero, il frame è codice non gestito.</span><span class="sxs-lookup"><span data-stu-id="f5bff-141">Next, determine whether the register context points to unmanaged code by calling [ICorProfilerInfo::GetFunctionFromIP](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-getfunctionfromip-method.md) — if it returns a `FunctionID` equal to zero, the frame is unmanaged code.</span></span> <span data-ttu-id="f5bff-142">A questo punto, scorrere lo stack fino a raggiungere il primo frame gestito, quindi calcolare il contesto di inizializzazione in base al contesto di registro per il frame.</span><span class="sxs-lookup"><span data-stu-id="f5bff-142">Now, walk the stack until you reach the first managed frame, and then calculate the seed context based on the register context for that frame.</span></span>  
  
 <span data-ttu-id="f5bff-143">Chiamare `DoStackSnapshot` con il contesto di inizializzazione per avviare il percorso dello stack asincrono.</span><span class="sxs-lookup"><span data-stu-id="f5bff-143">Call `DoStackSnapshot` with your seed context to begin the asynchronous stack walk.</span></span> <span data-ttu-id="f5bff-144">Se non si specifica un valore di inizializzazione, `DoStackSnapshot` possibile ignorare i frame gestiti nella parte superiore dello stack e, di conseguenza, fornirà un percorso stack incompleto.</span><span class="sxs-lookup"><span data-stu-id="f5bff-144">If you do not supply a seed, `DoStackSnapshot` might skip managed frames at the top of the stack and, consequently, will give you an incomplete stack walk.</span></span> <span data-ttu-id="f5bff-145">Se si fornisce un valore di inizializzazione, deve puntare al codice generato con compilazione JIT o Native Image Generator (Ngen. exe); in caso contrario, `DoStackSnapshot` restituisce il codice di errore, CORPROF_E_STACKSNAPSHOT_UNMANAGED_CTX.</span><span class="sxs-lookup"><span data-stu-id="f5bff-145">If you do supply a seed, it must point to JIT-compiled or Native Image Generator (Ngen.exe)-generated code; otherwise, `DoStackSnapshot` returns the failure code, CORPROF_E_STACKSNAPSHOT_UNMANAGED_CTX.</span></span>  
  
 <span data-ttu-id="f5bff-146">I percorsi di stack asincroni possono causare facilmente deadlock o violazioni di accesso, a meno che non si seguano le seguenti linee guida:</span><span class="sxs-lookup"><span data-stu-id="f5bff-146">Asynchronous stack walks can easily cause deadlocks or access violations, unless you follow these guidelines:</span></span>  
  
- <span data-ttu-id="f5bff-147">Quando si sospendono direttamente i thread, tenere presente che solo un thread che non esegue mai codice gestito può sospendere un altro thread.</span><span class="sxs-lookup"><span data-stu-id="f5bff-147">When you directly suspend threads, remember that only a thread that has never run managed code can suspend another thread.</span></span>  
  
- <span data-ttu-id="f5bff-148">Blocca sempre nel callback [ICorProfilerCallback:: ThreadDestroyed](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-threaddestroyed-method.md) fino al completamento del percorso stack del thread.</span><span class="sxs-lookup"><span data-stu-id="f5bff-148">Always block in your [ICorProfilerCallback::ThreadDestroyed](../../../../docs/framework/unmanaged-api/profiling/icorprofilercallback-threaddestroyed-method.md) callback until that thread's stack walk is complete.</span></span>  
  
- <span data-ttu-id="f5bff-149">Non mantenere un blocco quando il profiler chiama una funzione CLR che può attivare un Garbage Collection.</span><span class="sxs-lookup"><span data-stu-id="f5bff-149">Do not hold a lock while your profiler calls into a CLR function that can trigger a garbage collection.</span></span> <span data-ttu-id="f5bff-150">Ovvero, non mantenere un blocco se il thread proprietario può effettuare una chiamata che attiva un Garbage Collection.</span><span class="sxs-lookup"><span data-stu-id="f5bff-150">That is, do not hold a lock if the owning thread might make a call that triggers a garbage collection.</span></span>  
  
 <span data-ttu-id="f5bff-151">Esiste anche il rischio che si verifichi un deadlock se si chiama `DoStackSnapshot` da un thread creato dal profiler per poter scorrere lo stack di un thread di destinazione separato.</span><span class="sxs-lookup"><span data-stu-id="f5bff-151">There is also a risk of deadlock if you call `DoStackSnapshot` from a thread that your profiler has created so that you can walk the stack of a separate target thread.</span></span> <span data-ttu-id="f5bff-152">La prima volta che il thread creato immette determinati metodi di `ICorProfilerInfo*` (incluso `DoStackSnapshot`), il CLR eseguirà l'inizializzazione specifica di CLR per thread su tale thread.</span><span class="sxs-lookup"><span data-stu-id="f5bff-152">The first time the thread you created enters certain `ICorProfilerInfo*` methods (including `DoStackSnapshot`), the CLR will perform per-thread, CLR-specific initialization on that thread.</span></span> <span data-ttu-id="f5bff-153">Se il profiler ha sospeso il thread di destinazione il cui stack si sta tentando di esaminare e se il thread di destinazione è proprietario di un blocco necessario per eseguire questa inizializzazione per thread, si verificherà un deadlock.</span><span class="sxs-lookup"><span data-stu-id="f5bff-153">If your profiler has suspended the target thread whose stack you are trying to walk, and if that target thread happened to own a lock necessary for performing this per-thread initialization, a deadlock will occur.</span></span> <span data-ttu-id="f5bff-154">Per evitare questo deadlock, effettuare una chiamata iniziale in `DoStackSnapshot` dal thread creato dal profiler per esaminare un thread di destinazione separato, ma non sospendere prima il thread di destinazione.</span><span class="sxs-lookup"><span data-stu-id="f5bff-154">To avoid this deadlock, make an initial call into `DoStackSnapshot` from your profiler-created thread to walk a separate target thread, but do not suspend the target thread first.</span></span> <span data-ttu-id="f5bff-155">Questa chiamata iniziale garantisce che l'inizializzazione per thread possa essere completata senza deadlock.</span><span class="sxs-lookup"><span data-stu-id="f5bff-155">This initial call ensures that the per-thread initialization can complete without deadlock.</span></span> <span data-ttu-id="f5bff-156">Se `DoStackSnapshot` ha esito positivo e segnala almeno un frame, dopo tale punto sarà sicuro per il thread creato dal profiler sospendere qualsiasi thread di destinazione e chiamare `DoStackSnapshot` per esaminare lo stack del thread di destinazione.</span><span class="sxs-lookup"><span data-stu-id="f5bff-156">If `DoStackSnapshot` succeeds and reports at least one frame, after that point, it will be safe for that profiler-created thread to suspend any target thread and call `DoStackSnapshot` to walk the stack of that target thread.</span></span>  
  
## <a name="requirements"></a><span data-ttu-id="f5bff-157">Requisiti di</span><span class="sxs-lookup"><span data-stu-id="f5bff-157">Requirements</span></span>  
 <span data-ttu-id="f5bff-158">**Piattaforme:** vedere [Requisiti di sistema di .NET Framework](../../../../docs/framework/get-started/system-requirements.md).</span><span class="sxs-lookup"><span data-stu-id="f5bff-158">**Platforms:** See [System Requirements](../../../../docs/framework/get-started/system-requirements.md).</span></span>  
  
 <span data-ttu-id="f5bff-159">**Intestazione:** CorProf.idl, CorProf.h</span><span class="sxs-lookup"><span data-stu-id="f5bff-159">**Header:** CorProf.idl, CorProf.h</span></span>  
  
 <span data-ttu-id="f5bff-160">**Libreria:** CorGuids.lib</span><span class="sxs-lookup"><span data-stu-id="f5bff-160">**Library:** CorGuids.lib</span></span>  
  
 <span data-ttu-id="f5bff-161">**Versioni .NET Framework:** [!INCLUDE[net_current_v20plus](../../../../includes/net-current-v20plus-md.md)]</span><span class="sxs-lookup"><span data-stu-id="f5bff-161">**.NET Framework Versions:** [!INCLUDE[net_current_v20plus](../../../../includes/net-current-v20plus-md.md)]</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="f5bff-162">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="f5bff-162">See also</span></span>

- [<span data-ttu-id="f5bff-163">Interfaccia ICorProfilerInfo</span><span class="sxs-lookup"><span data-stu-id="f5bff-163">ICorProfilerInfo Interface</span></span>](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo-interface.md)
- [<span data-ttu-id="f5bff-164">Interfaccia ICorProfilerInfo2</span><span class="sxs-lookup"><span data-stu-id="f5bff-164">ICorProfilerInfo2 Interface</span></span>](../../../../docs/framework/unmanaged-api/profiling/icorprofilerinfo2-interface.md)
