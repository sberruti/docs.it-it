---
title: Considerazioni sulla sicurezza e sui servizi remoti
ms.date: 03/30/2017
helpviewer_keywords:
- code security, remoting
- remoting, security
- security [.NET Framework], remoting
- secure coding, remoting
ms.assetid: 125d2ab8-55a4-4e5f-af36-a7d401a37ab0
ms.openlocfilehash: 7a56c9894da88382f40dcd475e89776a83a59322
ms.sourcegitcommit: 9c54866bcbdc49dbb981dd55be9bbd0443837aa2
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 02/14/2020
ms.locfileid: "77215775"
---
# <a name="security-and-remoting-considerations"></a><span data-ttu-id="3e0c1-102">Considerazioni sulla sicurezza e sui servizi remoti</span><span class="sxs-lookup"><span data-stu-id="3e0c1-102">Security and Remoting Considerations</span></span>
<span data-ttu-id="3e0c1-103">I servizi remoti consentono di impostare chiamate trasparenti tra domini applicazione, processi o computer.</span><span class="sxs-lookup"><span data-stu-id="3e0c1-103">Remoting allows you to set up transparent calling between application domains, processes, or computers.</span></span> <span data-ttu-id="3e0c1-104">Lo stack di sicurezza per l'accesso di codice, tuttavia, non può superare i limiti del processo o del computer (viene applicato tra domini applicazione dello stesso processo).</span><span class="sxs-lookup"><span data-stu-id="3e0c1-104">However, the code access security stack walk cannot cross process or machine boundaries (it does apply between application domains of the same process).</span></span>  
  
 <span data-ttu-id="3e0c1-105">Tutte le classi utilizzabili in remoto (derivate da una classe <xref:System.MarshalByRefObject>) devono assumersi la responsabilità della sicurezza.</span><span class="sxs-lookup"><span data-stu-id="3e0c1-105">Any class that is remotable (derived from a <xref:System.MarshalByRefObject> class) needs to take responsibility for security.</span></span> <span data-ttu-id="3e0c1-106">Il codice deve essere usato solo in ambienti chiusi in cui il codice chiamante può essere considerato attendibile in modo implicito oppure le chiamate remote devono essere progettate in modo da non esporre il codice protetto a immissioni esterne che potrebbero essere usate da utenti malintenzionati.</span><span class="sxs-lookup"><span data-stu-id="3e0c1-106">Either the code should be used only in closed environments where the calling code can be implicitly trusted, or remoting calls should be designed so that they do not subject protected code to outside entry that could be used maliciously.</span></span>  
  
 <span data-ttu-id="3e0c1-107">In genere, è consigliabile non esporre mai metodi, proprietà o eventi protetti da [LinkDemand](link-demands.md) dichiarativo e <xref:System.Security.Permissions.SecurityAction.InheritanceDemand> controlli di sicurezza.</span><span class="sxs-lookup"><span data-stu-id="3e0c1-107">Generally, you should never expose methods, properties, or events that are protected by declarative [LinkDemand](link-demands.md) and <xref:System.Security.Permissions.SecurityAction.InheritanceDemand> security checks.</span></span> <span data-ttu-id="3e0c1-108">Con i servizi remoti, questi controlli non vengono applicati.</span><span class="sxs-lookup"><span data-stu-id="3e0c1-108">With remoting, these checks are not enforced.</span></span> <span data-ttu-id="3e0c1-109">Altri controlli di sicurezza, ad esempio <xref:System.Security.Permissions.SecurityAction.Demand>, [Assert](using-the-assert-method.md)e così via, funzionano tra i domini applicazione all'interno di un processo, ma non funzionano negli scenari tra processi o tra computer.</span><span class="sxs-lookup"><span data-stu-id="3e0c1-109">Other security checks, such as <xref:System.Security.Permissions.SecurityAction.Demand>, [Assert](using-the-assert-method.md), and so on, work between application domains within a process but do not work in cross-process or cross-machine scenarios.</span></span>  
  
## <a name="protected-objects"></a><span data-ttu-id="3e0c1-110">Oggetti protetti</span><span class="sxs-lookup"><span data-stu-id="3e0c1-110">Protected objects</span></span>  
 <span data-ttu-id="3e0c1-111">Alcuni oggetti includono internamente lo stato di sicurezza.</span><span class="sxs-lookup"><span data-stu-id="3e0c1-111">Some objects hold security state in themselves.</span></span> <span data-ttu-id="3e0c1-112">Questi oggetti non devono essere passati a codice non attendibile, che potrebbe acquisire autorizzazioni di sicurezza più elevate delle proprie.</span><span class="sxs-lookup"><span data-stu-id="3e0c1-112">These objects should not be passed to untrusted code, which would then acquire security authorization beyond its own permissions.</span></span>  
  
 <span data-ttu-id="3e0c1-113">Un esempio riguarda la creazione di un oggetto <xref:System.IO.FileStream>.</span><span class="sxs-lookup"><span data-stu-id="3e0c1-113">One example is creating a <xref:System.IO.FileStream> object.</span></span> <span data-ttu-id="3e0c1-114"><xref:System.Security.Permissions.FileIOPermission> viene richiesto al momento della creazione e, se riesce, viene restituito l'oggetto file.</span><span class="sxs-lookup"><span data-stu-id="3e0c1-114">The <xref:System.Security.Permissions.FileIOPermission> is demanded at the time of creation and, if it succeeds, the file object is returned.</span></span> <span data-ttu-id="3e0c1-115">Tuttavia, se il riferimento all'oggetto viene passato al codice senza le autorizzazioni del file, l'oggetto sarà in grado di leggere e scrivere nel file specificato.</span><span class="sxs-lookup"><span data-stu-id="3e0c1-115">However, if this object reference is passed to code without file permissions, the object will be able to read and write to this particular file.</span></span>  
  
 <span data-ttu-id="3e0c1-116">La difesa più semplice per questo tipo di oggetto è richiedere lo stesso **FileIOPermission** di qualsiasi codice che cerca di ottenere il riferimento all'oggetto tramite un elemento API pubblico.</span><span class="sxs-lookup"><span data-stu-id="3e0c1-116">The simplest defense for such an object is to demand the same **FileIOPermission** of any code that seeks to get the object reference through a public API element.</span></span>  
  
## <a name="application-domain-crossing-issues"></a><span data-ttu-id="3e0c1-117">Problemi relativi a diversi domini applicazioni</span><span class="sxs-lookup"><span data-stu-id="3e0c1-117">Application domain crossing issues</span></span>  
 <span data-ttu-id="3e0c1-118">Per isolare il codice in ambienti host gestiti, di solito si generano più domini applicazione figlio con criteri espliciti che consentono di ridurre i livelli di autorizzazione per i vari assembly.</span><span class="sxs-lookup"><span data-stu-id="3e0c1-118">To isolate code in managed hosting environments, it is common to generate multiple child application domains with explicit policy reducing the permission levels for various assemblies.</span></span> <span data-ttu-id="3e0c1-119">Tuttavia, i criteri per questi assembly rimangono invariati nel dominio applicazione predefinito.</span><span class="sxs-lookup"><span data-stu-id="3e0c1-119">However, the policy for those assemblies remains unchanged in the default application domain.</span></span> <span data-ttu-id="3e0c1-120">Se uno dei domini applicazione figlio riesce a forzare il dominio applicazione predefinito per caricare un assembly, l'effetto dell'isolamento del codice si perde e i tipi nell'assembly caricato forzatamente potranno eseguire il codice con un livello di attendibilità superiore.</span><span class="sxs-lookup"><span data-stu-id="3e0c1-120">If one of the child application domains can force the default application domain to load an assembly, the effect of code isolation is lost and types in the forcibly loaded assembly will be able to run code at a higher level of trust.</span></span>  
  
 <span data-ttu-id="3e0c1-121">Un dominio applicazione può forzare un altro dominio applicazione per caricare un assembly ed eseguire il codice contenuto chiamando un proxy in un oggetto ospitato nell’altro dominio applicazione.</span><span class="sxs-lookup"><span data-stu-id="3e0c1-121">An application domain can force another application domain to load an assembly and run code contained therein by calling a proxy to an object hosted in the other application domain.</span></span> <span data-ttu-id="3e0c1-122">Per ottenere un proxy tra domini applicazione, il dominio applicazione che ospita l'oggetto deve distribuirne uno tramite un parametro di chiamata al metodo o un valore restituito.</span><span class="sxs-lookup"><span data-stu-id="3e0c1-122">To obtain a cross-application-domain proxy, the application domain hosting the object must distribute one through a method call parameter or return value.</span></span> <span data-ttu-id="3e0c1-123">Oppure, se il dominio applicazione è stato appena creato, l'autore dispone di un proxy per l’oggetto <xref:System.AppDomain> per impostazione predefinita.</span><span class="sxs-lookup"><span data-stu-id="3e0c1-123">Or, if the application domain was just created, the creator has a proxy to the <xref:System.AppDomain> object by default.</span></span> <span data-ttu-id="3e0c1-124">Pertanto, per evitare di interrompere l'isolamento del codice, un dominio applicazione con un livello di attendibilità superiore non deve distribuire i riferimenti agli oggetti con marshalling per riferimento (istanze di classi derivate da <xref:System.MarshalByRefObject>) del proprio dominio ai domini applicazione con livelli di attendibilità inferiori.</span><span class="sxs-lookup"><span data-stu-id="3e0c1-124">Thus, to avoid breaking code isolation, an application domain with a higher level of trust should not distribute references to marshaled-by-reference objects (instances of classes derived from <xref:System.MarshalByRefObject>) in its domain to application domains with lower levels of trust.</span></span>  
  
 <span data-ttu-id="3e0c1-125">In genere, il dominio applicazione predefinito crea domini applicazione figlio con un oggetto controllo in ognuno di essi.</span><span class="sxs-lookup"><span data-stu-id="3e0c1-125">Usually, the default application domain creates the child application domains with a control object in each one.</span></span> <span data-ttu-id="3e0c1-126">L'oggetto controllo gestisce il nuovo dominio applicazione e occasionalmente accetta gli ordini dal dominio applicazione predefinito, ma non è in grado di contattare direttamente il dominio.</span><span class="sxs-lookup"><span data-stu-id="3e0c1-126">The control object manages the new application domain and occasionally takes orders from the default application domain, but it cannot actually contact the domain directly.</span></span> <span data-ttu-id="3e0c1-127">A volte il dominio applicazione predefinito chiama il proxy per l'oggetto controllo.</span><span class="sxs-lookup"><span data-stu-id="3e0c1-127">Occasionally, the default application domain calls its proxy to the control object.</span></span> <span data-ttu-id="3e0c1-128">Tuttavia, in alcuni casi l'oggetto controllo deve richiamare il dominio applicazione predefinito.</span><span class="sxs-lookup"><span data-stu-id="3e0c1-128">However, there might be cases in which it is necessary for the control object to call back to the default application domain.</span></span> <span data-ttu-id="3e0c1-129">In questi casi, il dominio applicazione predefinito passa un oggetto callback di marshalling per riferimento al costruttore dell'oggetto controllo.</span><span class="sxs-lookup"><span data-stu-id="3e0c1-129">In these cases, the default application domain passes a marshal-by-reference callback object to the constructor of the control object.</span></span> <span data-ttu-id="3e0c1-130">È responsabilità dell'oggetto controllo proteggere il proxy.</span><span class="sxs-lookup"><span data-stu-id="3e0c1-130">It is the responsibility of the control object to protect this proxy.</span></span> <span data-ttu-id="3e0c1-131">Se l'oggetto controllo posiziona il proxy in un campo statico pubblico di una classe pubblica o espone pubblicamente il proxy, può attivarsi un pericoloso meccanismo che consente a un codice di richiamare il dominio applicazione predefinito.</span><span class="sxs-lookup"><span data-stu-id="3e0c1-131">If the control object were to place the proxy on a public static field of a public class, or otherwise publicly expose the proxy, this would open up a dangerous mechanism for other code to call back into the default application domain.</span></span> <span data-ttu-id="3e0c1-132">Per questo motivo, gli oggetti controllo vengono sempre considerati implicitamente attendibili per mantenere privato il proxy.</span><span class="sxs-lookup"><span data-stu-id="3e0c1-132">For this reason, control objects are always implicitly trusted to keep the proxy private.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="3e0c1-133">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="3e0c1-133">See also</span></span>

- [<span data-ttu-id="3e0c1-134">Linee guida per la generazione di codice sicuro</span><span class="sxs-lookup"><span data-stu-id="3e0c1-134">Secure Coding Guidelines</span></span>](../../standard/security/secure-coding-guidelines.md)
