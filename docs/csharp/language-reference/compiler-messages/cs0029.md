---
title: Errore del compilatore CS0029
ms.date: 07/20/2015
f1_keywords:
- CS0029
helpviewer_keywords:
- CS0029
ms.assetid: 63c3e574-1868-4a9e-923e-dcd9f38bce88
ms.openlocfilehash: f4dec41945ace6c6b0821b9870a88960efbe1e52
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 03/14/2020
ms.locfileid: "71332306"
---
# <a name="compiler-error-cs0029"></a><span data-ttu-id="bf193-102">Errore del compilatore CS0029</span><span class="sxs-lookup"><span data-stu-id="bf193-102">Compiler Error CS0029</span></span>

<span data-ttu-id="bf193-103">Non è possibile convertire in modo implicito il tipo 'tipo' in 'tipo'</span><span class="sxs-lookup"><span data-stu-id="bf193-103">Cannot implicitly convert type 'type' to 'type'</span></span>

 <span data-ttu-id="bf193-104">Il compilatore richiede una conversione esplicita.</span><span class="sxs-lookup"><span data-stu-id="bf193-104">The compiler requires an explicit conversion.</span></span> <span data-ttu-id="bf193-105">Ad esempio, potrebbe essere necessario eseguire il cast di un r-value sullo stesso tipo di un l-value.</span><span class="sxs-lookup"><span data-stu-id="bf193-105">For example, you may need to cast an r-value to be the same type as an l-value.</span></span> <span data-ttu-id="bf193-106">Oppure, è necessario fornire routine di conversione per supportare determinati overload degli operatori.</span><span class="sxs-lookup"><span data-stu-id="bf193-106">Or, you must provide conversion routines to support certain operator overloads.</span></span>

 <span data-ttu-id="bf193-107">Le conversioni devono essere eseguite quando si assegna una variabile di un tipo a una variabile di tipo diverso.</span><span class="sxs-lookup"><span data-stu-id="bf193-107">Conversions must occur when assigning a variable of one type to a variable of a different type.</span></span> <span data-ttu-id="bf193-108">Quando si effettua un'assegnazione tra variabili di tipi diversi, il compilatore deve convertire il tipo sul lato destro dell'operatore di assegnazione nel tipo sul lato sinistro dell'operatore di assegnazione.</span><span class="sxs-lookup"><span data-stu-id="bf193-108">When making an assignment between variables of different types, the compiler must convert the type on the right-hand side of the assignment operator to the type on the left-hand side of the assignment operator.</span></span> <span data-ttu-id="bf193-109">Si consideri il codice seguente:</span><span class="sxs-lookup"><span data-stu-id="bf193-109">Take the following the code:</span></span>

```csharp
int i = 50;
long lng = 100;
i = lng;
```

 <span data-ttu-id="bf193-110">`i = lng;` esegue un'assegnazione, ma i tipi di dati delle variabili sul lato sinistro e destro dell'operatore di assegnazione non corrispondono.</span><span class="sxs-lookup"><span data-stu-id="bf193-110">`i = lng;` makes an assignment, but the data types of the variables on the left and right-hand side of the assignment operator don't match.</span></span> <span data-ttu-id="bf193-111">Prima di effettuare l'assegnazione, `lng`il compilatore converte in modo implicito la variabile , che è di tipo long, in un int. Ciò è implicito perché nessun codice indica in modo esplicito al compilatore di eseguire questa conversione.</span><span class="sxs-lookup"><span data-stu-id="bf193-111">Before making the assignment the compiler is implicitly converting the variable `lng`, which is of type long, to an int. This is implicit because no code explicitly instructed the compiler to perform this conversion.</span></span> <span data-ttu-id="bf193-112">Il problema con questo codice è che questa viene considerata una conversione verso un tipo di dati più piccolo e il compilatore non consente conversioni implicite verso un tipo di dati più piccolo a causa della potenziale perdita di dati.</span><span class="sxs-lookup"><span data-stu-id="bf193-112">The problem with this code is that this is considered a narrowing conversion, and the compiler does not allow implicit narrowing conversions because there could be a potential loss of data.</span></span>

 <span data-ttu-id="bf193-113">Una conversione verso un tipo di dati più piccolo si verifica nel caso della conversione verso un tipo di dati che occupa meno spazio di archiviazione in memoria rispetto al tipo di dati da cui viene convertito.</span><span class="sxs-lookup"><span data-stu-id="bf193-113">A narrowing conversion exists when converting to a data type that occupies less storage space in memory than the data type we are converting from.</span></span> <span data-ttu-id="bf193-114">Ad esempio, la conversione di un valore long in int viene considerata una conversione verso un tipo di dati più piccolo.</span><span class="sxs-lookup"><span data-stu-id="bf193-114">For example, converting a long to an int would be considered a narrowing conversion.</span></span> <span data-ttu-id="bf193-115">Un valore long occupa 8 byte di memoria, mentre un valore int occupa 4 byte.</span><span class="sxs-lookup"><span data-stu-id="bf193-115">A long occupies 8 bytes of memory while an int occupies 4 bytes.</span></span> <span data-ttu-id="bf193-116">Per rendersi conto di come può verificarsi una perdita di dati, prendere in esame l'esempio seguente:</span><span class="sxs-lookup"><span data-stu-id="bf193-116">To see how data loss can occur, consider the following sample:</span></span>

```csharp
int i = 50;
long lng = 3147483647;
i = lng;
```

 <span data-ttu-id="bf193-117">La variabile `lng` ora contiene un valore che non può essere archiviato nella variabile `i` perché è troppo grande.</span><span class="sxs-lookup"><span data-stu-id="bf193-117">The variable `lng` now contains a value that cannot be stored in the variable `i` because it is too large.</span></span> <span data-ttu-id="bf193-118">Se si dovesse convertire questo valore in un tipo int si potrebbero perdere alcuni dei dati e il valore convertito non sarebbe lo stesso del valore prima della conversione.</span><span class="sxs-lookup"><span data-stu-id="bf193-118">If we were to convert this value to an int type we would be losing some of our data and the converted value would not be the same as the value before the conversion.</span></span>

 <span data-ttu-id="bf193-119">Una conversione verso un tipo di dati più grande sarebbe l'opposto.</span><span class="sxs-lookup"><span data-stu-id="bf193-119">A widening conversion would be the opposite of a narrowing conversion.</span></span> <span data-ttu-id="bf193-120">Una conversione verso un tipo di dati più grande si verifica nel caso della conversione di un tipo di dati che occupa più spazio di archiviazione in memoria rispetto al tipo di dati da cui viene convertito.</span><span class="sxs-lookup"><span data-stu-id="bf193-120">With widening conversions, we are converting to a data type that occupies more storage space in memory than the data type we are converting from.</span></span> <span data-ttu-id="bf193-121">Di seguito è riportato un esempio di conversione verso un tipo di dati più grande:</span><span class="sxs-lookup"><span data-stu-id="bf193-121">Here is an example of a widening conversion:</span></span>

```csharp
int i = 50;
long lng = 100;
lng = i;
```

 <span data-ttu-id="bf193-122">Si noti la differenza tra questo esempio di codice e il primo.</span><span class="sxs-lookup"><span data-stu-id="bf193-122">Notice the difference between this code sample and the first.</span></span> <span data-ttu-id="bf193-123">In questo caso, la variabile `lng` è sul lato sinistro dell'operatore di assegnazione, pertanto è la destinazione dell'assegnazione.</span><span class="sxs-lookup"><span data-stu-id="bf193-123">This time the variable `lng` is on the left-hand side of the assignment operator, so it is the target of our assignment.</span></span> <span data-ttu-id="bf193-124">Prima di procedere all'assegnazione, il compilatore deve convertire in modo implicito la variabile `i`, che è di tipo int, nel tipo long.</span><span class="sxs-lookup"><span data-stu-id="bf193-124">Before the assignment can be made, the compiler must implicitly convert the variable `i`, which is of type int, to type long.</span></span> <span data-ttu-id="bf193-125">Questa è una conversione verso un tipo di dati più grande, perché si converte un tipo che occupa 4 byte di memoria (int) in un tipo che occupa 8 byte di memoria (long).</span><span class="sxs-lookup"><span data-stu-id="bf193-125">This is a widening conversion since we are converting from a type that occupies 4 bytes of memory (an int) to a type that occupies 8 bytes of memory (a long).</span></span> <span data-ttu-id="bf193-126">Le conversioni implicite verso un tipo di dati più grande sono consentite perché non è presente il rischio di perdita di dati.</span><span class="sxs-lookup"><span data-stu-id="bf193-126">Implicit widening conversions are allowed because there is no potential loss of data.</span></span> <span data-ttu-id="bf193-127">Qualsiasi valore che può essere archiviato in un int, può essere archiviato anche in un tipo long.</span><span class="sxs-lookup"><span data-stu-id="bf193-127">Any value that can be stored in an int can also be stored in a long.</span></span>

 <span data-ttu-id="bf193-128">Sapendo che le conversioni implicite verso un tipo di dati più piccolo non sono consentite, per riuscire a compilare questo codice è necessaria la conversione esplicita del tipo di dati.</span><span class="sxs-lookup"><span data-stu-id="bf193-128">We know that implicit narrowing conversions are not allowed, so to be able to compile this code we need to explicitly convert the data type.</span></span> <span data-ttu-id="bf193-129">Le conversioni esplicite vengono eseguite tramite casting.</span><span class="sxs-lookup"><span data-stu-id="bf193-129">Explicit conversions are done using casting.</span></span> <span data-ttu-id="bf193-130">Il termine cast o casting viene usato in C# per indicare la conversione da un tipo di dati a un altro.</span><span class="sxs-lookup"><span data-stu-id="bf193-130">Casting is the term used in C# to describe converting one data type to another.</span></span> <span data-ttu-id="bf193-131">Per ottenere la compilazione del codice, è necessario usare la sintassi seguente:</span><span class="sxs-lookup"><span data-stu-id="bf193-131">To get the code to compile we would need to use the following syntax:</span></span>

```csharp
int i = 50;
long lng = 100;
i = (int) lng;   // Cast to int.
```

 <span data-ttu-id="bf193-132">La terza riga di codice indica al compilatore di convertire in modo implicito la variabile `lng`, di tipo long, in int prima di procedere all'assegnazione.</span><span class="sxs-lookup"><span data-stu-id="bf193-132">The third line of code tells the compiler to explicitly convert the variable `lng`, which is of type long, to an int before making the assignment.</span></span> <span data-ttu-id="bf193-133">Tenere presente che con una conversione verso un tipo di dati più piccolo, esiste una potenziale perdita di dati.</span><span class="sxs-lookup"><span data-stu-id="bf193-133">Remember that with a narrowing conversion, there is a potential loss of data.</span></span> <span data-ttu-id="bf193-134">Le conversioni verso un tipo di dati più piccolo devono essere usate con cautela e anche se il codice viene compilato si potrebbero ottenere risultati imprevisti in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="bf193-134">Narrowing conversions should be used with caution and even though the code will compile you may get unexpected results at run-time.</span></span>

 <span data-ttu-id="bf193-135">Queste informazioni riguardano solo i tipi valore.</span><span class="sxs-lookup"><span data-stu-id="bf193-135">This discussion has only been for value types.</span></span> <span data-ttu-id="bf193-136">Quando si usano i tipi valore, si opera direttamente sui dati archiviati nella variabile.</span><span class="sxs-lookup"><span data-stu-id="bf193-136">When working with value types you work directly with the data stored in the variable.</span></span> <span data-ttu-id="bf193-137">Tuttavia, .NET Framework include anche i tipi riferimento.</span><span class="sxs-lookup"><span data-stu-id="bf193-137">However, the .NET Framework also has reference types.</span></span> <span data-ttu-id="bf193-138">Con i tipi riferimento non si usano i dati effettivi, ma un riferimento a una variabile.</span><span class="sxs-lookup"><span data-stu-id="bf193-138">When working with reference types you are working with a reference to a variable, not the actual data.</span></span> <span data-ttu-id="bf193-139">Sono esempi di tipi riferimento le classi, le interfacce e le matrici.</span><span class="sxs-lookup"><span data-stu-id="bf193-139">Examples of reference types would be classes, interfaces and arrays.</span></span> <span data-ttu-id="bf193-140">Non è possibile convertire in modo implicito o esplicito un tipo riferimento in un altro, a meno che il compilatore non consenta la conversione specifica o che non siano implementati gli operatori di conversione appropriati.</span><span class="sxs-lookup"><span data-stu-id="bf193-140">You cannot implicitly or explicitly convert one reference type to another unless the compiler allows the specific conversion or the appropriate conversion operators are implemented.</span></span>

 <span data-ttu-id="bf193-141">L'esempio seguente genera l'errore CS0029:</span><span class="sxs-lookup"><span data-stu-id="bf193-141">The following sample generates CS0029:</span></span>

```csharp
// CS0029.cs
public class MyInt
{
    private int x = 0;

    // Uncomment this conversion routine to resolve CS0029.
    /*
    public static implicit operator int(MyInt i)
    {
        return i.x;
    }
    */

    public static void Main()
    {
        var myInt = new MyInt();
        int i = myInt; // CS0029
    }
}
```

## <a name="see-also"></a><span data-ttu-id="bf193-142">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="bf193-142">See also</span></span>

- [<span data-ttu-id="bf193-143">Operatori di conversione definiti dall'utente</span><span class="sxs-lookup"><span data-stu-id="bf193-143">User-defined conversion operators</span></span>](../operators/user-defined-conversion-operators.md)
