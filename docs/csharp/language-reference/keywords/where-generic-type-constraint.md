---
title: where (vincolo di tipo generico) - Riferimenti per C#
ms.date: 04/12/2018
f1_keywords:
- whereconstraint
- whereconstraint_CSharpKeyword
helpviewer_keywords:
- where (generic type constraint) [C#]
ms.openlocfilehash: d236420c5019f7529b729155b13df50807dc1dab
ms.sourcegitcommit: 44a7cd8687f227fc6db3211ccf4783dc20235e51
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 02/26/2020
ms.locfileid: "77626711"
---
# <a name="where-generic-type-constraint-c-reference"></a><span data-ttu-id="930d6-102">where (vincolo di tipo generico) (Riferimenti per C#)</span><span class="sxs-lookup"><span data-stu-id="930d6-102">where (generic type constraint) (C# Reference)</span></span>

<span data-ttu-id="930d6-103">La clausola `where` in una definizione generica specifica i vincoli per i tipi che vengono usati come argomenti per i parametri di tipo in un tipo generico, metodo, delegato o funzione locale.</span><span class="sxs-lookup"><span data-stu-id="930d6-103">The `where` clause in a generic definition specifies constraints on the types that are used as arguments for type parameters in a generic type, method, delegate, or local function.</span></span> <span data-ttu-id="930d6-104">I vincoli possono specificare interfacce, classi base o richiedere che un tipo generico sia un riferimento, un valore o un tipo non gestito.</span><span class="sxs-lookup"><span data-stu-id="930d6-104">Constraints can specify interfaces, base classes, or require a generic type to be a reference, value, or unmanaged type.</span></span> <span data-ttu-id="930d6-105">Dichiarano le funzionalità che l'argomento tipo deve possedere.</span><span class="sxs-lookup"><span data-stu-id="930d6-105">They declare capabilities that the type argument must possess.</span></span>

<span data-ttu-id="930d6-106">Ad esempio, una classe generica, `MyGenericClass`, può essere dichiarata in modo che tramite il parametro di tipo `T` venga implementata l'interfaccia <xref:System.IComparable%601>:</span><span class="sxs-lookup"><span data-stu-id="930d6-106">For example, you can declare a generic class, `MyGenericClass`, such that the type parameter `T` implements the <xref:System.IComparable%601> interface:</span></span>

[!code-csharp[using an interface constraint](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#1)]

> [!NOTE]
> <span data-ttu-id="930d6-107">Per altre informazioni sulla clausola where in un'espressione di query, vedere [Clausola where](where-clause.md).</span><span class="sxs-lookup"><span data-stu-id="930d6-107">For more information on the where clause in a query expression, see [where clause](where-clause.md).</span></span>

<span data-ttu-id="930d6-108">La clausola `where` può inoltre includere un vincolo di classe di base.</span><span class="sxs-lookup"><span data-stu-id="930d6-108">The `where` clause can also include a base class constraint.</span></span> <span data-ttu-id="930d6-109">Il vincolo di classe di base dichiara che un tipo da usare come argomento tipo per quel tipo generico usi la classe specificata come classe di base (o sia quella classe di base) come argomento tipo per quel tipo generico.</span><span class="sxs-lookup"><span data-stu-id="930d6-109">The base class constraint states that a type to be used as a type argument for that generic type has the specified class as a base class (or is that base class) to be used as a type argument for that generic type.</span></span> <span data-ttu-id="930d6-110">Se viene usato il vincolo della classe di base, deve apparire prima di tutti gli altri vincoli per quel parametro di tipo.</span><span class="sxs-lookup"><span data-stu-id="930d6-110">If the base class constraint is used, it must appear before any other constraints on that type parameter.</span></span> <span data-ttu-id="930d6-111">Alcuni tipi non sono consentiti come vincoli di classe di base: <xref:System.Object>, <xref:System.Array> e <xref:System.ValueType>.</span><span class="sxs-lookup"><span data-stu-id="930d6-111">Some types are disallowed as a base class constraint: <xref:System.Object>, <xref:System.Array>, and <xref:System.ValueType>.</span></span> <span data-ttu-id="930d6-112">Prima di C# 7.3 anche <xref:System.Enum>, <xref:System.Delegate> e <xref:System.MulticastDelegate> non erano consentiti come vincoli di classe di base.</span><span class="sxs-lookup"><span data-stu-id="930d6-112">Prior to C# 7.3, <xref:System.Enum>, <xref:System.Delegate>, and <xref:System.MulticastDelegate> were also disallowed as base class constraints.</span></span> <span data-ttu-id="930d6-113">L'esempio seguente illustra i tipi possono ora essere specificati come una classe di base:</span><span class="sxs-lookup"><span data-stu-id="930d6-113">The following example shows the types that can now be specified as a base class:</span></span>

[!code-csharp[using an interface constraint](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#2)]

<span data-ttu-id="930d6-114">La clausola `where` può specificare che il tipo è un oggetto `class` o `struct`.</span><span class="sxs-lookup"><span data-stu-id="930d6-114">The `where` clause can specify that the type is a `class` or a `struct`.</span></span> <span data-ttu-id="930d6-115">Il vincolo `struct` elimina la necessità di specificare un vincolo di classe di base di `System.ValueType`.</span><span class="sxs-lookup"><span data-stu-id="930d6-115">The `struct` constraint removes the need to specify a base class constraint of `System.ValueType`.</span></span> <span data-ttu-id="930d6-116">Il tipo `System.ValueType` non può essere usato come vincolo di classe di base.</span><span class="sxs-lookup"><span data-stu-id="930d6-116">The `System.ValueType` type may not be used as a base class constraint.</span></span> <span data-ttu-id="930d6-117">Nell'esempio seguente vengono illustrati i vincoli `class` e `struct`:</span><span class="sxs-lookup"><span data-stu-id="930d6-117">The following example shows both the `class` and `struct` constraints:</span></span>

[!code-csharp[using the class and struct constraints](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#3)]

<span data-ttu-id="930d6-118">La clausola `where` può includere il vincolo `notnull`.</span><span class="sxs-lookup"><span data-stu-id="930d6-118">The `where` clause may include the `notnull` constraint.</span></span> <span data-ttu-id="930d6-119">Il vincolo `notnull` limita il parametro di tipo ai tipi che non ammettono valori null.</span><span class="sxs-lookup"><span data-stu-id="930d6-119">The `notnull` constraint limits the type parameter to non-nullable types.</span></span> <span data-ttu-id="930d6-120">Il tipo può essere un [tipo di valore](../builtin-types/value-types.md) o un tipo di riferimento non nullable.</span><span class="sxs-lookup"><span data-stu-id="930d6-120">That type may be a [value type](../builtin-types/value-types.md) or a non-nullable reference type.</span></span> <span data-ttu-id="930d6-121">Il vincolo `notnull` è disponibile a partire C# da 8,0 per il codice compilato in un [contesto di`nullable enable`](../../nullable-references.md#nullable-contexts).</span><span class="sxs-lookup"><span data-stu-id="930d6-121">The `notnull` constraint is available starting in C# 8.0 for code compiled in a [`nullable enable` context](../../nullable-references.md#nullable-contexts).</span></span> <span data-ttu-id="930d6-122">Diversamente da altri vincoli, se un argomento di tipo viola il vincolo di `notnull`, il compilatore genera un avviso anziché un errore.</span><span class="sxs-lookup"><span data-stu-id="930d6-122">Unlike other constraints, if a type argument violates the `notnull` constraint, the compiler generates a warning instead of an error.</span></span> <span data-ttu-id="930d6-123">Gli avvisi vengono generati solo in un contesto di `nullable enable`.</span><span class="sxs-lookup"><span data-stu-id="930d6-123">Warnings are only generated in a `nullable enable` context.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="930d6-124">Le dichiarazioni generiche che includono il vincolo `notnull` possono essere utilizzate in un contesto ignaro Nullable, ma il compilatore non impone il vincolo.</span><span class="sxs-lookup"><span data-stu-id="930d6-124">Generic declarations that include the `notnull` constraint can be used in a nullable oblivious context, but compiler does not enforce the constraint.</span></span>

[!code-csharp[using the nonnull constraint](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#NotNull)]

<span data-ttu-id="930d6-125">La clausola `where` può anche includere un vincolo `unmanaged`.</span><span class="sxs-lookup"><span data-stu-id="930d6-125">The `where` clause may also include an `unmanaged` constraint.</span></span> <span data-ttu-id="930d6-126">Il vincolo `unmanaged` limita il parametro di tipo ai tipi noti come [tipi non gestiti](../builtin-types/unmanaged-types.md).</span><span class="sxs-lookup"><span data-stu-id="930d6-126">The `unmanaged` constraint limits the type parameter to types known as [unmanaged types](../builtin-types/unmanaged-types.md).</span></span> <span data-ttu-id="930d6-127">Il vincolo `unmanaged` rende più semplice la scrittura di codice di interoperabilità di basso livello in C#.</span><span class="sxs-lookup"><span data-stu-id="930d6-127">The `unmanaged` constraint makes it easier to write low-level interop code in C#.</span></span> <span data-ttu-id="930d6-128">Questo vincolo abilita le routine riutilizzabili in tutti i tipi non gestiti.</span><span class="sxs-lookup"><span data-stu-id="930d6-128">This constraint enables reusable routines across all unmanaged types.</span></span> <span data-ttu-id="930d6-129">Il vincolo `unmanaged` non può essere combinato con il vincolo `class` o `struct`.</span><span class="sxs-lookup"><span data-stu-id="930d6-129">The `unmanaged` constraint can't be combined with the `class` or `struct` constraint.</span></span> <span data-ttu-id="930d6-130">Il vincolo `unmanaged` impone che il tipo deve essere un elemento `struct`:</span><span class="sxs-lookup"><span data-stu-id="930d6-130">The `unmanaged` constraint enforces that the type must be a `struct`:</span></span>

[!code-csharp[using the unmanaged constraint](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#4)]

<span data-ttu-id="930d6-131">La clausola `where` può anche includere un vincolo di costruttore, `new()`.</span><span class="sxs-lookup"><span data-stu-id="930d6-131">The `where` clause may also include a constructor constraint, `new()`.</span></span> <span data-ttu-id="930d6-132">Tale vincolo consente di creare un'istanza di un parametro di tipo usando l'operatore `new`.</span><span class="sxs-lookup"><span data-stu-id="930d6-132">That constraint makes it possible to create an instance of a type parameter using the `new` operator.</span></span> <span data-ttu-id="930d6-133">Il [vincolo New ()](new-constraint.md) consente al compilatore di verificare che qualsiasi argomento di tipo fornito disponga di un costruttore senza parametri accessibile.</span><span class="sxs-lookup"><span data-stu-id="930d6-133">The [new() Constraint](new-constraint.md) lets the compiler know that any type argument supplied must have an accessible parameterless constructor.</span></span> <span data-ttu-id="930d6-134">Ad esempio,</span><span class="sxs-lookup"><span data-stu-id="930d6-134">For example:</span></span>

[!code-csharp[using the new constraint](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#5)]

<span data-ttu-id="930d6-135">Il vincolo `new()` viene visualizzato per ultimo nella clausola `where`.</span><span class="sxs-lookup"><span data-stu-id="930d6-135">The `new()` constraint appears last in the `where` clause.</span></span> <span data-ttu-id="930d6-136">Il vincolo `new()` non può essere combinato con i vincoli `struct` o `unmanaged`.</span><span class="sxs-lookup"><span data-stu-id="930d6-136">The `new()` constraint can't be combined with the `struct` or `unmanaged` constraints.</span></span> <span data-ttu-id="930d6-137">Tutti i tipi che soddisfano i vincoli devono avere un costruttore senza parametri accessibile, per rendere il vincolo `new()` ridondante.</span><span class="sxs-lookup"><span data-stu-id="930d6-137">All types satisfying those constraints must have an accessible parameterless constructor, making the `new()` constraint redundant.</span></span>

<span data-ttu-id="930d6-138">Con più parametri di tipo, usare una clausola `where` per ogni parametro di tipo, ad esempio:</span><span class="sxs-lookup"><span data-stu-id="930d6-138">With multiple type parameters, use one `where` clause for each type parameter, for example:</span></span>

[!code-csharp[using multiple where constraints](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#6)]

<span data-ttu-id="930d6-139">È anche possibile associare vincoli ai parametri di tipo di metodi generici, come illustrato nell'esempio seguente:</span><span class="sxs-lookup"><span data-stu-id="930d6-139">You can also attach constraints to type parameters of generic methods, as shown in the following example:</span></span>

[!code-csharp[where constraints with generic methods](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#7)]

<span data-ttu-id="930d6-140">Si noti che la sintassi usata per descrivere i vincoli dei parametri di tipo per i delegati è uguale a quella dei metodi:</span><span class="sxs-lookup"><span data-stu-id="930d6-140">Notice that the syntax to describe type parameter constraints on delegates is the same as that of methods:</span></span>

[!code-csharp[where constraints with generic methods](~/samples/snippets/csharp/keywords/GenericWhereConstraints.cs#8)]

<span data-ttu-id="930d6-141">Per informazioni sui delegati generici, vedere [Delegati generici](../../programming-guide/generics/generic-delegates.md).</span><span class="sxs-lookup"><span data-stu-id="930d6-141">For information on generic delegates, see [Generic Delegates](../../programming-guide/generics/generic-delegates.md).</span></span>

<span data-ttu-id="930d6-142">Per informazioni dettagliate sulla sintassi e sull'uso dei vincoli, vedere [Vincoli sui parametri di tipo](../../programming-guide/generics/constraints-on-type-parameters.md).</span><span class="sxs-lookup"><span data-stu-id="930d6-142">For details on the syntax and use of constraints, see [Constraints on Type Parameters](../../programming-guide/generics/constraints-on-type-parameters.md).</span></span>

## <a name="c-language-specification"></a><span data-ttu-id="930d6-143">Specifiche del linguaggio C#</span><span class="sxs-lookup"><span data-stu-id="930d6-143">C# language specification</span></span>

 [!INCLUDE[CSharplangspec](~/includes/csharplangspec-md.md)]

## <a name="see-also"></a><span data-ttu-id="930d6-144">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="930d6-144">See also</span></span>

- [<span data-ttu-id="930d6-145">Riferimenti per C#</span><span class="sxs-lookup"><span data-stu-id="930d6-145">C# Reference</span></span>](../index.md)
- [<span data-ttu-id="930d6-146">Guida per programmatori C#</span><span class="sxs-lookup"><span data-stu-id="930d6-146">C# Programming Guide</span></span>](../../programming-guide/index.md)
- [<span data-ttu-id="930d6-147">Introduzione ai generics</span><span class="sxs-lookup"><span data-stu-id="930d6-147">Introduction to Generics</span></span>](../../programming-guide/generics/index.md)
- [<span data-ttu-id="930d6-148">Vincolo new</span><span class="sxs-lookup"><span data-stu-id="930d6-148">new Constraint</span></span>](./new-constraint.md)
- [<span data-ttu-id="930d6-149">Vincoli sui parametri di tipo</span><span class="sxs-lookup"><span data-stu-id="930d6-149">Constraints on Type Parameters</span></span>](../../programming-guide/generics/constraints-on-type-parameters.md)
