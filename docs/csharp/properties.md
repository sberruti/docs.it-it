---
title: Proprietà
description: Informazioni sulle proprietà di C#, tra cui funzionalità per la convalida, valori calcolati, valutazione lazy e notifiche di modifica di proprietà.
ms.technology: csharp-fundamentals
ms.date: 04/25/2018
ms.openlocfilehash: bda8a4f58f71b57248296dd4ba9f9bf4cbed40d4
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 03/14/2020
ms.locfileid: "79399413"
---
# <a name="properties"></a><span data-ttu-id="e2a61-103">Proprietà</span><span class="sxs-lookup"><span data-stu-id="e2a61-103">Properties</span></span>

<span data-ttu-id="e2a61-104">Le proprietà sono elementi fondamentali in C#.</span><span class="sxs-lookup"><span data-stu-id="e2a61-104">Properties are first class citizens in C#.</span></span> <span data-ttu-id="e2a61-105">Il linguaggio definisce la sintassi che consente agli sviluppatori di scrivere codice che esprime in modo preciso la finalità della progettazione.</span><span class="sxs-lookup"><span data-stu-id="e2a61-105">The language defines syntax that enables developers to write code that accurately expresses their design intent.</span></span>

<span data-ttu-id="e2a61-106">Quando viene eseguito l'accesso, le proprietà si comportano come i campi.</span><span class="sxs-lookup"><span data-stu-id="e2a61-106">Properties behave like fields when they are accessed.</span></span>
<span data-ttu-id="e2a61-107">Tuttavia, a differenza dei campi, le proprietà vengono implementate con funzioni di accesso che definiscono le istruzioni eseguite al momento dell'accesso e dell'assegnazione della proprietà.</span><span class="sxs-lookup"><span data-stu-id="e2a61-107">However, unlike fields, properties are implemented with accessors that define the statements executed when a property is accessed or assigned.</span></span>

## <a name="property-syntax"></a><span data-ttu-id="e2a61-108">Sintassi delle proprietà</span><span class="sxs-lookup"><span data-stu-id="e2a61-108">Property syntax</span></span>

<span data-ttu-id="e2a61-109">La sintassi delle proprietà è un'estensione naturale dei campi.</span><span class="sxs-lookup"><span data-stu-id="e2a61-109">The syntax for properties is a natural extension to fields.</span></span> <span data-ttu-id="e2a61-110">Un campo definisce una posizione di archiviazione:</span><span class="sxs-lookup"><span data-stu-id="e2a61-110">A field defines a storage location:</span></span>

[!code-csharp[Person class with public fields](../../samples/snippets/csharp/properties/Person.cs#1)]

<span data-ttu-id="e2a61-111">La definizione di una proprietà contiene le dichiarazioni di una funzione di accesso `get` e `set` che recupera e assegna il valore della proprietà:</span><span class="sxs-lookup"><span data-stu-id="e2a61-111">A property definition contains declarations for a `get` and `set` accessor that retrieves and assigns the value of that property:</span></span>

[!code-csharp[Person class with public properties](../../samples/snippets/csharp/properties/Person.cs#2)]

<span data-ttu-id="e2a61-112">La sintassi illustrata sopra è la sintassi della *proprietà automatica*.</span><span class="sxs-lookup"><span data-stu-id="e2a61-112">The syntax shown above is the *auto property* syntax.</span></span> <span data-ttu-id="e2a61-113">Il compilatore genera la posizione di archiviazione per il campo che esegue il backup della proprietà.</span><span class="sxs-lookup"><span data-stu-id="e2a61-113">The compiler generates the storage location for the field that backs up the property.</span></span> <span data-ttu-id="e2a61-114">Il compilatore implementa anche il corpo delle funzioni di accesso `get` e `set`.</span><span class="sxs-lookup"><span data-stu-id="e2a61-114">The compiler also implements the body of the `get` and `set` accessors.</span></span>

<span data-ttu-id="e2a61-115">In alcuni casi è necessario inizializzare una proprietà con un valore diverso da quello predefinito per il suo tipo.</span><span class="sxs-lookup"><span data-stu-id="e2a61-115">Sometimes, you need to initialize a property to a value other than the default for its type.</span></span>  <span data-ttu-id="e2a61-116">In C# questa operazione è possibile impostando un valore dopo la parentesi graffa chiusa della proprietà.</span><span class="sxs-lookup"><span data-stu-id="e2a61-116">C# enables that by setting a value after the closing brace for the property.</span></span> <span data-ttu-id="e2a61-117">Per la proprietà `FirstName` è preferibile usare come valore iniziale una stringa vuota anziché `null`.</span><span class="sxs-lookup"><span data-stu-id="e2a61-117">You may prefer the initial value for the `FirstName` property to be the empty string rather than `null`.</span></span> <span data-ttu-id="e2a61-118">Ecco come eseguire questa operazione:</span><span class="sxs-lookup"><span data-stu-id="e2a61-118">You would specify that as shown below:</span></span>

[!code-csharp[Person class with properties and initializer](../../samples/snippets/csharp/properties/Person.cs#3)]

<span data-ttu-id="e2a61-119">L'inizializzazione specifica è particolarmente utile per le proprietà di sola lettura, come si vedrà più avanti in questo articolo.</span><span class="sxs-lookup"><span data-stu-id="e2a61-119">Specific initialization is most useful for read-only properties, as you'll see later in this article.</span></span>

<span data-ttu-id="e2a61-120">È anche possibile definire l'archiviazione manualmente, come illustrato di seguito:</span><span class="sxs-lookup"><span data-stu-id="e2a61-120">You can also define the storage yourself, as shown below:</span></span>

[!code-csharp[Person class with properties and backing field](../../samples/snippets/csharp/properties/Person.cs#4)]

<span data-ttu-id="e2a61-121">Se l'implementazione di una proprietà corrisponde a un'espressione singola, è possibile usare *membri con corpo di espressione* per il getter o il setter:</span><span class="sxs-lookup"><span data-stu-id="e2a61-121">When a property implementation is a single expression, you can use *expression-bodied members* for the getter or setter:</span></span>

[!code-csharp[Person class with properties and expression bodied getters and setters](../../samples/snippets/csharp/properties/Person.cs#5)]

<span data-ttu-id="e2a61-122">Questa sintassi semplificata verrà usata ovunque applicabile in questo articolo.</span><span class="sxs-lookup"><span data-stu-id="e2a61-122">This simplified syntax will be used where applicable throughout this article.</span></span>

<span data-ttu-id="e2a61-123">La definizione della proprietà illustrata sopra è una proprietà di lettura/scrittura.</span><span class="sxs-lookup"><span data-stu-id="e2a61-123">The property definition shown above is a read-write property.</span></span> <span data-ttu-id="e2a61-124">Si noti la parola chiave `value` nella funzione di accesso impostata.</span><span class="sxs-lookup"><span data-stu-id="e2a61-124">Notice the keyword `value` in the set accessor.</span></span> <span data-ttu-id="e2a61-125">La funzione di accesso `set` ha sempre un singolo parametro denominato `value`.</span><span class="sxs-lookup"><span data-stu-id="e2a61-125">The `set` accessor always has a single parameter named `value`.</span></span> <span data-ttu-id="e2a61-126">La funzione di accesso `get` deve restituire un valore che è convertibile nel tipo della proprietà (in questo esempio `string`).</span><span class="sxs-lookup"><span data-stu-id="e2a61-126">The `get` accessor must return a value that is convertible to the type of the property (`string` in this example).</span></span>

<span data-ttu-id="e2a61-127">Queste sono le nozioni di basi sulla sintassi.</span><span class="sxs-lookup"><span data-stu-id="e2a61-127">That's the basics of the syntax.</span></span> <span data-ttu-id="e2a61-128">Esistono numerose varianti che supportano un'ampia gamma di termini di progettazione diversi.</span><span class="sxs-lookup"><span data-stu-id="e2a61-128">There are many different variations that support a variety of different design idioms.</span></span> <span data-ttu-id="e2a61-129">Di seguito sono descritte le opzioni di sintassi per ogni termine.</span><span class="sxs-lookup"><span data-stu-id="e2a61-129">Let's explore, and learn the syntax options for each.</span></span>

## <a name="scenarios"></a><span data-ttu-id="e2a61-130">Scenari</span><span class="sxs-lookup"><span data-stu-id="e2a61-130">Scenarios</span></span>

<span data-ttu-id="e2a61-131">Gli esempi precedenti hanno illustrato uno dei casi più semplici di definizione delle proprietà, ovvero una proprietà di lettura/scrittura senza convalida.</span><span class="sxs-lookup"><span data-stu-id="e2a61-131">The examples above showed one of the simplest cases of property definition: a read-write property with no validation.</span></span> <span data-ttu-id="e2a61-132">Scrivendo il codice desiderato nelle funzioni di accesso `get` e `set` è possibile creare scenari diversi.</span><span class="sxs-lookup"><span data-stu-id="e2a61-132">By writing the code you want in the `get` and `set` accessors, you can create many different scenarios.</span></span>

### <a name="validation"></a><span data-ttu-id="e2a61-133">Convalida</span><span class="sxs-lookup"><span data-stu-id="e2a61-133">Validation</span></span>

<span data-ttu-id="e2a61-134">È possibile scrivere codice nella funzione di accesso `set` per assicurarsi che i valori rappresentati da una proprietà siano sempre validi.</span><span class="sxs-lookup"><span data-stu-id="e2a61-134">You can write code in the `set` accessor to ensure that the values represented by a property are always valid.</span></span> <span data-ttu-id="e2a61-135">Ad esempio, si supponga che una regola per la classe `Person` preveda che il nome non può essere vuoto o uno spazio vuoto.</span><span class="sxs-lookup"><span data-stu-id="e2a61-135">For example, suppose one rule for the `Person` class is that the name cannot be blank or white space.</span></span> <span data-ttu-id="e2a61-136">Sarà necessario scrivere:</span><span class="sxs-lookup"><span data-stu-id="e2a61-136">You would write that as follows:</span></span>

[!code-csharp[Validating property setters](../../samples/snippets/csharp/properties/Person.cs#6)]

<span data-ttu-id="e2a61-137">L'esempio precedente può essere semplificato usando un'espressione `throw` come parte della convalida del setter della proprietà:</span><span class="sxs-lookup"><span data-stu-id="e2a61-137">The preceding example can be simplified by using a`throw` expression as part of the property setter validation:</span></span>

[!code-csharp[Validating property setters](../../samples/snippets/csharp/properties/Person.cs#7)]

<span data-ttu-id="e2a61-138">L'esempio precedente applica la regola che prevede che il nome non può essere vuoto o uno spazio vuoto.</span><span class="sxs-lookup"><span data-stu-id="e2a61-138">The example above enforces the rule that the first name must not be blank or white space.</span></span> <span data-ttu-id="e2a61-139">Se lo sviluppatore scrive</span><span class="sxs-lookup"><span data-stu-id="e2a61-139">If a developer writes</span></span>

```csharp
hero.FirstName = "";
```

<span data-ttu-id="e2a61-140">L'assegnazione genera `ArgumentException`.</span><span class="sxs-lookup"><span data-stu-id="e2a61-140">That assignment throws an `ArgumentException`.</span></span> <span data-ttu-id="e2a61-141">Poiché la funzione di accesso di un insieme di proprietà deve avere un tipo restituito void, gli errori vengono segnalati nella funzione di accesso dell'insieme generando un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="e2a61-141">Because a property set accessor must have a void return type, you report errors in the set accessor by throwing an exception.</span></span>

<span data-ttu-id="e2a61-142">La stessa sintassi può essere estesa a ogni elemento necessario nello scenario.</span><span class="sxs-lookup"><span data-stu-id="e2a61-142">You can extend this same syntax to anything needed in your scenario.</span></span> <span data-ttu-id="e2a61-143">È possibile controllare le relazioni tra le diverse proprietà o eseguire la convalida in base a qualsiasi condizione esterna.</span><span class="sxs-lookup"><span data-stu-id="e2a61-143">You can check the relationships between different properties, or validate against any external conditions.</span></span> <span data-ttu-id="e2a61-144">Tutte le istruzioni C# valide sono valide nella funzione di accesso di una proprietà.</span><span class="sxs-lookup"><span data-stu-id="e2a61-144">Any valid C# statements are valid in a property accessor.</span></span>

### <a name="read-only"></a><span data-ttu-id="e2a61-145">Sola lettura</span><span class="sxs-lookup"><span data-stu-id="e2a61-145">Read-only</span></span>

<span data-ttu-id="e2a61-146">Le definizioni di proprietà descritte fino a questo punto si riferiscono a proprietà di lettura/scrittura con funzioni di accesso pubbliche.</span><span class="sxs-lookup"><span data-stu-id="e2a61-146">Up to this point, all the property definitions you have seen are read/write properties with public accessors.</span></span> <span data-ttu-id="e2a61-147">Non si tratta tuttavia dell'unica accessibilità valida per le proprietà.</span><span class="sxs-lookup"><span data-stu-id="e2a61-147">That's not the only valid accessibility for properties.</span></span>
<span data-ttu-id="e2a61-148">È possibile creare proprietà di sola lettura o assegnare un'accessibilità diversa alle funzioni di accesso set e get.</span><span class="sxs-lookup"><span data-stu-id="e2a61-148">You can create read-only properties, or give different accessibility to the set and get accessors.</span></span> <span data-ttu-id="e2a61-149">Si supponga che la classe `Person` debba consentire soltanto la modifica del valore della proprietà `FirstName` da altri metodi della classe.</span><span class="sxs-lookup"><span data-stu-id="e2a61-149">Suppose that your `Person` class should only enable changing the value of the `FirstName` property from other methods in that class.</span></span> <span data-ttu-id="e2a61-150">È possibile assegnare alla funzione di accesso set l'accessibilità `private` anziché `public`:</span><span class="sxs-lookup"><span data-stu-id="e2a61-150">You could give the set accessor `private` accessibility instead of `public`:</span></span>

[!code-csharp[Using a private setter for a publicly readonly property](../../samples/snippets/csharp/properties/Person.cs#8)]

<span data-ttu-id="e2a61-151">L'accesso alla proprietà `FirstName` potrà quindi essere eseguito da qualsiasi codice, ma la proprietà potrà essere assegnata soltanto da altro codice della classe `Person`.</span><span class="sxs-lookup"><span data-stu-id="e2a61-151">Now, the `FirstName` property can be accessed from any code, but it can only be assigned from other code in the `Person` class.</span></span>

<span data-ttu-id="e2a61-152">È possibile aggiungere qualsiasi modificatore di accesso restrittivo alle funzioni di accesso set o get.</span><span class="sxs-lookup"><span data-stu-id="e2a61-152">You can add any restrictive access modifier to either the set or get accessors.</span></span> <span data-ttu-id="e2a61-153">Il modificatore di accesso inserito nella singola funzione di accesso deve essere più restrittivo del modificatore di accesso della definizione della proprietà.</span><span class="sxs-lookup"><span data-stu-id="e2a61-153">Any access modifier you place on the individual accessor must be more limited than the access modifier on the property definition.</span></span> <span data-ttu-id="e2a61-154">Il codice precedente è valido poiché la proprietà `FirstName` è `public` e la funzione di accesso set è `private`.</span><span class="sxs-lookup"><span data-stu-id="e2a61-154">The above is legal because the `FirstName` property is `public`, but the set accessor is `private`.</span></span> <span data-ttu-id="e2a61-155">Non è possibile dichiarare una proprietà `private` con una funzione di accesso `public`.</span><span class="sxs-lookup"><span data-stu-id="e2a61-155">You could not declare a `private` property with a `public` accessor.</span></span> <span data-ttu-id="e2a61-156">Le dichiarazioni di proprietà possono anche essere dichiarate `protected`, `internal`, `protected internal` o anche `private`.</span><span class="sxs-lookup"><span data-stu-id="e2a61-156">Property declarations can also be declared `protected`, `internal`, `protected internal`, or, even `private`.</span></span>

<span data-ttu-id="e2a61-157">È anche consentito inserire il modificatore più restrittivo nella funzione di accesso `get`.</span><span class="sxs-lookup"><span data-stu-id="e2a61-157">It is also legal to place the more restrictive modifier on the `get` accessor.</span></span> <span data-ttu-id="e2a61-158">Ad esempio, è possibile avere una proprietà `public` e limitare la funzione di accesso `get` a `private`.</span><span class="sxs-lookup"><span data-stu-id="e2a61-158">For example, you could have a `public` property, but restrict the `get` accessor to `private`.</span></span> <span data-ttu-id="e2a61-159">Questo scenario viene usato raramente.</span><span class="sxs-lookup"><span data-stu-id="e2a61-159">That scenario is rarely done in practice.</span></span>

<span data-ttu-id="e2a61-160">È anche possibile limitare le modifiche a una proprietà, in modo che possa essere impostata solo in un costruttore o in un inizializzatore di proprietà.</span><span class="sxs-lookup"><span data-stu-id="e2a61-160">You can also restrict modifications to a property so that it can only be set in a constructor or a property initializer.</span></span> <span data-ttu-id="e2a61-161">È possibile modificare in tal senso la classe `Person` come segue:</span><span class="sxs-lookup"><span data-stu-id="e2a61-161">You can modify the `Person` class so as follows:</span></span>

[!code-csharp[A readonly auto implemented property](../../samples/snippets/csharp/properties/Person.cs#9)]

<span data-ttu-id="e2a61-162">Questa funzionalità viene in genere usata per l'inizializzazione delle raccolte esposte come proprietà di sola lettura:</span><span class="sxs-lookup"><span data-stu-id="e2a61-162">This feature is most commonly used for initializing collections that are exposed as read-only properties:</span></span>

```csharp
public class Measurements
{
    public ICollection<DataPoint> points { get; } = new List<DataPoint>();
}
```

### <a name="computed-properties"></a><span data-ttu-id="e2a61-163">Proprietà calcolate</span><span class="sxs-lookup"><span data-stu-id="e2a61-163">Computed properties</span></span>

<span data-ttu-id="e2a61-164">Una proprietà non si limita a restituire il valore di un campo membro.</span><span class="sxs-lookup"><span data-stu-id="e2a61-164">A property does not need to simply return the value of a member field.</span></span> <span data-ttu-id="e2a61-165">È possibile creare proprietà che restituiscono un valore calcolato.</span><span class="sxs-lookup"><span data-stu-id="e2a61-165">You can create properties that return a computed value.</span></span> <span data-ttu-id="e2a61-166">Espandere l'oggetto `Person` per restituire il nome completo, calcolato concatenando il nome e il cognome:</span><span class="sxs-lookup"><span data-stu-id="e2a61-166">Let's expand the `Person` object to return the full name, computed by concatenating the first and last names:</span></span>

[!code-csharp[A computed property](../../samples/snippets/csharp/properties/Person.cs#10)]

<span data-ttu-id="e2a61-167">L'esempio precedente usa la funzionalità di [interpolazione delle stringhe](./language-reference/tokens/interpolated.md) per creare la stringa formattata per il nome completo.</span><span class="sxs-lookup"><span data-stu-id="e2a61-167">The example above uses the [string interpolation](./language-reference/tokens/interpolated.md) feature to create the formatted string for the full name.</span></span>

<span data-ttu-id="e2a61-168">È anche possibile usare un *membro con corpo di espressione* che consente di creare la proprietà calcolata `FullName` in modo più conciso:</span><span class="sxs-lookup"><span data-stu-id="e2a61-168">You can also use an *expression-bodied member*, which provides a more succinct way to create the computed `FullName` property:</span></span>

[!code-csharp[A computed property using an expression bodied member](../../samples/snippets/csharp/properties/Person.cs#11)]

<span data-ttu-id="e2a61-169">I *membri con corpo di espressione* usano la sintassi delle *espressioni lambda* per definire i metodi che contengono una singola espressione.</span><span class="sxs-lookup"><span data-stu-id="e2a61-169">*Expression-bodied members* use the *lambda expression* syntax to define methods that contain a single expression.</span></span> <span data-ttu-id="e2a61-170">In questo caso, l'espressione restituisce il nome completo per l'oggetto person.</span><span class="sxs-lookup"><span data-stu-id="e2a61-170">Here, that expression returns the full name for the person object.</span></span>

### <a name="cached-evaluated-properties"></a><span data-ttu-id="e2a61-171">Proprietà con valutazione memorizzata nella cache</span><span class="sxs-lookup"><span data-stu-id="e2a61-171">Cached evaluated properties</span></span>

<span data-ttu-id="e2a61-172">È possibile unire il concetto di proprietà calcolata al concetto di archiviazione e creare una *proprietà con valutazione memorizzata nella cache*.</span><span class="sxs-lookup"><span data-stu-id="e2a61-172">You can mix the concept of a computed property with storage and create a *cached evaluated property*.</span></span>  <span data-ttu-id="e2a61-173">Ad esempio, è possibile aggiornare la proprietà `FullName` in modo che venga eseguita soltanto la formattazione della stringa al primo accesso:</span><span class="sxs-lookup"><span data-stu-id="e2a61-173">For example, you could update the `FullName` property so that the string formatting only happened the first time it was accessed:</span></span>

[!code-csharp[Caching the value of a computed property](../../samples/snippets/csharp/properties/Person.cs#12)]

<span data-ttu-id="e2a61-174">Il codice riportato sopra tuttavia contiene un bug.</span><span class="sxs-lookup"><span data-stu-id="e2a61-174">The above code contains a bug though.</span></span> <span data-ttu-id="e2a61-175">Se il codice aggiorna il valore della proprietà `FirstName` o `LastName`, il campo `fullName` valutato in precedenza non è valido.</span><span class="sxs-lookup"><span data-stu-id="e2a61-175">If code updates the value of either the `FirstName` or `LastName` property, the previously evaluated `fullName` field is invalid.</span></span> <span data-ttu-id="e2a61-176">Modificare le funzioni di accesso `set` della proprietà `FirstName` e `LastName` in modo che il campo `fullName` venga calcolato nuovamente:</span><span class="sxs-lookup"><span data-stu-id="e2a61-176">You modify the `set` accessors of the `FirstName` and `LastName` property so that the `fullName` field is calculated again:</span></span>

[!code-csharp[Invalidating the cache correctly](../../samples/snippets/csharp/properties/Person.cs#13)]

<span data-ttu-id="e2a61-177">La versione finale valuta la proprietà `FullName` solo quando necessario.</span><span class="sxs-lookup"><span data-stu-id="e2a61-177">This final version evaluates the `FullName` property only when needed.</span></span>
<span data-ttu-id="e2a61-178">Se è valida, viene usata la versione calcolata in precedenza.</span><span class="sxs-lookup"><span data-stu-id="e2a61-178">If the previously calculated version is valid, it's used.</span></span> <span data-ttu-id="e2a61-179">Se un'altra modifica dello stato annulla la validità della versione calcolata in precedenza, la versione verrà ricalcolata.</span><span class="sxs-lookup"><span data-stu-id="e2a61-179">If another state change invalidates the previously calculated version, it will be recalculated.</span></span> <span data-ttu-id="e2a61-180">Non è necessario che gli sviluppatori che usano questa classe siano a conoscenza dei dettagli dell'implementazione.</span><span class="sxs-lookup"><span data-stu-id="e2a61-180">Developers that use this class do not need to know the details of the implementation.</span></span> <span data-ttu-id="e2a61-181">Nessuna di queste modifiche interne ha effetto sull'uso dell'oggetto Person.</span><span class="sxs-lookup"><span data-stu-id="e2a61-181">None of these internal changes affect the use of the Person object.</span></span> <span data-ttu-id="e2a61-182">Questo è il motivo principale dell'uso delle proprietà per l'esposizione dei membri dati di un oggetto.</span><span class="sxs-lookup"><span data-stu-id="e2a61-182">That's the key reason for using Properties to expose data members of an object.</span></span>

### <a name="attaching-attributes-to-auto-implemented-properties"></a><span data-ttu-id="e2a61-183">Collegamento di attributi a proprietà implementate automaticamente</span><span class="sxs-lookup"><span data-stu-id="e2a61-183">Attaching attributes to auto-implemented properties</span></span>

<span data-ttu-id="e2a61-184">A partire da C# 7.3 è possibile collegare gli attributi campo al campo sottostante generato dal compilatore nelle proprietà implementate automaticamente.</span><span class="sxs-lookup"><span data-stu-id="e2a61-184">Beginning with C# 7.3, field attributes can be attached to the compiler generated backing field in auto-implemented properties.</span></span> <span data-ttu-id="e2a61-185">Si consideri ad esempio una revisione della classe `Person` che aggiunge una proprietà `Id` al valore intero univoco.</span><span class="sxs-lookup"><span data-stu-id="e2a61-185">For example, consider a revision to the `Person` class that adds a unique integer `Id` property.</span></span>
<span data-ttu-id="e2a61-186">Si scrive la proprietà `Id` usando una proprietà implementata automaticamente, ma la progettazione non esegue la chiamata per salvare in modo permanente la proprietà `Id`.</span><span class="sxs-lookup"><span data-stu-id="e2a61-186">You write the`Id` property using an auto-implemented property, but your design does not call for persisting the `Id` property.</span></span> <span data-ttu-id="e2a61-187">La classe <xref:System.NonSerializedAttribute> può essere collegata soltanto a campi, non a proprietà.</span><span class="sxs-lookup"><span data-stu-id="e2a61-187">The <xref:System.NonSerializedAttribute> can only be attached to fields, not properties.</span></span> <span data-ttu-id="e2a61-188">È possibile collegare la classe <xref:System.NonSerializedAttribute> al campo sottostante per la proprietà `Id` usando l'identificatore `field:` dell'attributo, come illustrato nell'esempio seguente:</span><span class="sxs-lookup"><span data-stu-id="e2a61-188">You can attach the <xref:System.NonSerializedAttribute> to the backing field for the `Id` property by using the `field:` specifier on the attribute, as shown in the following example:</span></span>

[!code-csharp[Attaching attributes to a backing field](../../samples/snippets/csharp/properties/Person.cs#14)]

<span data-ttu-id="e2a61-189">Questa tecnica funziona con qualsiasi attributo collegato al campo sottostante nella proprietà implementate automaticamente.</span><span class="sxs-lookup"><span data-stu-id="e2a61-189">This technique works for any attribute you attach to the backing field on the auto-implemented property.</span></span>

### <a name="implementing-inotifypropertychanged"></a><span data-ttu-id="e2a61-190">Implementazione di NotifyPropertyChanged</span><span class="sxs-lookup"><span data-stu-id="e2a61-190">Implementing INotifyPropertyChanged</span></span>

<span data-ttu-id="e2a61-191">Uno scenario finale in cui è necessario scrivere codice nella funzione di accesso di una proprietà è quello finalizzato al supporto dell'interfaccia <xref:System.ComponentModel.INotifyPropertyChanged> usata per inviare ai client di data binding la notifica della modifica di un valore.</span><span class="sxs-lookup"><span data-stu-id="e2a61-191">A final scenario where you need to write code in a property accessor is to support the <xref:System.ComponentModel.INotifyPropertyChanged> interface used to notify data binding clients that a value has changed.</span></span> <span data-ttu-id="e2a61-192">Quando viene modificato il valore di una proprietà, l'oggetto genera l'evento <xref:System.ComponentModel.INotifyPropertyChanged.PropertyChanged?displayProperty=nameWithType> per indicare la modifica.</span><span class="sxs-lookup"><span data-stu-id="e2a61-192">When the value of a property changes, the object raises the <xref:System.ComponentModel.INotifyPropertyChanged.PropertyChanged?displayProperty=nameWithType> event to indicate the change.</span></span> <span data-ttu-id="e2a61-193">Le librerie di data binding aggiornano a loro volta gli elementi visualizzati in base alla modifica.</span><span class="sxs-lookup"><span data-stu-id="e2a61-193">The data binding libraries, in turn, update display elements based on that change.</span></span> <span data-ttu-id="e2a61-194">Il codice seguente illustra come implementare `INotifyPropertyChanged` per la proprietà `FirstName` della classe person.</span><span class="sxs-lookup"><span data-stu-id="e2a61-194">The code below shows how you would implement `INotifyPropertyChanged` for the `FirstName` property of this person class.</span></span>

[!code-csharp[invalidating the cache correctly](../../samples/snippets/csharp/properties/Person.cs#15)]

<span data-ttu-id="e2a61-195">L'operatore `?.` è chiamato *operatore condizionale Null*.</span><span class="sxs-lookup"><span data-stu-id="e2a61-195">The `?.` operator is called the *null conditional operator*.</span></span> <span data-ttu-id="e2a61-196">L'operatore cerca un riferimento Null prima di eseguire la valutazione della parte destra dell'operatore.</span><span class="sxs-lookup"><span data-stu-id="e2a61-196">It checks for a null reference before evaluating the right side of the operator.</span></span> <span data-ttu-id="e2a61-197">Se non vengono trovati sottoscrittori dell'evento `PropertyChanged`, il codice che genera l'evento non viene eseguito.</span><span class="sxs-lookup"><span data-stu-id="e2a61-197">The end result is that if there are no subscribers to the `PropertyChanged` event, the code to raise the event doesn't execute.</span></span> <span data-ttu-id="e2a61-198">In questo caso, verrà generato `NullReferenceException` senza eseguire il controllo.</span><span class="sxs-lookup"><span data-stu-id="e2a61-198">It would throw a `NullReferenceException` without this check in that case.</span></span> <span data-ttu-id="e2a61-199">Per ulteriori informazioni, vedere [`events`](events-overview.md).</span><span class="sxs-lookup"><span data-stu-id="e2a61-199">For more information, see [`events`](events-overview.md).</span></span> <span data-ttu-id="e2a61-200">Questo esempio usa anche il nuovo operatore `nameof` per convertire il simbolo del nome della proprietà nella rappresentazione di testo.</span><span class="sxs-lookup"><span data-stu-id="e2a61-200">This example also uses the new `nameof` operator to convert from the property name symbol to its text representation.</span></span>
<span data-ttu-id="e2a61-201">L'uso di `nameof` può ridurre gli errori nel caso in cui il nome della proprietà sia stato digitato erroneamente.</span><span class="sxs-lookup"><span data-stu-id="e2a61-201">Using `nameof` can reduce errors where you have mistyped the name of the property.</span></span>

<span data-ttu-id="e2a61-202">L'implementazione di <xref:System.ComponentModel.INotifyPropertyChanged> è quindi un esempio di caso in cui è possibile scrivere codice nelle funzioni di accesso per supportare gli scenari necessari.</span><span class="sxs-lookup"><span data-stu-id="e2a61-202">Again, implementing <xref:System.ComponentModel.INotifyPropertyChanged> is an example of a case where you can write code in your accessors to support the scenarios you need.</span></span>

## <a name="summing-up"></a><span data-ttu-id="e2a61-203">Riepilogo</span><span class="sxs-lookup"><span data-stu-id="e2a61-203">Summing up</span></span>

<span data-ttu-id="e2a61-204">Le proprietà sono una forma di campi intelligenti in una classe o un oggetto.</span><span class="sxs-lookup"><span data-stu-id="e2a61-204">Properties are a form of smart fields in a class or object.</span></span> <span data-ttu-id="e2a61-205">All'esterno dell'oggetto, vengono visualizzate come campi dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="e2a61-205">From outside the object, they appear like fields in the object.</span></span> <span data-ttu-id="e2a61-206">Tuttavia, le proprietà possono essere implementate usando l'intera gamma di funzionalità di C#.</span><span class="sxs-lookup"><span data-stu-id="e2a61-206">However, properties can be implemented using the full palette of C# functionality.</span></span>
<span data-ttu-id="e2a61-207">È possibile specificare la convalida, un'accessibilità diversa, la valutazione lazy o tutti i requisiti necessari negli scenari.</span><span class="sxs-lookup"><span data-stu-id="e2a61-207">You can provide validation, different accessibility, lazy evaluation, or any requirements your scenarios need.</span></span>
