---
title: Nozioni di base sugli alberi delle espressioni
description: Informazioni sugli alberi delle espressioni e sulla loro utilità nella conversione degli algoritmi per l'esecuzione esterna e nell'analisi del codice prima dell'esecuzione.
ms.date: 06/20/2016
ms.technology: csharp-advanced-concepts
ms.assetid: bbcdd339-86eb-4ae5-9911-4c214a39a92d
ms.openlocfilehash: 12093e9c9246c87cc5ea3aedaca6ba34acacce4d
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 03/14/2020
ms.locfileid: "73036998"
---
# <a name="expression-trees-explained"></a><span data-ttu-id="21beb-103">Nozioni di base sugli alberi delle espressioni</span><span class="sxs-lookup"><span data-stu-id="21beb-103">Expression Trees Explained</span></span>

[<span data-ttu-id="21beb-104">Precedente -- Panoramica</span><span class="sxs-lookup"><span data-stu-id="21beb-104">Previous -- Overview</span></span>](expression-trees.md)

<span data-ttu-id="21beb-105">Un albero delle espressioni è una struttura dei dati che definisce il codice.</span><span class="sxs-lookup"><span data-stu-id="21beb-105">An Expression Tree is a data structure that defines code.</span></span> <span data-ttu-id="21beb-106">Si basa sulle stesse strutture usate da un compilatore per analizzare il codice e generare l'output compilato.</span><span class="sxs-lookup"><span data-stu-id="21beb-106">They are based on the same structures that a compiler uses to analyze code and generate the compiled output.</span></span> <span data-ttu-id="21beb-107">Nel corso di questa esercitazione si noterà una certa similarità tra gli alberi delle espressioni e i tipi usati nelle API di Roslyn per compilare [analizzatori e correzioni di codice](https://github.com/dotnet/roslyn-analyzers).</span><span class="sxs-lookup"><span data-stu-id="21beb-107">As you read through this tutorial, you will notice quite a bit of similarity between Expression Trees and the types used in the Roslyn APIs to build [Analyzers and CodeFixes](https://github.com/dotnet/roslyn-analyzers).</span></span>
<span data-ttu-id="21beb-108">(Analyzers e CodeFixes sono pacchetti NuGet che eseguono l'analisi statica sul codice e possono suggerire potenziali correzioni per uno sviluppatore.) I concetti sono simili e il risultato finale è una struttura di dati che consente di esaminare il codice sorgente in modo significativo.</span><span class="sxs-lookup"><span data-stu-id="21beb-108">(Analyzers and CodeFixes are NuGet packages that perform static analysis on code and can suggest potential fixes for a developer.) The concepts are similar, and the end result is a data structure that allows examination of the source code in a meaningful way.</span></span> <span data-ttu-id="21beb-109">Gli alberi delle espressioni si basano tuttavia su un set di classi e API completamente diverso dalle API di Roslyn.</span><span class="sxs-lookup"><span data-stu-id="21beb-109">However, Expression Trees are based on a totally different set of classes and APIs than the Roslyn APIs.</span></span>

<span data-ttu-id="21beb-110">Si osservi l'esempio seguente.</span><span class="sxs-lookup"><span data-stu-id="21beb-110">Let's look at a simple example.</span></span>
<span data-ttu-id="21beb-111">Ecco una riga di codice:</span><span class="sxs-lookup"><span data-stu-id="21beb-111">Here's a line of code:</span></span>

```csharp
var sum = 1 + 2;
```

<span data-ttu-id="21beb-112">Analizzando la riga come se fosse un albero delle espressioni, si nota che l'albero contiene numerosi nodi.</span><span class="sxs-lookup"><span data-stu-id="21beb-112">If you were to analyze this as an expression tree, the tree contains several nodes.</span></span>
<span data-ttu-id="21beb-113">Il nodo più esterno è un'istruzione di dichiarazione di variabile con assegnazione (`var sum = 1 + 2;`). Tale nodo contiene più nodi figlio: una dichiarazione di variabile, un operatore di assegnazione e un'espressione che rappresenta la parte a destra del segno di uguale.</span><span class="sxs-lookup"><span data-stu-id="21beb-113">The outermost node is a variable declaration statement with assignment (`var sum = 1 + 2;`) That outermost node contains several child nodes: a variable declaration, an assignment operator, and an expression representing the right hand side of the equals sign.</span></span> <span data-ttu-id="21beb-114">Questa espressione è a sua volta suddivisa in espressioni che rappresentano l'operazione di addizione e gli operandi sinistro e destro dell'addizione.</span><span class="sxs-lookup"><span data-stu-id="21beb-114">That expression is further subdivided into expressions that represent the addition operation, and left and right operands of the addition.</span></span>

<span data-ttu-id="21beb-115">Di seguito vengono esaminate in dettaglio le espressioni che costituiscono la parte a destra del segno di uguale.</span><span class="sxs-lookup"><span data-stu-id="21beb-115">Let's drill down a bit more into the expressions that make up the right side of the equals sign.</span></span>
<span data-ttu-id="21beb-116">L'espressione è `1 + 2`.</span><span class="sxs-lookup"><span data-stu-id="21beb-116">The expression is `1 + 2`.</span></span> <span data-ttu-id="21beb-117">Si tratta di un'espressione binaria.</span><span class="sxs-lookup"><span data-stu-id="21beb-117">That's a binary expression.</span></span> <span data-ttu-id="21beb-118">Nello specifico, è un'espressione di addizione binaria.</span><span class="sxs-lookup"><span data-stu-id="21beb-118">More specifically, it's a binary addition expression.</span></span> <span data-ttu-id="21beb-119">Un'espressione di addizione binaria ha due figli, che rappresentano i nodi sinistro e destro dell'espressione di addizione.</span><span class="sxs-lookup"><span data-stu-id="21beb-119">A binary addition expression has two children, representing the left and right nodes of the addition expression.</span></span> <span data-ttu-id="21beb-120">In questo caso, entrambi i nodi sono espressioni costanti: l'operando sinistro è il valore `1` e l'operando destro è il valore `2`.</span><span class="sxs-lookup"><span data-stu-id="21beb-120">Here, both nodes are constant expressions: The left operand is the value `1`, and the right operand is the value `2`.</span></span>

<span data-ttu-id="21beb-121">A livello visivo, l'intera istruzione è una struttura ad albero: è possibile iniziare dal nodo radice e passare a ogni nodo nell'albero per visualizzare il codice che costituisce l'istruzione:</span><span class="sxs-lookup"><span data-stu-id="21beb-121">Visually, the entire statement is a tree: You could start at the root node, and travel to each node in the tree to see the code that makes up the statement:</span></span>

- <span data-ttu-id="21beb-122">Istruzione di dichiarazione di variabili con assegnazione (`var sum = 1 + 2;`)</span><span class="sxs-lookup"><span data-stu-id="21beb-122">Variable declaration statement with assignment (`var sum = 1 + 2;`)</span></span>
  - <span data-ttu-id="21beb-123">Dichiarazione di variabili implicite (`var sum`)</span><span class="sxs-lookup"><span data-stu-id="21beb-123">Implicit variable type declaration (`var sum`)</span></span>
    - <span data-ttu-id="21beb-124">Parola chiave di variabile implicita (`var`)</span><span class="sxs-lookup"><span data-stu-id="21beb-124">Implicit var keyword (`var`)</span></span>
    - <span data-ttu-id="21beb-125">Dichiarazione del nome di variabile (`sum`)</span><span class="sxs-lookup"><span data-stu-id="21beb-125">Variable name declaration (`sum`)</span></span>
  - <span data-ttu-id="21beb-126">Operatore di assegnazione (`=`)</span><span class="sxs-lookup"><span data-stu-id="21beb-126">Assignment operator (`=`)</span></span>
  - <span data-ttu-id="21beb-127">Espressione di addizione binaria (`1 + 2`)</span><span class="sxs-lookup"><span data-stu-id="21beb-127">Binary addition expression (`1 + 2`)</span></span>
    - <span data-ttu-id="21beb-128">Operando sinistro (`1`)</span><span class="sxs-lookup"><span data-stu-id="21beb-128">Left operand (`1`)</span></span>
    - <span data-ttu-id="21beb-129">Operatore di addizione (`+`)</span><span class="sxs-lookup"><span data-stu-id="21beb-129">Addition operator (`+`)</span></span>
    - <span data-ttu-id="21beb-130">Operando destro (`2`)</span><span class="sxs-lookup"><span data-stu-id="21beb-130">Right operand (`2`)</span></span>

<span data-ttu-id="21beb-131">Tutto ciò può apparire complicato, ma è molto funzionale.</span><span class="sxs-lookup"><span data-stu-id="21beb-131">This may look complicated, but it is very powerful.</span></span> <span data-ttu-id="21beb-132">Seguendo la stessa procedura, è possibile scomporre espressioni molto più complesse.</span><span class="sxs-lookup"><span data-stu-id="21beb-132">Following the same process, you can decompose much more complicated expressions.</span></span> <span data-ttu-id="21beb-133">Si consideri l'espressione seguente:</span><span class="sxs-lookup"><span data-stu-id="21beb-133">Consider this expression:</span></span>

```csharp
var finalAnswer = this.SecretSauceFunction(
    currentState.createInterimResult(), currentState.createSecondValue(1, 2),
    decisionServer.considerFinalOptions("hello")) +
    MoreSecretSauce('A', DateTime.Now, true);
```

<span data-ttu-id="21beb-134">Anche l'espressione precedente è una dichiarazione di variabile con un'assegnazione.</span><span class="sxs-lookup"><span data-stu-id="21beb-134">The expression above is also a variable declaration with an assignment.</span></span>
<span data-ttu-id="21beb-135">In questo caso, il lato destro dell'assegnazione è una struttura ad albero molto più complessa.</span><span class="sxs-lookup"><span data-stu-id="21beb-135">In this instance, the right hand side of the assignment is a much more complicated tree.</span></span>
<span data-ttu-id="21beb-136">Senza procedere con la scomposizione dell'espressione, si considerino i diversi nodi.</span><span class="sxs-lookup"><span data-stu-id="21beb-136">I'm not going to decompose this expression, but consider what the different nodes might be.</span></span> <span data-ttu-id="21beb-137">Questi includono chiamate al metodo che usano l'oggetto corrente come un ricevitore, una che include un ricevitore `this` esplicito, una che non lo usa.</span><span class="sxs-lookup"><span data-stu-id="21beb-137">There are method calls using the current object as a receiver, one that has an explicit `this` receiver, one that does not.</span></span> <span data-ttu-id="21beb-138">Sono presenti chiamate al metodo che usano altri oggetti ricevitore, e argomenti costanti di diversi tipi.</span><span class="sxs-lookup"><span data-stu-id="21beb-138">There are method calls using other receiver objects, there are constant arguments of different types.</span></span> <span data-ttu-id="21beb-139">Infine, è presente un operatore di addizione binaria.</span><span class="sxs-lookup"><span data-stu-id="21beb-139">And finally, there is a binary addition operator.</span></span> <span data-ttu-id="21beb-140">A seconda del tipo restituito di `SecretSauceFunction()` o `MoreSecretSauce()`, l'operatore di addizione binaria può rappresentare una chiamata al metodo a un operatore di addizione con override, risolto in una chiamata al metodo statico dell'operatore di addizione binaria definito per una classe.</span><span class="sxs-lookup"><span data-stu-id="21beb-140">Depending on the return type of `SecretSauceFunction()` or `MoreSecretSauce()`, that binary addition operator may be a method call to an overridden addition operator, resolving to a static method call to the binary addition operator defined for a class.</span></span>

<span data-ttu-id="21beb-141">Nonostante l'apparente complessità, l'espressione precedente crea una struttura ad albero semplice da esplorare quanto il primo esempio.</span><span class="sxs-lookup"><span data-stu-id="21beb-141">Despite this perceived complexity, the expression above creates a tree structure that can be navigated as easily as the first sample.</span></span> <span data-ttu-id="21beb-142">È possibile continuare ad attraversare i nodi figlio per individuare i nodi foglia nell'espressione.</span><span class="sxs-lookup"><span data-stu-id="21beb-142">You can keep traversing child nodes to find leaf nodes in the expression.</span></span> <span data-ttu-id="21beb-143">I nodi padre includono riferimenti ai propri elementi figlio e ogni nodo dispone di una proprietà che descrive di che tipo di nodo si tratta.</span><span class="sxs-lookup"><span data-stu-id="21beb-143">Parent nodes will have references to their children, and each node has a property that describes what kind of node it is.</span></span>

<span data-ttu-id="21beb-144">La struttura di albero delle espressioni è molto coerente.</span><span class="sxs-lookup"><span data-stu-id="21beb-144">The structure of an expression tree is very consistent.</span></span> <span data-ttu-id="21beb-145">Dopo aver appreso le nozioni di base, è possibile comprendere anche il codice più complesso quando questo viene rappresentato come un albero delle espressioni.</span><span class="sxs-lookup"><span data-stu-id="21beb-145">Once you've learned the basics, you can understand even the most complex code when it is represented as an expression tree.</span></span> <span data-ttu-id="21beb-146">L'eleganza nella struttura dei dati spiega come il compilatore C# possa analizzare anche i programmi C# più complessi e creare l'output corretto a partire da un codice sorgente così complesso.</span><span class="sxs-lookup"><span data-stu-id="21beb-146">The elegance in the data structure explains how the C# compiler can analyze the most complex C# programs and create proper output from that complicated source code.</span></span>

<span data-ttu-id="21beb-147">Dopo avere acquisito familiarità con la struttura degli alberi delle espressioni, si noterà che conoscenze acquisite consentono di operare anche con scenari avanzati.</span><span class="sxs-lookup"><span data-stu-id="21beb-147">Once you become familiar with the structure of expression trees, you will find that knowledge you've gained quickly enables you to work with many more and more advanced scenarios.</span></span> <span data-ttu-id="21beb-148">Gli alberi delle espressioni hanno capacità straordinarie.</span><span class="sxs-lookup"><span data-stu-id="21beb-148">There is incredible power to expression trees.</span></span>

<span data-ttu-id="21beb-149">Oltre alla conversione degli algoritmi da eseguire in altri ambienti, essi possono essere usati per semplificare la scrittura di algoritmi che verificano il codice prima che venga eseguito.</span><span class="sxs-lookup"><span data-stu-id="21beb-149">In addition to translating algorithms to execute in other environments, expression trees can be used to make it easier to write algorithms that inspect code before executing it.</span></span> <span data-ttu-id="21beb-150">È possibile scrivere un metodo i cui argomenti sono espressioni e quindi esaminare tali espressioni prima di eseguire il codice.</span><span class="sxs-lookup"><span data-stu-id="21beb-150">You can write a method whose arguments are expressions and then examine those expressions before executing the code.</span></span> <span data-ttu-id="21beb-151">L'albero delle espressioni è una rappresentazione completa del codice e consente quindi di visualizzare i valori di qualsiasi sottoespressione,</span><span class="sxs-lookup"><span data-stu-id="21beb-151">The Expression Tree is a full representation of the code: you can see values of any sub-expression.</span></span>
<span data-ttu-id="21beb-152">i nomi dei metodi e delle proprietà</span><span class="sxs-lookup"><span data-stu-id="21beb-152">You can see method and property names.</span></span> <span data-ttu-id="21beb-153">e il valore di qualsiasi espressione costante.</span><span class="sxs-lookup"><span data-stu-id="21beb-153">You can see the value of any constant expressions.</span></span>
<span data-ttu-id="21beb-154">È anche possibile convertire un albero delle espressioni in un delegato eseguibile, ed eseguire il codice.</span><span class="sxs-lookup"><span data-stu-id="21beb-154">You can also convert an expression tree into an executable delegate, and execute the code.</span></span>

<span data-ttu-id="21beb-155">Le API degli alberi delle espressioni consentono di creare strutture che rappresentano praticamente qualsiasi costrutto di codice valido.</span><span class="sxs-lookup"><span data-stu-id="21beb-155">The APIs for Expression Trees enable you to create trees that represent almost any valid code construct.</span></span> <span data-ttu-id="21beb-156">Tuttavia, per evitare complicazioni eccessive, in un albero delle espressioni non è possibile creare alcuni idiomi di C#.</span><span class="sxs-lookup"><span data-stu-id="21beb-156">However, to keep things as simple as possible, some C# idioms cannot be created in an expression tree.</span></span> <span data-ttu-id="21beb-157">Ne sono esempi le espressioni asincrone che usano le delle parole chiave `async` e `await`.</span><span class="sxs-lookup"><span data-stu-id="21beb-157">One example is asynchronous expressions (using the `async` and `await` keywords).</span></span> <span data-ttu-id="21beb-158">Se sono necessari gli algoritmi asincroni, modificare direttamente gli oggetti `Task` invece di affidarsi al supporto del compilatore.</span><span class="sxs-lookup"><span data-stu-id="21beb-158">If your needs require asynchronous algorithms, you would need to manipulate the `Task` objects directly, rather than rely on the compiler support.</span></span> <span data-ttu-id="21beb-159">Un altro metodo è la creazione dei cicli.</span><span class="sxs-lookup"><span data-stu-id="21beb-159">Another is in creating loops.</span></span> <span data-ttu-id="21beb-160">In genere, i cicli vengono creati usando i cicli `for`, `foreach`, `while` o `do`.</span><span class="sxs-lookup"><span data-stu-id="21beb-160">Typically, you create these by using `for`, `foreach`, `while` or `do` loops.</span></span> <span data-ttu-id="21beb-161">Come si vedrà [più avanti in questa serie](expression-trees-building.md), le API degli alberi delle espressioni supportano una singola espressione Loop, con le espressioni `break` e `continue` che controllano il ciclo di ripetizione.</span><span class="sxs-lookup"><span data-stu-id="21beb-161">As you'll see [later in this series](expression-trees-building.md), the APIs for expression trees support a single loop expression, with `break` and `continue` expressions that control repeating the loop.</span></span>

<span data-ttu-id="21beb-162">Non è possibile modificare un albero delle espressioni.</span><span class="sxs-lookup"><span data-stu-id="21beb-162">The one thing you can't do is modify an expression tree.</span></span>  <span data-ttu-id="21beb-163">Sono infatti strutture dei dati immutabili.</span><span class="sxs-lookup"><span data-stu-id="21beb-163">Expression Trees are immutable data structures.</span></span> <span data-ttu-id="21beb-164">Se si vuole modificare un albero delle espressioni, è necessario creare un nuovo albero che sia una copia dell'originale e che contenga le modifiche desiderate.</span><span class="sxs-lookup"><span data-stu-id="21beb-164">If you want to mutate (change) an expression tree, you must create a new tree that is a copy of the original, but with your desired changes.</span></span>

[<span data-ttu-id="21beb-165">Successivo -- Tipi di framework che supportano alberi delle espressioni</span><span class="sxs-lookup"><span data-stu-id="21beb-165">Next -- Framework Types Supporting Expression Trees</span></span>](expression-classes.md)
