---
title: Classi generiche - Guida per programmatori C#
ms.date: 07/20/2015
helpviewer_keywords:
- C# language, generic classes
- generics [C#], classes
ms.assetid: 27d6f256-cd61-41e3-bc6e-b990a53b0224
ms.openlocfilehash: 13a1ca2d85be0c61b9d0f09c0c5cb670b49f5625
ms.sourcegitcommit: 5f236cd78cf09593c8945a7d753e0850e96a0b80
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 01/07/2020
ms.locfileid: "75703221"
---
# <a name="generic-classes-c-programming-guide"></a><span data-ttu-id="4548b-102">Classi generiche (Guida per programmatori C#)</span><span class="sxs-lookup"><span data-stu-id="4548b-102">Generic Classes (C# Programming Guide)</span></span>
<span data-ttu-id="4548b-103">Le classi generiche incapsulano operazioni che non sono specifiche di un determinato tipo di dati.</span><span class="sxs-lookup"><span data-stu-id="4548b-103">Generic classes encapsulate operations that are not specific to a particular data type.</span></span> <span data-ttu-id="4548b-104">L'uso più comune per le classi generiche è con raccolte come elenchi collegati, tabelle hash, stack, code, alberi e così via.</span><span class="sxs-lookup"><span data-stu-id="4548b-104">The most common use for generic classes is with collections like linked lists, hash tables, stacks, queues, trees, and so on.</span></span> <span data-ttu-id="4548b-105">Le operazioni come l'aggiunta e la rimozione di elementi dalla raccolta vengono eseguite praticamente allo stesso modo, indipendentemente dal tipo dei dati archiviati.</span><span class="sxs-lookup"><span data-stu-id="4548b-105">Operations such as adding and removing items from the collection are performed in basically the same way regardless of the type of data being stored.</span></span>  
  
 <span data-ttu-id="4548b-106">Per la maggior parte degli scenari che richiedono classi di raccolta, l'approccio consigliato consiste nell'usare quelle disponibili nella libreria di classi .NET.</span><span class="sxs-lookup"><span data-stu-id="4548b-106">For most scenarios that require collection classes, the recommended approach is to use the ones provided in the .NET class library.</span></span> <span data-ttu-id="4548b-107">Per altre informazioni sull'uso di queste classi, vedere [Generic Collections in .NET](../../../standard/generics/collections.md) (Raccolte generiche in .NET).</span><span class="sxs-lookup"><span data-stu-id="4548b-107">For more information about using these classes, see [Generic Collections in .NET](../../../standard/generics/collections.md).</span></span>  
  
 <span data-ttu-id="4548b-108">Normalmente, per creare classi generiche è possibile iniziare da una classe concreta esistente, modificando quindi i tipi in parametri di tipo uno per volta fino a raggiungere l'equilibrio ottimale tra generalizzazione e usabilità.</span><span class="sxs-lookup"><span data-stu-id="4548b-108">Typically, you create generic classes by starting with an existing concrete class, and changing types into type parameters one at a time until you reach the optimal balance of generalization and usability.</span></span> <span data-ttu-id="4548b-109">Ecco alcuni aspetti importanti di cui tenere conto quando si creano classi generiche personalizzate:</span><span class="sxs-lookup"><span data-stu-id="4548b-109">When creating your own generic classes, important considerations include the following:</span></span>  
  
- <span data-ttu-id="4548b-110">Tipi da generalizzare in parametri di tipo.</span><span class="sxs-lookup"><span data-stu-id="4548b-110">Which types to generalize into type parameters.</span></span>  
  
     <span data-ttu-id="4548b-111">Di norma, maggiore è il numero di tipi che è possibile parametrizzare, più flessibile e riutilizzabile sarà il codice.</span><span class="sxs-lookup"><span data-stu-id="4548b-111">As a rule, the more types you can parameterize, the more flexible and reusable your code becomes.</span></span> <span data-ttu-id="4548b-112">Tuttavia, una generalizzazione eccessiva può creare codice difficile da leggere e comprendere per gli altri sviluppatori.</span><span class="sxs-lookup"><span data-stu-id="4548b-112">However, too much generalization can create code that is difficult for other developers to read or understand.</span></span>  
  
- <span data-ttu-id="4548b-113">Vincoli, se presenti, da applicare ai parametri di tipo. Vedere [Vincoli sui parametri di tipo](./constraints-on-type-parameters.md).</span><span class="sxs-lookup"><span data-stu-id="4548b-113">What constraints, if any, to apply to the type parameters (See [Constraints on Type Parameters](./constraints-on-type-parameters.md)).</span></span>  
  
     <span data-ttu-id="4548b-114">Una buona regola consiste nell'applicare il numero massimo di vincoli possibile, ma che permetta di continuare a gestire tutti i tipi necessari.</span><span class="sxs-lookup"><span data-stu-id="4548b-114">A good rule is to apply the maximum constraints possible that will still let you handle the types you must handle.</span></span> <span data-ttu-id="4548b-115">Se, ad esempio, la classe generica è destinata solo all'uso con tipi riferimento, applicare il vincolo di classe.</span><span class="sxs-lookup"><span data-stu-id="4548b-115">For example, if you know that your generic class is intended for use only with reference types, apply the class constraint.</span></span> <span data-ttu-id="4548b-116">In questo modo, si eviterà l'uso indesiderato della classe con tipi valore e sarà possibile usare l'operatore `as` in `T` e verificare la presenza di valori null.</span><span class="sxs-lookup"><span data-stu-id="4548b-116">That will prevent unintended use of your class with value types, and will enable you to use the `as` operator on `T`, and check for null values.</span></span>  
  
- <span data-ttu-id="4548b-117">Se suddividere il comportamento generico in classi e sottoclassi base.</span><span class="sxs-lookup"><span data-stu-id="4548b-117">Whether to factor generic behavior into base classes and subclasses.</span></span>  
  
     <span data-ttu-id="4548b-118">Poiché le classi generiche possono fungere da classi base, valgono le stesse considerazioni di progettazione relative alle classi non generiche.</span><span class="sxs-lookup"><span data-stu-id="4548b-118">Because generic classes can serve as base classes, the same design considerations apply here as with non-generic classes.</span></span> <span data-ttu-id="4548b-119">Vedere le regole sull'ereditarietà da classi base generiche più avanti in questo argomento.</span><span class="sxs-lookup"><span data-stu-id="4548b-119">See the rules about inheriting from generic base classes later in this topic.</span></span>  
  
- <span data-ttu-id="4548b-120">Se implementare una o più interfacce generiche.</span><span class="sxs-lookup"><span data-stu-id="4548b-120">Whether to implement one or more generic interfaces.</span></span>  
  
     <span data-ttu-id="4548b-121">Se, ad esempio, si progetta una classe che verrà usata per creare elementi in una raccolta basata su generics, potrebbe essere necessario implementare un'interfaccia come <xref:System.IComparable%601>, dove `T` è il tipo della classe.</span><span class="sxs-lookup"><span data-stu-id="4548b-121">For example, if you are designing a class that will be used to create items in a generics-based collection, you may have to implement an interface such as <xref:System.IComparable%601> where `T` is the type of your class.</span></span>  
  
 <span data-ttu-id="4548b-122">Per un esempio di una classe generica semplice, vedere [Introduzione ai generics](./index.md).</span><span class="sxs-lookup"><span data-stu-id="4548b-122">For an example of a simple generic class, see [Introduction to Generics](./index.md).</span></span>  
  
 <span data-ttu-id="4548b-123">Le regole per i parametri di tipo e i vincoli hanno diverse implicazioni per il comportamento delle classi generiche, in particolare riguardo a ereditarietà e accessibilità dei membri.</span><span class="sxs-lookup"><span data-stu-id="4548b-123">The rules for type parameters and constraints have several implications for generic class behavior, especially regarding inheritance and member accessibility.</span></span> <span data-ttu-id="4548b-124">Prima di continuare, è utile comprendere alcuni termini.</span><span class="sxs-lookup"><span data-stu-id="4548b-124">Before proceeding, you should understand some terms.</span></span> <span data-ttu-id="4548b-125">Per una classe generica, il codice client `Node<T>,` può fare riferimento alla classe specificando un argomento tipo, per creare un tipo costruito chiuso (`Node<int>`).</span><span class="sxs-lookup"><span data-stu-id="4548b-125">For a generic class `Node<T>,` client code can reference the class either by specifying a type argument, to create a closed constructed type (`Node<int>`).</span></span> <span data-ttu-id="4548b-126">In alternativa, può lasciare il parametro di tipo non specificato, ad esempio quando si specifica una classe base generica, per creare un tipo costruito aperto (`Node<T>`).</span><span class="sxs-lookup"><span data-stu-id="4548b-126">Alternatively, it can leave the type parameter unspecified, for example when you specify a generic base class, to create an open constructed type (`Node<T>`).</span></span> <span data-ttu-id="4548b-127">Le classi generiche possono ereditare da classi concrete, classi costruite chiuse o classi base costruite aperte:</span><span class="sxs-lookup"><span data-stu-id="4548b-127">Generic classes can inherit from concrete, closed constructed, or open constructed base classes:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#16](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideGenerics/CS/Generics.cs#16)]  
  
 <span data-ttu-id="4548b-128">Le classi non generiche, ovvero concrete, possono ereditare da classi base costruite chiuse, ma non da classi costruite aperte o da parametri di tipo, perché in fase di esecuzione il codice client non può in alcun modo specificare l'argomento tipo necessario per creare un'istanza della classe base.</span><span class="sxs-lookup"><span data-stu-id="4548b-128">Non-generic, in other words, concrete, classes can inherit from closed constructed base classes, but not from open constructed classes or from type parameters because there is no way at run time for client code to supply the type argument required to instantiate the base class.</span></span>  
  
 [!code-csharp[csProgGuideGenerics#17](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideGenerics/CS/Generics.cs#17)]  
  
 <span data-ttu-id="4548b-129">Le classi generiche che ereditano da tipi costruiti aperti devono specificare gli argomenti tipo per qualsiasi parametro di tipo di classe base che non viene condiviso dalla classe che eredita, come mostrato nel codice seguente:</span><span class="sxs-lookup"><span data-stu-id="4548b-129">Generic classes that inherit from open constructed types must supply type arguments for any base class type parameters that are not shared by the inheriting class, as demonstrated in the following code:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#18](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideGenerics/CS/Generics.cs#18)]  
  
 <span data-ttu-id="4548b-130">Le classi generiche che ereditano da tipi costruiti aperti devono specificare vincoli che implichino o siano un superset dei vincoli sul tipo di base:</span><span class="sxs-lookup"><span data-stu-id="4548b-130">Generic classes that inherit from open constructed types must specify constraints that are a superset of, or imply, the constraints on the base type:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#19](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideGenerics/CS/Generics.cs#19)]  
  
 <span data-ttu-id="4548b-131">I tipi generici possono usare più parametri di tipo e vincoli, in questo modo:</span><span class="sxs-lookup"><span data-stu-id="4548b-131">Generic types can use multiple type parameters and constraints, as follows:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#20](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideGenerics/CS/Generics.cs#20)]  
  
 <span data-ttu-id="4548b-132">I tipo costruiti aperti e i tipi costruiti chiusi possono essere usati come parametri di metodo:</span><span class="sxs-lookup"><span data-stu-id="4548b-132">Open constructed and closed constructed types can be used as method parameters:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#21](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideGenerics/CS/Generics.cs#21)]  
  
 <span data-ttu-id="4548b-133">Se una classe generica implementa un'interfaccia, è possibile eseguire il cast di tutte le istanze della classe all'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="4548b-133">If a generic class implements an interface, all instances of that class can be cast to that interface.</span></span>  
  
 <span data-ttu-id="4548b-134">Le classi generiche sono invariabili.</span><span class="sxs-lookup"><span data-stu-id="4548b-134">Generic classes are invariant.</span></span> <span data-ttu-id="4548b-135">In altri termini, se un parametro di input specifica un oggetto `List<BaseClass>`, se si prova a specificare un oggetto `List<DerivedClass>`, viene restituito un errore in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="4548b-135">In other words, if an input parameter specifies a `List<BaseClass>`, you will get a compile-time error if you try to provide a `List<DerivedClass>`.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="4548b-136">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="4548b-136">See also</span></span>

- <xref:System.Collections.Generic>
- [<span data-ttu-id="4548b-137">Guida per programmatori C#</span><span class="sxs-lookup"><span data-stu-id="4548b-137">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="4548b-138">Generics</span><span class="sxs-lookup"><span data-stu-id="4548b-138">Generics</span></span>](./index.md)
- <span data-ttu-id="4548b-139">[Saving the State of Enumerators](https://blogs.msdn.microsoft.com/wesdyer/2006/01/13/saving-the-state-of-enumerators/) (Salvataggio dello stato degli enumeratori)</span><span class="sxs-lookup"><span data-stu-id="4548b-139">[Saving the State of Enumerators](https://blogs.msdn.microsoft.com/wesdyer/2006/01/13/saving-the-state-of-enumerators/)</span></span>
- <span data-ttu-id="4548b-140">[An Inheritance Puzzle, Part One](https://blogs.msdn.microsoft.com/ericlippert/2007/07/27/an-inheritance-puzzle-part-one/) (Indovinello sull'ereditarietà - Parte 1)</span><span class="sxs-lookup"><span data-stu-id="4548b-140">[An Inheritance Puzzle, Part One](https://blogs.msdn.microsoft.com/ericlippert/2007/07/27/an-inheritance-puzzle-part-one/)</span></span>
