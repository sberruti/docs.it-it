---
title: Introduzione all'analisi semantica
description: Questa esercitazione offre una panoramica dell'utilizzo dell'analisi semantica con .NET Compiler SDK.
ms.date: 02/06/2018
ms.custom: mvc
ms.openlocfilehash: a6dcaeeb86acb5c0e1602f01dc5952ffd9d5e3f5
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 03/14/2020
ms.locfileid: "78240509"
---
# <a name="get-started-with-semantic-analysis"></a><span data-ttu-id="b88f8-103">Introduzione all'analisi semantica</span><span class="sxs-lookup"><span data-stu-id="b88f8-103">Get started with semantic analysis</span></span>

<span data-ttu-id="b88f8-104">In questa esercitazione si presuppone una certa familiarità con l'API Syntax.</span><span class="sxs-lookup"><span data-stu-id="b88f8-104">This tutorial assumes you're familiar with the Syntax API.</span></span> <span data-ttu-id="b88f8-105">L'articolo [Introduzione all'analisi della sintassi](syntax-analysis.md) offre informazioni introduttive sufficienti.</span><span class="sxs-lookup"><span data-stu-id="b88f8-105">The [get started with syntax analysis](syntax-analysis.md) article provides sufficient introduction.</span></span>

<span data-ttu-id="b88f8-106">In questa esercitazione verranno esplorate le API **Symbol** e **Binding**.</span><span class="sxs-lookup"><span data-stu-id="b88f8-106">In this tutorial, you explore the **Symbol** and **Binding APIs**.</span></span> <span data-ttu-id="b88f8-107">Queste API offrono informazioni sul _significato semantico_ di un programma</span><span class="sxs-lookup"><span data-stu-id="b88f8-107">These APIs provide information about the _semantic meaning_ of a program.</span></span> <span data-ttu-id="b88f8-108">e consentono di porre domande sui tipi rappresentati da qualsiasi simbolo nel programma e ottenere risposte.</span><span class="sxs-lookup"><span data-stu-id="b88f8-108">They enable you to ask and answer questions about the types represented by any symbol in your program.</span></span>

<span data-ttu-id="b88f8-109">È necessario installare **.NET Compiler Platform SDK**:</span><span class="sxs-lookup"><span data-stu-id="b88f8-109">You'll need to install the **.NET Compiler Platform SDK**:</span></span>

[!INCLUDE[interactive-note](~/includes/roslyn-installation.md)]

## <a name="understanding-compilations-and-symbols"></a><span data-ttu-id="b88f8-110">Informazioni su compilazioni e simboli</span><span class="sxs-lookup"><span data-stu-id="b88f8-110">Understanding Compilations and Symbols</span></span>

<span data-ttu-id="b88f8-111">Man mano che si lavora con .NET Compiler SDK si acquisirà familiarità con le distinzioni tra API Syntax e API Semantic.</span><span class="sxs-lookup"><span data-stu-id="b88f8-111">As you work more with the .NET Compiler SDK, you become familiar with the distinctions between Syntax API and the Semantic API.</span></span> <span data-ttu-id="b88f8-112">L'**API Syntax** consente di esaminare la _struttura_ di un programma.</span><span class="sxs-lookup"><span data-stu-id="b88f8-112">The **Syntax API** allows you to look at the _structure_ of a program.</span></span> <span data-ttu-id="b88f8-113">Tuttavia, spesso servono informazioni più dettagliate sulla semantica o il _significato_ di un programma.</span><span class="sxs-lookup"><span data-stu-id="b88f8-113">However, often you want richer information about the semantics or _meaning_ of a program.</span></span> <span data-ttu-id="b88f8-114">Mentre un file di codice sciolto o un frammento di codice Visual Basic o C , può essere analizzato sintatticamente in isolamento, non è significativo porre domande come "qual è il tipo di questa variabile" in un vuoto.</span><span class="sxs-lookup"><span data-stu-id="b88f8-114">While a loose code file or snippet of Visual Basic or C# code can be syntactically analyzed in isolation, it's not meaningful to ask questions such as "what's the type of this variable" in a vacuum.</span></span> <span data-ttu-id="b88f8-115">Il significato di un nome di tipo potrebbe essere dipendente da riferimenti ad assembly, importazioni di spazi dei nomi o altri file di codice.</span><span class="sxs-lookup"><span data-stu-id="b88f8-115">The meaning of a type name may be dependent on assembly references, namespace imports, or other code files.</span></span> <span data-ttu-id="b88f8-116">Queste domande possono ottenere risposta tramite l'**API Semantic**, in particolare la classe <xref:Microsoft.CodeAnalysis.Compilation?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b88f8-116">Those questions are answered using the **Semantic API**, specifically the <xref:Microsoft.CodeAnalysis.Compilation?displayProperty=nameWithType> class.</span></span>

<span data-ttu-id="b88f8-117">Un'istanza di <xref:Microsoft.CodeAnalysis.Compilation> è paragonabile a un singolo progetto, dal punto di vista del compilatore e rappresenta tutti gli elementi necessari per compilare un programma Visual Basic o C#.</span><span class="sxs-lookup"><span data-stu-id="b88f8-117">An instance of <xref:Microsoft.CodeAnalysis.Compilation> is analogous to a single project as seen by the compiler and represents everything needed to compile a Visual Basic or C# program.</span></span> <span data-ttu-id="b88f8-118">La **compilazione** include il set di file di origine da compilare, i riferimenti agli assembly e le opzioni del compilatore.</span><span class="sxs-lookup"><span data-stu-id="b88f8-118">The **compilation** includes the set of source files to be compiled, assembly references, and compiler options.</span></span> <span data-ttu-id="b88f8-119">È possibile ragionare sul significato del codice usando tutte le altre informazioni in questo contesto.</span><span class="sxs-lookup"><span data-stu-id="b88f8-119">You can reason about the meaning of the code using all the other information in this context.</span></span> <span data-ttu-id="b88f8-120"><xref:Microsoft.CodeAnalysis.Compilation> consente di trovare i **simboli**, ovvero entità come i tipi, gli spazi dei nomi, i membri e le variabili a cui fanno riferimento i nomi e altre espressioni.</span><span class="sxs-lookup"><span data-stu-id="b88f8-120">A <xref:Microsoft.CodeAnalysis.Compilation> allows you to find **Symbols** - entities such as types, namespaces, members, and variables which names and other expressions refer to.</span></span> <span data-ttu-id="b88f8-121">Il processo di associazione di nomi ed espressioni a **simboli** viene chiamato **associazione**.</span><span class="sxs-lookup"><span data-stu-id="b88f8-121">The process of associating names and expressions with **Symbols** is called **Binding**.</span></span>

<span data-ttu-id="b88f8-122">Come <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType>, <xref:Microsoft.CodeAnalysis.Compilation> è una classe astratta con derivati specifici del linguaggio.</span><span class="sxs-lookup"><span data-stu-id="b88f8-122">Like <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType>, <xref:Microsoft.CodeAnalysis.Compilation> is an abstract class with language-specific derivatives.</span></span> <span data-ttu-id="b88f8-123">Quando si crea un'istanza di Compilation, è necessario richiamare un metodo factory sulla classe <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation?displayProperty=nameWithType> (o <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation?displayProperty=nameWithType>).</span><span class="sxs-lookup"><span data-stu-id="b88f8-123">When creating an instance of Compilation, you must invoke a factory method on the <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation?displayProperty=nameWithType> (or <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation?displayProperty=nameWithType>) class.</span></span>

## <a name="querying-symbols"></a><span data-ttu-id="b88f8-124">Esecuzione di query sui simboli</span><span class="sxs-lookup"><span data-stu-id="b88f8-124">Querying symbols</span></span>

<span data-ttu-id="b88f8-125">In questa esercitazione, viene esaminato ancora una volta il programma "Hello World".</span><span class="sxs-lookup"><span data-stu-id="b88f8-125">In this tutorial, you look at the "Hello World" program again.</span></span> <span data-ttu-id="b88f8-126">In questo caso si esegue una query sui simboli nel programma per scoprire quali tipi rappresentano questi simboli.</span><span class="sxs-lookup"><span data-stu-id="b88f8-126">This time, you query the symbols in the program to understand what types those symbols represent.</span></span> <span data-ttu-id="b88f8-127">Verrà eseguita una query per recuperare i tipi in uno spazio dei nomi e si imparerà a trovare i metodi disponibili per un tipo.</span><span class="sxs-lookup"><span data-stu-id="b88f8-127">You query for the types in a namespace, and learn to find the methods available on a type.</span></span>

<span data-ttu-id="b88f8-128">È possibile visualizzare il codice completato per l'esempio nel [repository GitHub](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SemanticQuickStart).</span><span class="sxs-lookup"><span data-stu-id="b88f8-128">You can see the finished code for this sample in [our GitHub repository](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SemanticQuickStart).</span></span>

> [!NOTE]
> <span data-ttu-id="b88f8-129">I tipi di albero della sintassi usano l'ereditarietà per descrivere i diversi elementi della sintassi validi in posizioni diverse nel programma.</span><span class="sxs-lookup"><span data-stu-id="b88f8-129">The Syntax Tree types use inheritance to describe the different syntax elements that are valid at different locations in the program.</span></span> <span data-ttu-id="b88f8-130">L'uso di queste API spesso significa eseguire il cast di proprietà o membri di raccolte in tipi derivati specifici.</span><span class="sxs-lookup"><span data-stu-id="b88f8-130">Using these APIs often means casting properties or collection members to specific derived types.</span></span> <span data-ttu-id="b88f8-131">Negli esempi seguenti, l'assegnazione e i cast sono istruzioni separate, con variabili tipizzate in modo esplicito.</span><span class="sxs-lookup"><span data-stu-id="b88f8-131">In the following examples, the assignment and the casts are separate statements, using explicitly typed variables.</span></span> <span data-ttu-id="b88f8-132">È possibile leggere il codice per visualizzare i tipi restituiti dell'API e il tipo di runtime degli oggetti restituiti.</span><span class="sxs-lookup"><span data-stu-id="b88f8-132">You can read the code to see the return types of the API and the runtime type of the objects returned.</span></span> <span data-ttu-id="b88f8-133">In pratica, è più comune usare variabili tipizzate in modo implicito e basarsi sui nomi delle API per descrivere il tipo di oggetti in corso di analisi.</span><span class="sxs-lookup"><span data-stu-id="b88f8-133">In practice, it's more common to use implicitly typed variables and rely on API names to describe the type of objects being examined.</span></span>

<span data-ttu-id="b88f8-134">Creare un nuovo progetto C# **Stand-Alone Code Analysis Tool** (Strumento di analisi del codice autonomo):</span><span class="sxs-lookup"><span data-stu-id="b88f8-134">Create a new C# **Stand-Alone Code Analysis Tool** project:</span></span>

* <span data-ttu-id="b88f8-135">In Visual Studio scegliere **File** > **nuovo** > **progetto** per visualizzare la finestra di dialogo Nuovo progetto.</span><span class="sxs-lookup"><span data-stu-id="b88f8-135">In Visual Studio, choose **File** > **New** > **Project** to display the New Project dialog.</span></span>
* <span data-ttu-id="b88f8-136">In**Estensibilità** **di Visual C,** > scegliere **Strumento di analisi**del codice autonomo .</span><span class="sxs-lookup"><span data-stu-id="b88f8-136">Under **Visual C#** > **Extensibility**, choose **Stand-Alone Code Analysis Tool**.</span></span>
* <span data-ttu-id="b88f8-137">Denominare il progetto "**SemanticQuickStart**" e fare clic su OK.</span><span class="sxs-lookup"><span data-stu-id="b88f8-137">Name your project "**SemanticQuickStart**" and click OK.</span></span>

<span data-ttu-id="b88f8-138">Verrà analizzato il semplice programma "Hello World!"</span><span class="sxs-lookup"><span data-stu-id="b88f8-138">You're going to analyze the basic "Hello World!"</span></span> <span data-ttu-id="b88f8-139">mostrato in precedenza.</span><span class="sxs-lookup"><span data-stu-id="b88f8-139">program shown earlier.</span></span>
<span data-ttu-id="b88f8-140">Aggiungere il testo per il programma Hello World come costante nella classe `Program`:</span><span class="sxs-lookup"><span data-stu-id="b88f8-140">Add the text for the Hello World program as a constant in your `Program` class:</span></span>

[!code-csharp[Declare the program test](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#1 "Declare a constant string for the program text to analyze")]

<span data-ttu-id="b88f8-141">Aggiungere poi il codice seguente per creare l'albero della sintassi per il testo del codice nella costante `programText`.</span><span class="sxs-lookup"><span data-stu-id="b88f8-141">Next, add the following code to build the syntax tree for the code text in the `programText` constant.</span></span>  <span data-ttu-id="b88f8-142">Aggiungere la riga seguente al metodo `Main`:</span><span class="sxs-lookup"><span data-stu-id="b88f8-142">Add the following line to your `Main` method:</span></span>

[!code-csharp[Create the tree](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#2 "Create the syntax tree")]

<span data-ttu-id="b88f8-143">Compilare poi un'istanza di <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation> dall'albero già creato.</span><span class="sxs-lookup"><span data-stu-id="b88f8-143">Next, build a <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation> from the tree you already created.</span></span> <span data-ttu-id="b88f8-144">L'esempio "Hello World" si basa sui tipi <xref:System.String> e <xref:System.Console>.</span><span class="sxs-lookup"><span data-stu-id="b88f8-144">The "Hello World" sample relies on the <xref:System.String> and <xref:System.Console> types.</span></span> <span data-ttu-id="b88f8-145">È necessario fare riferimento all'assembly che dichiara i due tipi nella compilazione.</span><span class="sxs-lookup"><span data-stu-id="b88f8-145">You need to reference the assembly that declares those two types in your compilation.</span></span> <span data-ttu-id="b88f8-146">Aggiungere la riga seguente al metodo `Main` per creare una compilazione dell'albero della sintassi, incluso il riferimento all'assembly appropriato:</span><span class="sxs-lookup"><span data-stu-id="b88f8-146">Add the following line to your `Main` method to create a compilation of your syntax tree, including the reference to the appropriate assembly:</span></span>

[!code-csharp[Create the compilation](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#3 "Create the compilation for the semantic model")]

<span data-ttu-id="b88f8-147">Il metodo <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.AddReferences%2A?displayProperty=nameWithType> aggiunge i riferimenti alla compilazione.</span><span class="sxs-lookup"><span data-stu-id="b88f8-147">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.AddReferences%2A?displayProperty=nameWithType> method adds references to the compilation.</span></span> <span data-ttu-id="b88f8-148">Il metodo <xref:Microsoft.CodeAnalysis.MetadataReference.CreateFromFile%2A?displayProperty=nameWithType> carica un assembly come riferimento.</span><span class="sxs-lookup"><span data-stu-id="b88f8-148">The <xref:Microsoft.CodeAnalysis.MetadataReference.CreateFromFile%2A?displayProperty=nameWithType> method loads an assembly as a reference.</span></span>

## <a name="querying-the-semantic-model"></a><span data-ttu-id="b88f8-149">Esecuzione di query sul modello semantico</span><span class="sxs-lookup"><span data-stu-id="b88f8-149">Querying the semantic model</span></span>

<span data-ttu-id="b88f8-150">Dopo aver creato un <xref:Microsoft.CodeAnalysis.Compilation> è possibile richiedere un <xref:Microsoft.CodeAnalysis.SemanticModel> per qualsiasi <xref:Microsoft.CodeAnalysis.SyntaxTree> contenuto in tale <xref:Microsoft.CodeAnalysis.Compilation>.</span><span class="sxs-lookup"><span data-stu-id="b88f8-150">Once you have a <xref:Microsoft.CodeAnalysis.Compilation> you can ask it for a <xref:Microsoft.CodeAnalysis.SemanticModel> for any <xref:Microsoft.CodeAnalysis.SyntaxTree> contained in that <xref:Microsoft.CodeAnalysis.Compilation>.</span></span> <span data-ttu-id="b88f8-151">È possibile considerare il modello semantico come fonte di tutte le informazioni che si ottengono in genere da IntelliSense.</span><span class="sxs-lookup"><span data-stu-id="b88f8-151">You can think of the semantic model as the source for all the information you would normally get from intellisense.</span></span> <span data-ttu-id="b88f8-152">Un oggetto <xref:Microsoft.CodeAnalysis.SemanticModel> può rispondere a domande come "Quali nomi sono compresi nell'ambito in questa posizione?", "Quali membri sono accessibili da questo metodo?", "Quali variabili vengono usate in questo blocco di testo?" e "A cosa fa riferimento questa espressione/questo nome?"</span><span class="sxs-lookup"><span data-stu-id="b88f8-152">A <xref:Microsoft.CodeAnalysis.SemanticModel> can answer questions like "What names are in scope at this location?", "What members are accessible from this method?", "What variables are used in this block of text?", and "What does this name/expression refer to?"</span></span> <span data-ttu-id="b88f8-153">Aggiungere questa istruzione per creare il modello semantico:</span><span class="sxs-lookup"><span data-stu-id="b88f8-153">Add this statement to create the semantic model:</span></span>

[!code-csharp[Create the semantic model](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#4 "Create the semantic model")]

## <a name="binding-a-name"></a><span data-ttu-id="b88f8-154">Associazione di un nome</span><span class="sxs-lookup"><span data-stu-id="b88f8-154">Binding a name</span></span>

<span data-ttu-id="b88f8-155"><xref:Microsoft.CodeAnalysis.Compilation> crea <xref:Microsoft.CodeAnalysis.SemanticModel> da <xref:Microsoft.CodeAnalysis.SyntaxTree>.</span><span class="sxs-lookup"><span data-stu-id="b88f8-155">The <xref:Microsoft.CodeAnalysis.Compilation> creates the  <xref:Microsoft.CodeAnalysis.SemanticModel> from the <xref:Microsoft.CodeAnalysis.SyntaxTree>.</span></span> <span data-ttu-id="b88f8-156">Dopo aver creato il modello, è possibile eseguire query per trovare la prima direttiva `using` e recuperare informazioni sui simboli per lo spazio dei nomi `System`.</span><span class="sxs-lookup"><span data-stu-id="b88f8-156">After creating the model, you can query it to find the first `using` directive, and retrieve the symbol information for the `System` namespace.</span></span> <span data-ttu-id="b88f8-157">Aggiungere queste due righe al metodo `Main` per creare il modello semantico e recuperare il simbolo per la prima istruzione using:</span><span class="sxs-lookup"><span data-stu-id="b88f8-157">Add these two lines to your `Main` method to create the semantic model and retrieve the symbol for the first using statement:</span></span>

[!code-csharp[Find the namespace symbol for the first using](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#5 "Find the namespace symbol for the first using")]

<span data-ttu-id="b88f8-158">Il codice precedente illustra come associare il nome nella prima direttiva `using` per recuperare un <xref:Microsoft.CodeAnalysis.SymbolInfo?displayProperty=nameWithType> per lo spazio dei nomi `System`.</span><span class="sxs-lookup"><span data-stu-id="b88f8-158">The preceding code shows how to bind the name in the first `using` directive to retrieve a <xref:Microsoft.CodeAnalysis.SymbolInfo?displayProperty=nameWithType> for the `System` namespace.</span></span> <span data-ttu-id="b88f8-159">Il codice precedente dimostra anche che si usa il **modello della sintassi** per trovare la struttura del codice e il **modello semantico** per comprenderne il significato.</span><span class="sxs-lookup"><span data-stu-id="b88f8-159">The preceding code also illustrates that you use the **syntax model** to find the structure of the code; you use the **semantic model** to understand its meaning.</span></span> <span data-ttu-id="b88f8-160">Il **modello della sintassi** individua la stringa `System` nell'istruzione using.</span><span class="sxs-lookup"><span data-stu-id="b88f8-160">The **syntax model** finds the string `System` in the using statement.</span></span> <span data-ttu-id="b88f8-161">Il **modello semantico** include tutte le informazioni sui tipi definiti nello spazio dei nomi `System`.</span><span class="sxs-lookup"><span data-stu-id="b88f8-161">The **semantic model** has all the information about the types defined in the `System` namespace.</span></span>

<span data-ttu-id="b88f8-162">Dall'oggetto <xref:Microsoft.CodeAnalysis.SymbolInfo> è possibile ottenere <xref:Microsoft.CodeAnalysis.ISymbol?displayProperty=nameWithType> usando la proprietà <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b88f8-162">From the <xref:Microsoft.CodeAnalysis.SymbolInfo> object you can obtain the <xref:Microsoft.CodeAnalysis.ISymbol?displayProperty=nameWithType> using the <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="b88f8-163">Questa proprietà restituisce il simbolo a cui fa riferimento questa espressione.</span><span class="sxs-lookup"><span data-stu-id="b88f8-163">This property returns the symbol this expression refers to.</span></span> <span data-ttu-id="b88f8-164">Per le espressioni che non fanno riferimento ad alcun elemento (ad esempio, i valori letterali numerici) questa proprietà è `null`.</span><span class="sxs-lookup"><span data-stu-id="b88f8-164">For expressions that don't refer to anything (such as numeric literals) this property is `null`.</span></span> <span data-ttu-id="b88f8-165">Quando <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> non è null, <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> indica il tipo del simbolo.</span><span class="sxs-lookup"><span data-stu-id="b88f8-165">When the <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> is not null, the <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> denotes the type of the symbol.</span></span> <span data-ttu-id="b88f8-166">In questo esempio, la proprietà <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> è un <xref:Microsoft.CodeAnalysis.SymbolKind.Namespace?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b88f8-166">In this example, the <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> property is a <xref:Microsoft.CodeAnalysis.SymbolKind.Namespace?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b88f8-167">Aggiungere il codice seguente al metodo `Main`.</span><span class="sxs-lookup"><span data-stu-id="b88f8-167">Add the following code to your `Main` method.</span></span> <span data-ttu-id="b88f8-168">Recupera il simbolo per lo spazio dei nomi `System` e quindi visualizza tutti gli spazi dei nomi figlio dichiarati nello spazio dei nomi `System`:</span><span class="sxs-lookup"><span data-stu-id="b88f8-168">It retrieves the symbol for the `System` namespace and then displays all the child namespaces declared in the `System` namespace:</span></span>

[!code-csharp[Display all the child namespaces](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#6 "Display all the child namespaces from this compilation")]

<span data-ttu-id="b88f8-169">Eseguire il programma. L'output dovrebbe essere il seguente:</span><span class="sxs-lookup"><span data-stu-id="b88f8-169">Run the program and you should see the following output:</span></span>

```output
System.Collections
System.Configuration
System.Deployment
System.Diagnostics
System.Globalization
System.IO
System.Numerics
System.Reflection
System.Resources
System.Runtime
System.Security
System.StubHelpers
System.Text
System.Threading
Press any key to continue . . .
```

> [!NOTE]
> <span data-ttu-id="b88f8-170">L'output non include ogni spazio dei nomi figlio dello spazio dei nomi `System`.</span><span class="sxs-lookup"><span data-stu-id="b88f8-170">The output does not include every namespace that is a child namespace of the `System` namespace.</span></span> <span data-ttu-id="b88f8-171">Viene visualizzato ogni spazio dei nomi presente in questa compilazione, che fa riferimento solo all'assembly in cui è dichiarato `System.String`.</span><span class="sxs-lookup"><span data-stu-id="b88f8-171">It displays every namespace that is present in this compilation, which only references the assembly where `System.String` is declared.</span></span> <span data-ttu-id="b88f8-172">Gli eventuali spazi dei nomi dichiarati in altri assembly non sono noti per questa compilazione</span><span class="sxs-lookup"><span data-stu-id="b88f8-172">Any namespaces declared in other assemblies are not known to this compilation</span></span>

### <a name="binding-an-expression"></a><span data-ttu-id="b88f8-173">Associazione di un'espressione</span><span class="sxs-lookup"><span data-stu-id="b88f8-173">Binding an expression</span></span>

<span data-ttu-id="b88f8-174">Il codice precedente mostra come trovare un simbolo mediante l'associazione a un nome.</span><span class="sxs-lookup"><span data-stu-id="b88f8-174">The preceding code shows how to find a symbol by binding to a name.</span></span> <span data-ttu-id="b88f8-175">Esistono altre espressioni in un programma C# che possono essere associate e non sono nomi.</span><span class="sxs-lookup"><span data-stu-id="b88f8-175">There are other expressions in a C# program that can be bound that aren't names.</span></span> <span data-ttu-id="b88f8-176">Per illustrare questa funzionalità, si esaminerà l'associazione a un semplice valore letterale stringa.</span><span class="sxs-lookup"><span data-stu-id="b88f8-176">To demonstrate this capability, let's access the binding to a simple string literal.</span></span>

<span data-ttu-id="b88f8-177">Il programma "Hello World" contiene un <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax?displayProperty=nameWithType>, ovvero la stringa "Hello, World!"</span><span class="sxs-lookup"><span data-stu-id="b88f8-177">The "Hello World" program contains a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax?displayProperty=nameWithType>, the "Hello, World!"</span></span> <span data-ttu-id="b88f8-178">visualizzata nella console.</span><span class="sxs-lookup"><span data-stu-id="b88f8-178">string displayed to the console.</span></span>

<span data-ttu-id="b88f8-179">È possibile trovare la stringa "Hello, World!"</span><span class="sxs-lookup"><span data-stu-id="b88f8-179">You find the "Hello, World!"</span></span> <span data-ttu-id="b88f8-180">individuando il singolo valore letterale stringa nel programma.</span><span class="sxs-lookup"><span data-stu-id="b88f8-180">string by locating the single string literal in the program.</span></span> <span data-ttu-id="b88f8-181">Dopo aver individuato il nodo della sintassi, è possibile ottenere le informazioni sul tipo per tale nodo dal modello semantico.</span><span class="sxs-lookup"><span data-stu-id="b88f8-181">Then, once you've located the syntax node, get the type info for that node from the semantic model.</span></span> <span data-ttu-id="b88f8-182">Aggiungere il codice seguente al metodo `Main`:</span><span class="sxs-lookup"><span data-stu-id="b88f8-182">Add the following code to your `Main` method:</span></span>

[!code-csharp[Find the namespace symbol for the only using](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#7 "Find the namespace symbol for the only using")]

<span data-ttu-id="b88f8-183">Lo struct <xref:Microsoft.CodeAnalysis.TypeInfo?displayProperty=nameWithType> include una proprietà <xref:Microsoft.CodeAnalysis.TypeInfo.Type?displayProperty=nameWithType> che consente l'accesso alle informazioni semantiche sul tipo del valore letterale.</span><span class="sxs-lookup"><span data-stu-id="b88f8-183">The <xref:Microsoft.CodeAnalysis.TypeInfo?displayProperty=nameWithType> struct includes a <xref:Microsoft.CodeAnalysis.TypeInfo.Type?displayProperty=nameWithType> property that enables access to the semantic information about the type of the literal.</span></span> <span data-ttu-id="b88f8-184">In questo esempio, si tratta del tipo `string`.</span><span class="sxs-lookup"><span data-stu-id="b88f8-184">In this example, that's the `string` type.</span></span> <span data-ttu-id="b88f8-185">Aggiungere una dichiarazione che assegna questa proprietà a una variabile locale:</span><span class="sxs-lookup"><span data-stu-id="b88f8-185">Add a declaration that assigns this property to a local variable:</span></span>

[!code-csharp[Find the semantic information about the string type](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#8 "Use the string literal to access the semantic information in the string type.")]

<span data-ttu-id="b88f8-186">Per completare questa esercitazione, verrà definita una query LINQ che crea una sequenza di tutti i metodi pubblici dichiarati nel tipo `string` che restituiscono `string`.</span><span class="sxs-lookup"><span data-stu-id="b88f8-186">To finish this tutorial, let's build a LINQ query that creates a sequence of all the public methods declared on the `string` type that return a `string`.</span></span> <span data-ttu-id="b88f8-187">Questa query diventa complessa, quindi viene creata riga per riga per poi essere ricostruita come singola query.</span><span class="sxs-lookup"><span data-stu-id="b88f8-187">This query gets complex, so let's build it line by line, then reconstruct it as a single query.</span></span> <span data-ttu-id="b88f8-188">L'origine per questa query è la sequenza di tutti i membri dichiarati nel tipo `string`:</span><span class="sxs-lookup"><span data-stu-id="b88f8-188">The source for this query is the sequence of all members declared on the `string` type:</span></span>

[!code-csharp[Access the sequence of members on the string type](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#9 "Access the sequence of members on the string type.")]

<span data-ttu-id="b88f8-189">Questa sequenza di origine contiene tutti i membri, inclusi le proprietà e i campi, quindi filtrarla tramite il metodo <xref:System.Collections.Immutable.ImmutableArray%601.OfType%2A?displayProperty=nameWithType> per trovare gli elementi corrispondenti a oggetti <xref:Microsoft.CodeAnalysis.IMethodSymbol?displayProperty=nameWithType>:</span><span class="sxs-lookup"><span data-stu-id="b88f8-189">That source sequence contains all members, including properties and fields, so filter it using the <xref:System.Collections.Immutable.ImmutableArray%601.OfType%2A?displayProperty=nameWithType> method to find elements that are <xref:Microsoft.CodeAnalysis.IMethodSymbol?displayProperty=nameWithType> objects:</span></span>

[!code-csharp[Filter the sequence to only methods](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#10 "Find the subset of the collection that is the methods.")]

<span data-ttu-id="b88f8-190">Aggiungere poi un altro filtro per restituire solo i metodi pubblici che restituiscono `string`:</span><span class="sxs-lookup"><span data-stu-id="b88f8-190">Next, add another filter to return only those methods that are public and return a `string`:</span></span>

[!code-csharp[Filter on return type and accessibility](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#11 "Find only the public methods that return a string.")]

<span data-ttu-id="b88f8-191">Selezionare solo la proprietà del nome e solo i nomi distinti rimuovendo qualsiasi overload:</span><span class="sxs-lookup"><span data-stu-id="b88f8-191">Select only the name property, and only distinct names by removing any overloads:</span></span>

[!code-csharp[find the distinct names.](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#12 "Use the string literal to access the semantic information in the string type.")]

<span data-ttu-id="b88f8-192">È anche possibile creare la query completa usando la sintassi di query LINQ e quindi visualizzare tutti i nomi di metodo nella console:</span><span class="sxs-lookup"><span data-stu-id="b88f8-192">You can also build the full query using the LINQ query syntax, and then display all the method names in  the console:</span></span>

[!code-csharp[build and display the results of this query.](../../../../samples/snippets/csharp/roslyn-sdk/SemanticQuickStart/Program.cs#13 "Build and display the results of the query.")]

<span data-ttu-id="b88f8-193">Compilare ed eseguire il programma.</span><span class="sxs-lookup"><span data-stu-id="b88f8-193">Build and run the program.</span></span> <span data-ttu-id="b88f8-194">Dovrebbe venire visualizzato l'output seguente.</span><span class="sxs-lookup"><span data-stu-id="b88f8-194">You should see the following output:</span></span>

```output
Join
Substring
Trim
TrimStart
TrimEnd
Normalize
PadLeft
PadRight
ToLower
ToLowerInvariant
ToUpper
ToUpperInvariant
ToString
Insert
Replace
Remove
Format
Copy
Concat
Intern
IsInterned
Press any key to continue . . .
```

<span data-ttu-id="b88f8-195">È stata usata l'API Semantic per trovare e visualizzare informazioni sui simboli che fanno parte di questo programma.</span><span class="sxs-lookup"><span data-stu-id="b88f8-195">You've used the Semantic API to find and display information about the symbols that are part of this program.</span></span>
