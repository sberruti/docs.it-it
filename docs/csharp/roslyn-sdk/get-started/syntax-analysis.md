---
title: Introduzione all'analisi della sintassi (API Roslyn)
description: Introduzione all'attraversamento, all'esecuzione di query e all'esplorazione di alberi della sintassi.
ms.date: 02/05/2018
ms.custom: mvc
ms.openlocfilehash: 22d1303c9daa2ae35cf130b0c857cd7a5efdbe76
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 03/14/2020
ms.locfileid: "78240519"
---
# <a name="get-started-with-syntax-analysis"></a><span data-ttu-id="3761e-103">Introduzione all'analisi della sintassi</span><span class="sxs-lookup"><span data-stu-id="3761e-103">Get started with syntax analysis</span></span>

<span data-ttu-id="3761e-104">In questa esercitazione verrà esaminata l'**API Syntax**.</span><span class="sxs-lookup"><span data-stu-id="3761e-104">In this tutorial, you'll explore the **Syntax API**.</span></span> <span data-ttu-id="3761e-105">L'API Syntax consente l'accesso alle strutture di dati che descrivono un programma C# o Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="3761e-105">The Syntax API provides access to the data structures that describe a C# or Visual Basic program.</span></span> <span data-ttu-id="3761e-106">Queste strutture di dati includono dettagli sufficienti per rappresentare completamente un programma di qualsiasi dimensione.</span><span class="sxs-lookup"><span data-stu-id="3761e-106">These data structures have enough detail that they can fully represent any program of any size.</span></span> <span data-ttu-id="3761e-107">Queste strutture possono descrivere programmi completi che vengono compilati ed eseguiti correttamente.</span><span class="sxs-lookup"><span data-stu-id="3761e-107">These structures can describe complete programs that compile and run correctly.</span></span> <span data-ttu-id="3761e-108">Possono anche descrivere programmi incompleti, durante la scrittura, nell'editor.</span><span class="sxs-lookup"><span data-stu-id="3761e-108">They can also describe incomplete programs, as you write them, in the editor.</span></span>

<span data-ttu-id="3761e-109">Per rendere possibile questa espressione elaborata, le strutture di dati e le API che costituiscono l'API Syntax sono necessariamente complesse.</span><span class="sxs-lookup"><span data-stu-id="3761e-109">To enable this rich expression, the data structures and APIs that make up the Syntax API are necessarily complex.</span></span> <span data-ttu-id="3761e-110">Per iniziare, verrà esaminato l'aspetto della struttura dei dati per il tipico programma "Hello World":</span><span class="sxs-lookup"><span data-stu-id="3761e-110">Let's start with what the data structure looks like for the typical "Hello World" program:</span></span>

```csharp
using System;
using System.Collections.Generic;
using System.Linq;

namespace HelloWorld
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
        }
    }
}
```

<span data-ttu-id="3761e-111">Esaminando il testo del programma precedente</span><span class="sxs-lookup"><span data-stu-id="3761e-111">Look at the text of the previous program.</span></span> <span data-ttu-id="3761e-112">si riconoscono elementi noti.</span><span class="sxs-lookup"><span data-stu-id="3761e-112">You recognize familiar elements.</span></span> <span data-ttu-id="3761e-113">L'intero testo rappresenta un singolo file di origine, ovvero un'**unità di compilazione**.</span><span class="sxs-lookup"><span data-stu-id="3761e-113">The entire text represents a single source file, or a **compilation unit**.</span></span> <span data-ttu-id="3761e-114">Le prime tre righe di tale file di origine sono **direttive using**.</span><span class="sxs-lookup"><span data-stu-id="3761e-114">The first three lines of that source file are **using directives**.</span></span> <span data-ttu-id="3761e-115">L'origine rimanente è contenuta in una **dichiarazione dello spazio dei nomi**.</span><span class="sxs-lookup"><span data-stu-id="3761e-115">The remaining source is contained in a **namespace declaration**.</span></span> <span data-ttu-id="3761e-116">La dichiarazione dello spazio dei nomi contiene una **dichiarazione di classe** figlio.</span><span class="sxs-lookup"><span data-stu-id="3761e-116">The namespace declaration contains a child **class declaration**.</span></span> <span data-ttu-id="3761e-117">La dichiarazione di classe contiene una **dichiarazione di metodo**.</span><span class="sxs-lookup"><span data-stu-id="3761e-117">The class declaration contains one **method declaration**.</span></span>

<span data-ttu-id="3761e-118">L'API Syntax crea una struttura ad albero con la radice che rappresenta l'unità di compilazione.</span><span class="sxs-lookup"><span data-stu-id="3761e-118">The Syntax API creates a tree structure with the root representing the compilation unit.</span></span> <span data-ttu-id="3761e-119">I nodi nell'albero rappresentano le direttive using, la dichiarazione dello spazio dei nomi e tutti gli altri elementi del programma.</span><span class="sxs-lookup"><span data-stu-id="3761e-119">Nodes in the tree represent the using directives, namespace declaration and all the other elements of the program.</span></span> <span data-ttu-id="3761e-120">La struttura ad albero continua fino ai livelli più bassi: la stringa "Hello World!"</span><span class="sxs-lookup"><span data-stu-id="3761e-120">The tree structure continues down to the lowest levels: the string "Hello World!"</span></span> <span data-ttu-id="3761e-121">è un **token letterale di stringa** che è un discendente di un **argomento**.</span><span class="sxs-lookup"><span data-stu-id="3761e-121">is a **string literal token** that is a descendent of an **argument**.</span></span> <span data-ttu-id="3761e-122">L'API Syntax consente l'accesso alla struttura del programma.</span><span class="sxs-lookup"><span data-stu-id="3761e-122">The Syntax API provides access to the structure of the program.</span></span> <span data-ttu-id="3761e-123">È possibile eseguire query per ottenere specifiche procedure consigliate per la scrittura del codice, ripercorrere l'intera struttura ad albero per comprendere il codice e creare nuovi alberi modificando quello esistente.</span><span class="sxs-lookup"><span data-stu-id="3761e-123">You can query for specific code practices, walk the entire tree to understand the code, and create new trees by modifying the existing tree.</span></span>

<span data-ttu-id="3761e-124">Questa breve descrizione offre una panoramica del tipo di informazioni accessibili tramite l'API Syntax.</span><span class="sxs-lookup"><span data-stu-id="3761e-124">That brief description provides an overview of the kind of information accessible using the Syntax API.</span></span> <span data-ttu-id="3761e-125">L'API Syntax non è altro che un'API formale che descrive i costrutti di codice familiari, già noti da C#.</span><span class="sxs-lookup"><span data-stu-id="3761e-125">The Syntax API is nothing more than a formal API that describes the familiar code constructs you know from C#.</span></span> <span data-ttu-id="3761e-126">Le funzionalità complete includono informazioni sulla formattazione del codice, inclusi spazi vuoti, interruzioni di riga e rientri.</span><span class="sxs-lookup"><span data-stu-id="3761e-126">The full capabilities include information about how the code is formatted including line breaks, white space, and indenting.</span></span> <span data-ttu-id="3761e-127">Usando queste informazioni è possibile rappresentare completamente il codice nel modo in cui viene scritto e letto dai programmatori umani o dal compilatore.</span><span class="sxs-lookup"><span data-stu-id="3761e-127">Using this information, you can fully represent the code as written and read by human programmers or the compiler.</span></span> <span data-ttu-id="3761e-128">L'uso di questa struttura consente di interagire con il codice sorgente su un livello molto significativo.</span><span class="sxs-lookup"><span data-stu-id="3761e-128">Using this structure enables you to interact with the source code on a deeply meaningful level.</span></span> <span data-ttu-id="3761e-129">Non si tratta più di semplici stringhe di testo, ma di dati che rappresentano la struttura di un programma C#.</span><span class="sxs-lookup"><span data-stu-id="3761e-129">It's no longer text strings, but data that represents the structure of a C# program.</span></span>

<span data-ttu-id="3761e-130">Per iniziare, è necessario installare **.NET Compiler Platform SDK**:</span><span class="sxs-lookup"><span data-stu-id="3761e-130">To get started, you'll need to install the **.NET Compiler Platform SDK**:</span></span>

[!INCLUDE[interactive-note](~/includes/roslyn-installation.md)]

## <a name="understanding-syntax-trees"></a><span data-ttu-id="3761e-131">Informazioni sugli alberi della sintassi</span><span class="sxs-lookup"><span data-stu-id="3761e-131">Understanding syntax trees</span></span>

<span data-ttu-id="3761e-132">È possibile usare l'API Syntax per qualsiasi analisi della struttura di codice C#.</span><span class="sxs-lookup"><span data-stu-id="3761e-132">You use the Syntax API for any analysis of the structure of C# code.</span></span> <span data-ttu-id="3761e-133">L'**API Syntax** espone i parser, gli alberi della sintassi e le utilità per l'analisi e costruzione di alberi della sintassi.</span><span class="sxs-lookup"><span data-stu-id="3761e-133">The **Syntax API** exposes the parsers, the syntax trees, and utilities for analyzing and constructing syntax trees.</span></span> <span data-ttu-id="3761e-134">Si tratta del modo in cui si cercano elementi di sintassi specifici nel codice o si legge il codice per un programma.</span><span class="sxs-lookup"><span data-stu-id="3761e-134">It's how you search code for specific syntax elements or read the code for a program.</span></span>

<span data-ttu-id="3761e-135">Un albero della sintassi è una struttura di dati usata dai compilatori C# e Visual Basic per comprendere i programmi C# e Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="3761e-135">A syntax tree is a data structure used by the C# and Visual Basic compilers to understand C# and Visual Basic programs.</span></span> <span data-ttu-id="3761e-136">Gli alberi della sintassi vengono prodotti dallo stesso parser eseguito quando viene compilato un progetto o uno sviluppatore preme F5.</span><span class="sxs-lookup"><span data-stu-id="3761e-136">Syntax trees are produced by the same parser that runs when a project is built or a developer hits F5.</span></span> <span data-ttu-id="3761e-137">Gli alberi della sintassi garantiscono la totale fedeltà al linguaggio. Ogni elemento di informazioni in un file di codice è rappresentato nell'albero.</span><span class="sxs-lookup"><span data-stu-id="3761e-137">The syntax trees have full-fidelity with the language; every bit of information in a code file is represented in the tree.</span></span> <span data-ttu-id="3761e-138">La scrittura di un albero della sintassi in formato di testo riproduce l'esatto testo originale analizzato.</span><span class="sxs-lookup"><span data-stu-id="3761e-138">Writing a syntax tree to text reproduces the exact original text that was parsed.</span></span> <span data-ttu-id="3761e-139">Gli alberi di sintassi sono anche **non modificabili**, ovvero non possono essere mai modificati dopo la creazione.</span><span class="sxs-lookup"><span data-stu-id="3761e-139">The syntax trees are also **immutable**; once created a syntax tree can never be changed.</span></span> <span data-ttu-id="3761e-140">I consumer degli alberi possono analizzarli su più thread, senza blocchi o altre misure di concorrenza, dando per scontato che i dati non cambiano mai.</span><span class="sxs-lookup"><span data-stu-id="3761e-140">Consumers of the trees can analyze the trees on multiple threads, without locks or other concurrency measures, knowing the data never changes.</span></span> <span data-ttu-id="3761e-141">È possibile usare le API per creare nuovi alberi risultanti dalla modifica di un albero esistente.</span><span class="sxs-lookup"><span data-stu-id="3761e-141">You can use APIs to create new trees that are the result of modifying an existing tree.</span></span>

<span data-ttu-id="3761e-142">I quattro principali blocchi predefiniti degli alberi della sintassi sono:</span><span class="sxs-lookup"><span data-stu-id="3761e-142">The four primary building blocks of syntax trees are:</span></span>

* <span data-ttu-id="3761e-143">La classe <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType>, un'istanza della quale rappresenta l'intero albero di analisi.</span><span class="sxs-lookup"><span data-stu-id="3761e-143">The <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType> class, an instance of which represents an entire parse tree.</span></span> <span data-ttu-id="3761e-144"><xref:Microsoft.CodeAnalysis.SyntaxTree> è una classe astratta con derivati specifici del linguaggio.</span><span class="sxs-lookup"><span data-stu-id="3761e-144"><xref:Microsoft.CodeAnalysis.SyntaxTree> is an abstract class that has language-specific derivatives.</span></span> <span data-ttu-id="3761e-145">Utilizzare i metodi di <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree?displayProperty=nameWithType> analisi <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree?displayProperty=nameWithType>della classe (or ) per analizzare il testo in C o Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="3761e-145">You use the parse methods of the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree?displayProperty=nameWithType> (or <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree?displayProperty=nameWithType>) class to parse text in C# or Visual Basic.</span></span>
* <span data-ttu-id="3761e-146">La classe <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>, le cui istanze rappresentano costrutti sintattici, come dichiarazioni, istruzioni, clausole ed espressioni.</span><span class="sxs-lookup"><span data-stu-id="3761e-146">The <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType> class, instances of which represent syntactic constructs such as declarations, statements, clauses, and expressions.</span></span>
* <span data-ttu-id="3761e-147">La struttura <xref:Microsoft.CodeAnalysis.SyntaxToken?displayProperty=nameWithType>, che rappresenta parole chiave, identificatori, operatori o segni di punteggiatura singoli.</span><span class="sxs-lookup"><span data-stu-id="3761e-147">The <xref:Microsoft.CodeAnalysis.SyntaxToken?displayProperty=nameWithType> structure, which represents an individual keyword, identifier, operator, or punctuation.</span></span>
* <span data-ttu-id="3761e-148">E infine la struttura <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType>, che rappresenta elementi di informazioni sintatticamente non significativi, come lo spazio vuoto tra i token, le direttive di pre-elaborazione e i commenti.</span><span class="sxs-lookup"><span data-stu-id="3761e-148">And lastly the <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType> structure, which represents syntactically insignificant bits of information such as the white space between tokens, preprocessing directives, and comments.</span></span>

<span data-ttu-id="3761e-149">Gli elementi semplici, i token e i nodi sono composti in modo gerarchico per formare un albero che rappresenta completamente tutti gli elementi in un frammento di codice Visual Basic o C#.</span><span class="sxs-lookup"><span data-stu-id="3761e-149">Trivia, tokens, and nodes are composed hierarchically to form a tree that completely represents everything in a fragment of Visual Basic or C# code.</span></span> <span data-ttu-id="3761e-150">È possibile visualizzare questa struttura usando la finestra **Syntax Visualizer** (Visualizzatore sintassi).</span><span class="sxs-lookup"><span data-stu-id="3761e-150">You can see this structure using the **Syntax Visualizer** window.</span></span> <span data-ttu-id="3761e-151">In Visual Studio scegliere **Visualizza** > **altro** > **visualizzatore sintassi**Windows .</span><span class="sxs-lookup"><span data-stu-id="3761e-151">In Visual Studio, choose **View** > **Other Windows** > **Syntax Visualizer**.</span></span> <span data-ttu-id="3761e-152">Ad esempio, il file di origine C# precedente esaminato nella finestra **Syntax Visualizer** (Visualizzatore sintassi) ha l'aspetto illustrato nella figura seguente:</span><span class="sxs-lookup"><span data-stu-id="3761e-152">For example, the preceding C# source file examined using the **Syntax Visualizer** looks like the following figure:</span></span>

<span data-ttu-id="3761e-153">**SyntaxNode**: blu | **SyntaxToken**: verde | **SyntaxTrivia**: rosso ![File di codice C#](media/walkthrough-csharp-syntax-figure1.png)</span><span class="sxs-lookup"><span data-stu-id="3761e-153">**SyntaxNode**: Blue | **SyntaxToken**: Green | **SyntaxTrivia**: Red ![C# Code File](media/walkthrough-csharp-syntax-figure1.png)</span></span>

<span data-ttu-id="3761e-154">Esplorando questa struttura ad albero, è possibile trovare qualsiasi istruzione, espressione, token o spazio vuoto in un file di codice.</span><span class="sxs-lookup"><span data-stu-id="3761e-154">By navigating this tree structure, you can find any statement, expression, token, or bit of white space in a code file.</span></span>

<span data-ttu-id="3761e-155">Anche se è possibile trovare qualsiasi elemento in un file di codice usando le API Syntax, la maggior parte degli scenari d'uso riguarda l'analisi di piccoli frammenti di codice o la ricerca di istruzioni o frammenti specifici.</span><span class="sxs-lookup"><span data-stu-id="3761e-155">While you can find anything in a code file using the Syntax APIs, most scenarios involve examining small snippets of code, or searching for particular statements or fragments.</span></span> <span data-ttu-id="3761e-156">Gli esempi che seguono mostrano due usi tipici per esplorare la struttura del codice o cercare singole istruzioni.</span><span class="sxs-lookup"><span data-stu-id="3761e-156">The two examples that follow show typical uses to browse the structure of code, or search for single statements.</span></span>

## <a name="traversing-trees"></a><span data-ttu-id="3761e-157">Attraversamento degli alberi</span><span class="sxs-lookup"><span data-stu-id="3761e-157">Traversing trees</span></span>

<span data-ttu-id="3761e-158">È possibile esaminare i nodi in un albero della sintassi in due modi.</span><span class="sxs-lookup"><span data-stu-id="3761e-158">You can examine the nodes in a syntax tree in two ways.</span></span> <span data-ttu-id="3761e-159">È possibile attraversare l'albero per esaminare ogni nodo oppure è possibile eseguire query per recuperare elementi o nodi specifici.</span><span class="sxs-lookup"><span data-stu-id="3761e-159">You can traverse the tree to examine each node, or you can query for specific elements or nodes.</span></span>

### <a name="manual-traversal"></a><span data-ttu-id="3761e-160">Attraversamento manuale</span><span class="sxs-lookup"><span data-stu-id="3761e-160">Manual traversal</span></span>

<span data-ttu-id="3761e-161">È possibile visualizzare il codice completato per l'esempio nel [repository GitHub](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SyntaxQuickStart).</span><span class="sxs-lookup"><span data-stu-id="3761e-161">You can see the finished code for this sample in [our GitHub repository](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SyntaxQuickStart).</span></span>

> [!NOTE]
> <span data-ttu-id="3761e-162">I tipi di albero della sintassi usano l'ereditarietà per descrivere i diversi elementi della sintassi validi in posizioni diverse nel programma.</span><span class="sxs-lookup"><span data-stu-id="3761e-162">The Syntax Tree types use inheritance to describe the different syntax elements that are valid at different locations in the program.</span></span> <span data-ttu-id="3761e-163">L'uso di queste API spesso significa eseguire il cast di proprietà o membri di raccolte in tipi derivati specifici.</span><span class="sxs-lookup"><span data-stu-id="3761e-163">Using these APIs often means casting properties or collection members to specific derived types.</span></span> <span data-ttu-id="3761e-164">Negli esempi seguenti, l'assegnazione e i cast sono istruzioni separate, con variabili tipizzate in modo esplicito.</span><span class="sxs-lookup"><span data-stu-id="3761e-164">In the following examples, the assignment and the casts are separate statements, using explicitly typed variables.</span></span> <span data-ttu-id="3761e-165">È possibile leggere il codice per visualizzare i tipi restituiti dell'API e il tipo di runtime degli oggetti restituiti.</span><span class="sxs-lookup"><span data-stu-id="3761e-165">You can read the code to see the return types of the API and the runtime type of the objects returned.</span></span> <span data-ttu-id="3761e-166">In pratica, è più comune usare variabili tipizzate in modo implicito e basarsi sui nomi delle API per descrivere il tipo di oggetti in corso di analisi.</span><span class="sxs-lookup"><span data-stu-id="3761e-166">In practice, it's more common to use implicitly typed variables and rely on API names to describe the type of objects being examined.</span></span>

<span data-ttu-id="3761e-167">Creare un nuovo progetto C# **Stand-Alone Code Analysis Tool** (Strumento di analisi del codice autonomo):</span><span class="sxs-lookup"><span data-stu-id="3761e-167">Create a new C# **Stand-Alone Code Analysis Tool** project:</span></span>

* <span data-ttu-id="3761e-168">In Visual Studio scegliere **File** > **nuovo** > **progetto** per visualizzare la finestra di dialogo Nuovo progetto.</span><span class="sxs-lookup"><span data-stu-id="3761e-168">In Visual Studio, choose **File** > **New** > **Project** to display the New Project dialog.</span></span>
* <span data-ttu-id="3761e-169">In**Estensibilità** **di Visual C,** > scegliere **Strumento di analisi**del codice autonomo .</span><span class="sxs-lookup"><span data-stu-id="3761e-169">Under **Visual C#** > **Extensibility**, choose **Stand-Alone Code Analysis Tool**.</span></span>
* <span data-ttu-id="3761e-170">Denominare il progetto "**SyntaxTreeManualTraversal**" e fare clic su OK.</span><span class="sxs-lookup"><span data-stu-id="3761e-170">Name your project "**SyntaxTreeManualTraversal**" and click OK.</span></span>

<span data-ttu-id="3761e-171">Verrà analizzato il semplice programma "Hello World!"</span><span class="sxs-lookup"><span data-stu-id="3761e-171">You're going to analyze the basic "Hello World!"</span></span> <span data-ttu-id="3761e-172">mostrato in precedenza.</span><span class="sxs-lookup"><span data-stu-id="3761e-172">program shown earlier.</span></span>
<span data-ttu-id="3761e-173">Aggiungere il testo per il programma Hello World come costante nella classe `Program`:</span><span class="sxs-lookup"><span data-stu-id="3761e-173">Add the text for the Hello World program as a constant in your `Program` class:</span></span>

[!code-csharp[Declare the program text](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#1 "Declare a constant string for the program text to analyze")]

<span data-ttu-id="3761e-174">Aggiungere poi il codice seguente per creare l'**albero della sintassi** per il testo del codice nella costante `programText`.</span><span class="sxs-lookup"><span data-stu-id="3761e-174">Next, add the following code to build the **syntax tree** for the code text in the `programText` constant.</span></span>  <span data-ttu-id="3761e-175">Aggiungere la riga seguente al metodo `Main`:</span><span class="sxs-lookup"><span data-stu-id="3761e-175">Add the following line to your `Main` method:</span></span>

[!code-csharp[Create the tree](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#2 "Create the syntax tree")]

<span data-ttu-id="3761e-176">Queste due righe creano l'albero e ne recuperano il nodo radice.</span><span class="sxs-lookup"><span data-stu-id="3761e-176">Those two lines create the tree and retrieve the root node of that tree.</span></span> <span data-ttu-id="3761e-177">È ora possibile esaminare i nodi dell'albero.</span><span class="sxs-lookup"><span data-stu-id="3761e-177">You can now examine the nodes in the tree.</span></span> <span data-ttu-id="3761e-178">Aggiungere queste righe al metodo `Main` per visualizzare alcune delle proprietà del nodo radice nell'albero:</span><span class="sxs-lookup"><span data-stu-id="3761e-178">Add these lines to your `Main` method to display some of the properties of the root node in the tree:</span></span>

[!code-csharp[Examine the root node](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#3 "Examine the root node")]

<span data-ttu-id="3761e-179">Eseguire l'applicazione per vedere cosa ha individuato il codice sul nodo radice in questo albero.</span><span class="sxs-lookup"><span data-stu-id="3761e-179">Run the application to see what your code has discovered about the root node in this tree.</span></span>

<span data-ttu-id="3761e-180">In genere, l'attraversamento del codice viene eseguito per acquisire informazioni sul codice.</span><span class="sxs-lookup"><span data-stu-id="3761e-180">Typically, you'd traverse the tree to learn about the code.</span></span> <span data-ttu-id="3761e-181">In questo esempio, viene analizzato codice noto per esplorare le API.</span><span class="sxs-lookup"><span data-stu-id="3761e-181">In this example, you're analyzing code you know to explore the APIs.</span></span> <span data-ttu-id="3761e-182">Aggiungere il codice seguente per esaminare il primo membro del nodo `root`:</span><span class="sxs-lookup"><span data-stu-id="3761e-182">Add the following code to examine the first member of the `root` node:</span></span>

[!code-csharp[Find the first member](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#4 "Find the first member")]

<span data-ttu-id="3761e-183">Tale membro è di tipo <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="3761e-183">That member is a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3761e-184">e rappresenta tutto nell'ambito della dichiarazione `namespace HelloWorld`.</span><span class="sxs-lookup"><span data-stu-id="3761e-184">It represents everything in the scope of the `namespace HelloWorld` declaration.</span></span> <span data-ttu-id="3761e-185">Aggiungere il codice seguente per individuare i nodi dichiarati all'interno dello spazio dei nomi `HelloWorld`:</span><span class="sxs-lookup"><span data-stu-id="3761e-185">Add the following code to examine what nodes are declared inside the `HelloWorld` namespace:</span></span>

[!code-csharp[Find the class declaration](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#5 "Find the class declaration")]

<span data-ttu-id="3761e-186">Eseguire il programma per verificare quanto appreso.</span><span class="sxs-lookup"><span data-stu-id="3761e-186">Run the program to see what you've learned.</span></span>

<span data-ttu-id="3761e-187">Ora che è noto che la dichiarazione è un <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax?displayProperty=nameWithType>, dichiarare una nuova variabile di quel tipo per esaminare la dichiarazione di classe.</span><span class="sxs-lookup"><span data-stu-id="3761e-187">Now that you know the declaration is a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax?displayProperty=nameWithType>, declare a new variable of that type to examine the class declaration.</span></span> <span data-ttu-id="3761e-188">Questa classe contiene solo un membro: il metodo `Main`.</span><span class="sxs-lookup"><span data-stu-id="3761e-188">This class only contains one member: the `Main` method.</span></span> <span data-ttu-id="3761e-189">Aggiungere il codice seguente per trovare il metodo `Main` ed eseguirne il cast su <xref:Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3761e-189">Add the following code to find the `Main` method, and cast it to a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax?displayProperty=nameWithType>.</span></span>

[!code-csharp[Find the main declaration](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#6 "Find the main declaration")]

<span data-ttu-id="3761e-190">Il nodo della dichiarazione del metodo contiene tutte le informazioni sintattiche sul metodo.</span><span class="sxs-lookup"><span data-stu-id="3761e-190">The method declaration node contains all the syntactic information about the method.</span></span> <span data-ttu-id="3761e-191">A questo punto verranno visualizzati il tipo restituito del metodo `Main`, il numero e i tipi degli argomenti e il testo del corpo del metodo.</span><span class="sxs-lookup"><span data-stu-id="3761e-191">Let's display the return type of the `Main` method, the number and types of the arguments, and the body text of the method.</span></span> <span data-ttu-id="3761e-192">Aggiungere il codice seguente:</span><span class="sxs-lookup"><span data-stu-id="3761e-192">Add the following code:</span></span>

[!code-csharp[Examine the syntax of the main method](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#7 "Display information about the main method")]

<span data-ttu-id="3761e-193">Eseguire il programma per visualizzare tutte le informazioni individuate su questo programma:</span><span class="sxs-lookup"><span data-stu-id="3761e-193">Run the program to see all the information you've discovered about this program:</span></span>

```text
The tree is a CompilationUnit node.
The tree has 1 elements in it.
The tree has 4 using statements. They are:
        System
        System.Collections
        System.Linq
        System.Text
The first member is a NamespaceDeclaration.
There are 1 members declared in this namespace.
The first member is a ClassDeclaration.
There are 1 members declared in the Program class.
The first member is a MethodDeclaration.
The return type of the Main method is void.
The method has 1 parameters.
The type of the args parameter is string[].
The body text of the Main method follows:
        {
            Console.WriteLine("Hello, World!");
        }
```

### <a name="query-methods"></a><span data-ttu-id="3761e-194">Metodi di query</span><span class="sxs-lookup"><span data-stu-id="3761e-194">Query methods</span></span>

<span data-ttu-id="3761e-195">Oltre ad attraversare gli alberi, è anche possibile esplorare l'albero della sintassi usando i metodi di query definiti in <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3761e-195">In addition to traversing trees, you can also explore the syntax tree using the query methods defined on <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3761e-196">Questi metodi dovrebbero essere immediatamente familiari a chiunque abbia familiarità con XPath.</span><span class="sxs-lookup"><span data-stu-id="3761e-196">These methods should be immediately familiar to anyone familiar with XPath.</span></span> <span data-ttu-id="3761e-197">Per trovare rapidamente elementi in un albero, è possibile usare questi metodi con LINQ.</span><span class="sxs-lookup"><span data-stu-id="3761e-197">You can use these methods with LINQ to quickly find things in a tree.</span></span> <span data-ttu-id="3761e-198"><xref:Microsoft.CodeAnalysis.SyntaxNode> include metodi di query, come <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>, <xref:Microsoft.CodeAnalysis.SyntaxNode.AncestorsAndSelf%2A> e <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes%2A>.</span><span class="sxs-lookup"><span data-stu-id="3761e-198">The <xref:Microsoft.CodeAnalysis.SyntaxNode> has query methods such as <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>, <xref:Microsoft.CodeAnalysis.SyntaxNode.AncestorsAndSelf%2A> and <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes%2A>.</span></span>

<span data-ttu-id="3761e-199">È possibile usare questi metodi di query per trovare l'argomento del metodo `Main`, in alternativa all'esplorazione dell'albero.</span><span class="sxs-lookup"><span data-stu-id="3761e-199">You can use these query methods to find the argument to the `Main` method as an alternative to navigating the tree.</span></span> <span data-ttu-id="3761e-200">Aggiungere il codice seguente alla fine del metodo `Main`:</span><span class="sxs-lookup"><span data-stu-id="3761e-200">Add the following code to the bottom of your `Main` method:</span></span>

[!code-csharp[Query the tree for the arguments to Main](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#8 "Query the tree for the arguments to Main")]

<span data-ttu-id="3761e-201">La prima istruzione usa un'espressione LINQ e il metodo <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A> per individuare lo stesso parametro, come nell'esempio precedente.</span><span class="sxs-lookup"><span data-stu-id="3761e-201">The first statement uses a LINQ expression and the <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A> method to locate the same parameter as in the previous example.</span></span>

<span data-ttu-id="3761e-202">Eseguire il programma. Si può notare che l'espressione LINQ ha trovato lo stesso parametro individuato con l'esplorazione manuale dell'albero.</span><span class="sxs-lookup"><span data-stu-id="3761e-202">Run the program, and you can see that the LINQ expression found the same parameter as manually navigating the tree.</span></span>

<span data-ttu-id="3761e-203">L'esempio usa istruzioni `WriteLine` per visualizzare informazioni sugli alberi della sintassi durante l'attraversamento.</span><span class="sxs-lookup"><span data-stu-id="3761e-203">The sample uses `WriteLine` statements to display information about the syntax trees as they are traversed.</span></span> <span data-ttu-id="3761e-204">È anche possibile ottenere molte più informazioni eseguendo il programma terminato nel debugger.</span><span class="sxs-lookup"><span data-stu-id="3761e-204">You can also learn much more by running the finished program under the debugger.</span></span> <span data-ttu-id="3761e-205">È possibile esaminare molti più metodi e proprietà che fanno parte dell'albero della sintassi creato per il programma Hello World.</span><span class="sxs-lookup"><span data-stu-id="3761e-205">You can examine more of the properties and methods that are part of the syntax tree created for the hello world program.</span></span>

## <a name="syntax-walkers"></a><span data-ttu-id="3761e-206">Percorrere in modo ricorsivo la sintassi</span><span class="sxs-lookup"><span data-stu-id="3761e-206">Syntax walkers</span></span>

<span data-ttu-id="3761e-207">Spesso è necessario trovare tutti i nodi di un tipo specifico in un albero della sintassi, ad esempio ogni dichiarazione di proprietà in un file.</span><span class="sxs-lookup"><span data-stu-id="3761e-207">Often you want to find all nodes of a specific type in a syntax tree, for example, every property declaration in a file.</span></span> <span data-ttu-id="3761e-208">Con l'estensione della classe <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker?displayProperty=nameWithType> e l'override del metodo <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitPropertyDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax)>, si elabora ogni dichiarazione di proprietà in un albero della sintassi senza conoscerne in anticipo la struttura.</span><span class="sxs-lookup"><span data-stu-id="3761e-208">By extending the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker?displayProperty=nameWithType> class and overriding the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitPropertyDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax)> method, you process every property declaration in a syntax tree without knowing its structure beforehand.</span></span> <span data-ttu-id="3761e-209"><xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> è un tipo specifico di <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor> che visita in modo ricorsivo un nodo e tutti i relativi nodi figlio.</span><span class="sxs-lookup"><span data-stu-id="3761e-209"><xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> is a specific kind of <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor> that recursively visits a node and each of its children.</span></span>

<span data-ttu-id="3761e-210">Questo esempio implementa un <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> che esamina un albero della sintassi.</span><span class="sxs-lookup"><span data-stu-id="3761e-210">This example implements a <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> that examines a syntax tree.</span></span> <span data-ttu-id="3761e-211">Raccoglie le direttive `using` individuate, che non importano uno spazio dei nomi `System`.</span><span class="sxs-lookup"><span data-stu-id="3761e-211">It collects `using` directives it finds that aren't importing a `System` namespace.</span></span>

<span data-ttu-id="3761e-212">Creare un nuovo progetto C# **Stand-Alone Code Analysis Tool** (Strumento di analisi del codice autonomo) e denominarlo "**SyntaxWalker**."</span><span class="sxs-lookup"><span data-stu-id="3761e-212">Create a new C# **Stand-Alone Code Analysis Tool** project; name it "**SyntaxWalker**."</span></span>

<span data-ttu-id="3761e-213">È possibile visualizzare il codice completato per l'esempio nel [repository GitHub](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SyntaxQuickStart).</span><span class="sxs-lookup"><span data-stu-id="3761e-213">You can see the finished code for this sample in [our GitHub repository](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SyntaxQuickStart).</span></span> <span data-ttu-id="3761e-214">L'esempio su GitHub contiene entrambi i progetti descritti in questa esercitazione.</span><span class="sxs-lookup"><span data-stu-id="3761e-214">The sample on GitHub contains both projects described in this tutorial.</span></span>

<span data-ttu-id="3761e-215">Come nell'esempio precedente, è possibile definire una costante stringa per contenere il testo del programma che verrà analizzato:</span><span class="sxs-lookup"><span data-stu-id="3761e-215">As in the previous sample, you can define a string constant to hold the text of the program you're going to analyze:</span></span>

[!code-csharp[Define the code text to analyzer](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/Program.cs#1 "Define the program text to analyze")]

<span data-ttu-id="3761e-216">Questo testo di origine contiene direttive `using` distribuite in quattro diverse posizioni: nel livello file, nello spazio dei nomi di livello superiore e nei due spazi dei nomi annidati.</span><span class="sxs-lookup"><span data-stu-id="3761e-216">This source text contains `using` directives scattered across four different locations: the file-level, in the top-level namespace, and in the two nested namespaces.</span></span> <span data-ttu-id="3761e-217">Questo esempio mette in evidenza uno scenario fondamentale per l'uso della classe <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> per eseguire query nel codice.</span><span class="sxs-lookup"><span data-stu-id="3761e-217">This example highlights a core scenario for using the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> class to query code.</span></span> <span data-ttu-id="3761e-218">Sarebbe un'operazione complessa visitare ogni nodo nell'albero della sintassi radice per trovare le dichiarazioni using.</span><span class="sxs-lookup"><span data-stu-id="3761e-218">It would be cumbersome to visit every node in the root syntax tree to find using declarations.</span></span> <span data-ttu-id="3761e-219">Si crea invece una classe derivata e si esegue l'override del metodo che viene chiamato solo quando il nodo corrente nell'albero è una direttiva using.</span><span class="sxs-lookup"><span data-stu-id="3761e-219">Instead, you create a derived class and override the method that gets called only when the current node in the tree is a using directive.</span></span> <span data-ttu-id="3761e-220">Non vengono eseguite altre operazioni su qualsiasi altro tipo di nodo.</span><span class="sxs-lookup"><span data-stu-id="3761e-220">Your visitor does not do any work on any other node types.</span></span> <span data-ttu-id="3761e-221">Questo singolo metodo esamina ogni istruzione `using` e crea una raccolta degli spazi dei nomi non inclusi nello spazio dei nomi `System`.</span><span class="sxs-lookup"><span data-stu-id="3761e-221">This single method examines each of the `using` statements and builds a collection of the namespaces that aren't in the `System` namespace.</span></span> <span data-ttu-id="3761e-222">Si compila un <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> che esamina tutte le istruzioni `using`, ma solo le istruzioni `using`.</span><span class="sxs-lookup"><span data-stu-id="3761e-222">You build a <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> that examines all the `using` statements, but only the `using` statements.</span></span>

<span data-ttu-id="3761e-223">Dopo aver definito il testo del programma, è necessario creare un `SyntaxTree` e ottenere la radice di tale albero:</span><span class="sxs-lookup"><span data-stu-id="3761e-223">Now that you've defined the program text, you need to create a `SyntaxTree` and get the root of that tree:</span></span>

[!code-csharp[Create the Syntax tree and access the root](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/Program.cs#2 "Create the Syntax tree and access the root node.")]

<span data-ttu-id="3761e-224">Creare poi una nuova classe.</span><span class="sxs-lookup"><span data-stu-id="3761e-224">Next, create a new class.</span></span> <span data-ttu-id="3761e-225">In Visual Studio scegliere **Aggiungi** > **nuovo elemento**.</span><span class="sxs-lookup"><span data-stu-id="3761e-225">In Visual Studio, choose **Project** > **Add New Item**.</span></span> <span data-ttu-id="3761e-226">Nella finestra di dialogo **Aggiungi nuovo elemento** digitare *UsingCollector.cs* come nome del file.</span><span class="sxs-lookup"><span data-stu-id="3761e-226">In the **Add New Item** dialog type *UsingCollector.cs* as the filename.</span></span>

<span data-ttu-id="3761e-227">Implementare la funzionalità del visitatore di `using` nella classe `UsingCollector`.</span><span class="sxs-lookup"><span data-stu-id="3761e-227">You implement the `using` visitor functionality in the `UsingCollector` class.</span></span> <span data-ttu-id="3761e-228">Per iniziare, far derivare la classe `UsingCollector` da <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker>.</span><span class="sxs-lookup"><span data-stu-id="3761e-228">Start by making the `UsingCollector` class derive from <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker>.</span></span>

[!code-csharp[Declare the base class for the using collector](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/UsingCollector.cs#3 "Declare the base class for the UsingCollector")]

<span data-ttu-id="3761e-229">È necessario spazio di archiviazione per i nodi dello spazio dei nomi raccolti.</span><span class="sxs-lookup"><span data-stu-id="3761e-229">You need storage to hold the namespace nodes that you're collecting.</span></span>  <span data-ttu-id="3761e-230">Dichiarare una proprietà pubblica di sola lettura nella classe `UsingCollector`. Questa variabile viene usata per archiviare i nodi <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> trovati:</span><span class="sxs-lookup"><span data-stu-id="3761e-230">Declare a public read-only property in the `UsingCollector` class; you use this variable to store the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> nodes you find:</span></span>

[!code-csharp[Declare storage for the using syntax nodes](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/UsingCollector.cs#4 "Declare storage for the using syntax nodes")]

<span data-ttu-id="3761e-231">La classe di base, <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> implementa la logica per visitare ogni nodo nell'albero della sintassi.</span><span class="sxs-lookup"><span data-stu-id="3761e-231">The base class, <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> implements the logic to visit each node in the syntax tree.</span></span> <span data-ttu-id="3761e-232">La classe derivata esegue l'override dei metodi chiamati per i nodi specifici a cui si è interessati.</span><span class="sxs-lookup"><span data-stu-id="3761e-232">The derived class overrides the methods called for the specific nodes you're interested in.</span></span> <span data-ttu-id="3761e-233">In questo caso, si è interessati a qualsiasi direttiva `using`.</span><span class="sxs-lookup"><span data-stu-id="3761e-233">In this case, you're interested in any `using` directive.</span></span> <span data-ttu-id="3761e-234">Questo significa che è necessario eseguire l'override del metodo <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)>.</span><span class="sxs-lookup"><span data-stu-id="3761e-234">That means you must override the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)> method.</span></span> <span data-ttu-id="3761e-235">L'unico argomento di questo metodo è un oggetto <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3761e-235">The one argument to this method is a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax?displayProperty=nameWithType> object.</span></span> <span data-ttu-id="3761e-236">Ciò rappresenta un vantaggio importante rispetto all'uso dei visitatori: i metodi sottoposti a override vengono chiamati con argomenti di cui è già stato eseguito il cast al tipo di nodo specifico.</span><span class="sxs-lookup"><span data-stu-id="3761e-236">That's an important advantage to using the visitors: they call the overridden methods with arguments already cast to the specific node type.</span></span> <span data-ttu-id="3761e-237">La classe <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax?displayProperty=nameWithType> include una proprietà <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.Name> che archivia il nome dello spazio dei nomi importato.</span><span class="sxs-lookup"><span data-stu-id="3761e-237">The <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax?displayProperty=nameWithType> class has a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.Name> property that stores the name of the namespace being imported.</span></span> <span data-ttu-id="3761e-238">Si tratta di un oggetto <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3761e-238">It is a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3761e-239">Aggiungere il codice seguente nell'override di <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)>:</span><span class="sxs-lookup"><span data-stu-id="3761e-239">Add the following code in the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)> override:</span></span>

[!code-csharp[Examine using nodes for the System namespace](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/UsingCollector.cs#5 "Examine all using nodes for the System namespace.")]

<span data-ttu-id="3761e-240">Come per l'esempio precedente, sono state aggiunte svariate istruzioni `WriteLine` per facilitare la comprensione di questo metodo.</span><span class="sxs-lookup"><span data-stu-id="3761e-240">As with the earlier example, you've added a variety of `WriteLine` statements to aid in understanding of this method.</span></span> <span data-ttu-id="3761e-241">È possibile vedere quando viene chiamato e quali argomenti vengono passati al metodo ogni volta.</span><span class="sxs-lookup"><span data-stu-id="3761e-241">You can see when it's called, and what arguments are passed to it each time.</span></span>

<span data-ttu-id="3761e-242">Infine, è necessario aggiungere due righe di codice per creare `UsingCollector` e fare in modo che visiti il nodo radice raccogliendo tutte le istruzioni `using`.</span><span class="sxs-lookup"><span data-stu-id="3761e-242">Finally, you need to add two lines of code to create the `UsingCollector` and have it visit the root node, collecting all the `using` statements.</span></span> <span data-ttu-id="3761e-243">Aggiungere quindi un ciclo `foreach` per visualizzare tutte le istruzioni `using` trovate dallo strumento di raccolta:</span><span class="sxs-lookup"><span data-stu-id="3761e-243">Then, add a `foreach` loop to display all the `using` statements your collector found:</span></span>

[!code-csharp[Create the UsingCollector and visit the root node.](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/Program.cs#6 "Create the UsingCollector and visit the root node.")]

<span data-ttu-id="3761e-244">Compilare ed eseguire il programma.</span><span class="sxs-lookup"><span data-stu-id="3761e-244">Compile and run the program.</span></span> <span data-ttu-id="3761e-245">Dovrebbe venire visualizzato l'output seguente.</span><span class="sxs-lookup"><span data-stu-id="3761e-245">You should see the following output:</span></span>

```console
        VisitUsingDirective called with System.
        VisitUsingDirective called with System.Collections.Generic.
        VisitUsingDirective called with System.Linq.
        VisitUsingDirective called with System.Text.
        VisitUsingDirective called with Microsoft.CodeAnalysis.
                Success. Adding Microsoft.CodeAnalysis.
        VisitUsingDirective called with Microsoft.CodeAnalysis.CSharp.
                Success. Adding Microsoft.CodeAnalysis.CSharp.
        VisitUsingDirective called with Microsoft.
                Success. Adding Microsoft.
        VisitUsingDirective called with System.ComponentModel.
        VisitUsingDirective called with Microsoft.Win32.
                Success. Adding Microsoft.Win32.
        VisitUsingDirective called with System.Runtime.InteropServices.
        VisitUsingDirective called with System.CodeDom.
        VisitUsingDirective called with Microsoft.CSharp.
                Success. Adding Microsoft.CSharp.
Microsoft.CodeAnalysis
Microsoft.CodeAnalysis.CSharp
Microsoft
Microsoft.Win32
Microsoft.CSharp
Press any key to continue . . .
```

<span data-ttu-id="3761e-246">Congratulazioni!</span><span class="sxs-lookup"><span data-stu-id="3761e-246">Congratulations!</span></span> <span data-ttu-id="3761e-247">È stata usata l'**API Syntax** per individuare tipi specifici di istruzioni e dichiarazioni C# in codice sorgente C#.</span><span class="sxs-lookup"><span data-stu-id="3761e-247">You've used the **Syntax API** to locate specific kinds of C# statements and declarations in C# source code.</span></span>
