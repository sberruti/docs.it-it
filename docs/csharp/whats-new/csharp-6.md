---
title: Novità di C# 6 - Guida a C#
description: Informazioni sulle nuove funzionalità di C# versione 6
ms.date: 12/12/2018
ms.openlocfilehash: da40b4c9d4af0094fdd907c542e971ba55086e0f
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 03/14/2020
ms.locfileid: "79399392"
---
# <a name="whats-new-in-c-6"></a><span data-ttu-id="1851d-103">Novità di C# 6</span><span class="sxs-lookup"><span data-stu-id="1851d-103">What's New in C# 6</span></span>

<span data-ttu-id="1851d-104">La versione 6.0 di C# contiene molte funzionalità che consentono agli sviluppatori di migliorare la produttività.</span><span class="sxs-lookup"><span data-stu-id="1851d-104">The 6.0 release of C# contained many features that improve productivity for developers.</span></span> <span data-ttu-id="1851d-105">L'effetto generale di queste funzionalità è che il codice che si scrive è più conciso e anche più leggibile.</span><span class="sxs-lookup"><span data-stu-id="1851d-105">The overall effect of these features is that you write more concise code that is also more readable.</span></span> <span data-ttu-id="1851d-106">La sintassi è più semplice e lineare per molte delle procedure più comuni.</span><span class="sxs-lookup"><span data-stu-id="1851d-106">The syntax contains less ceremony for many common practices.</span></span> <span data-ttu-id="1851d-107">È più facile visualizzare le finalità di progettazione se la sintassi è più snella.</span><span class="sxs-lookup"><span data-stu-id="1851d-107">It's easier to see the design intent with less ceremony.</span></span> <span data-ttu-id="1851d-108">L'apprendimento approfondito di queste funzionalità consentirà di ottenere una maggiore produttività e di scrivere codice più leggibile,</span><span class="sxs-lookup"><span data-stu-id="1851d-108">Learn these features well, and you'll be more productive and write more readable code.</span></span> <span data-ttu-id="1851d-109">concentrandosi più sulle funzionalità da sviluppare che sui costrutti del linguaggio.</span><span class="sxs-lookup"><span data-stu-id="1851d-109">You can concentrate more on your features than on the constructs of the language.</span></span>

<span data-ttu-id="1851d-110">Il resto di questo articolo offre una panoramica di ognuna di queste funzionalità, con un collegamento per esplorare ciascuna di esse più in dettaglio.</span><span class="sxs-lookup"><span data-stu-id="1851d-110">The rest of this article provides an overview of each of these features, with a link to explore each feature.</span></span> <span data-ttu-id="1851d-111">È anche possibile esplorare le funzionalità in un'[esplorazione interattiva di C# 6](../tutorials/exploration/csharp-6.yml) nella sezione delle esercitazioni.</span><span class="sxs-lookup"><span data-stu-id="1851d-111">You can also explore the features in an [interactive exploration on C# 6](../tutorials/exploration/csharp-6.yml) in the tutorials section.</span></span>

## <a name="read-only-auto-properties"></a><span data-ttu-id="1851d-112">Proprietà automatiche di sola lettura</span><span class="sxs-lookup"><span data-stu-id="1851d-112">Read-only auto-properties</span></span>

<span data-ttu-id="1851d-113">Le *proprietà automatiche di sola lettura* offrono una sintassi più concisa per creare i tipi non modificabili.</span><span class="sxs-lookup"><span data-stu-id="1851d-113">*Read-only auto-properties* provide a more concise syntax to create immutable types.</span></span> <span data-ttu-id="1851d-114">Si dichiara la proprietà automatica solo con una funzione di accesso get:</span><span class="sxs-lookup"><span data-stu-id="1851d-114">You declare the auto-property with only a get accessor:</span></span>

[!code-csharp[ReadOnlyAutoProperty](../../../samples/snippets/csharp/new-in-6/newcode.cs#ReadOnlyAutoProperty)]

<span data-ttu-id="1851d-115">Le proprietà `FirstName` e `LastName` possono essere impostate solo nel corpo del costruttore della stessa classe:</span><span class="sxs-lookup"><span data-stu-id="1851d-115">The `FirstName` and `LastName` properties can be set only in the body of the constructor of the same class:</span></span>

[!code-csharp[ReadOnlyAutoPropertyConstructor](../../../samples/snippets/csharp/new-in-6/newcode.cs#ReadOnlyAutoPropertyConstructor)]

<span data-ttu-id="1851d-116">Tentare di impostare `LastName` in un altro metodo genera un errore di compilazione `CS0200`:</span><span class="sxs-lookup"><span data-stu-id="1851d-116">Trying to set `LastName` in another method generates a `CS0200` compilation error:</span></span>

```csharp
public class Student
{
    public string LastName { get;  }

    public void ChangeName(string newLastName)
    {
        // Generates CS0200: Property or indexer cannot be assigned to -- it is read only
        LastName = newLastName;
    }
}
```

<span data-ttu-id="1851d-117">Questa funzionalità abilita il supporto effettivo del linguaggio per la creazione di tipi non modificabili e per l'uso di sintassi più concisa e pratica per le proprietà automatiche.</span><span class="sxs-lookup"><span data-stu-id="1851d-117">This feature enables true language support for creating immutable types and uses the more concise and convenient auto-property syntax.</span></span>

<span data-ttu-id="1851d-118">Se l'aggiunta di questa sintassi non rimuove un metodo accessibile, si tratta di una [modifica compatibile a livello binario](version-update-considerations.md#binary-compatible-changes).</span><span class="sxs-lookup"><span data-stu-id="1851d-118">If adding this syntax doesn't remove an accessible method, it's a [binary compatible change](version-update-considerations.md#binary-compatible-changes).</span></span>

## <a name="auto-property-initializers"></a><span data-ttu-id="1851d-119">Inizializzatori di proprietà automatiche</span><span class="sxs-lookup"><span data-stu-id="1851d-119">Auto-property initializers</span></span>

<span data-ttu-id="1851d-120">Gli *inizializzatori di proprietà automatiche* permettono di dichiarare il valore iniziale per una proprietà automatica come parte della dichiarazione di proprietà.</span><span class="sxs-lookup"><span data-stu-id="1851d-120">*Auto-property initializers* let you declare the initial value for an auto-property as part of the property declaration.</span></span>

[!code-csharp[Initialization](../../../samples/snippets/csharp/new-in-6/newcode.cs#Initialization)]

<span data-ttu-id="1851d-121">Il membro `Grades` viene inizializzato quando viene dichiarato.</span><span class="sxs-lookup"><span data-stu-id="1851d-121">The `Grades` member is initialized where it's declared.</span></span> <span data-ttu-id="1851d-122">Ciò rende più semplice eseguire l'inizializzazione esattamente una sola volta.</span><span class="sxs-lookup"><span data-stu-id="1851d-122">That makes it easier to perform the initialization exactly once.</span></span> <span data-ttu-id="1851d-123">L'inizializzazione fa parte della dichiarazione di proprietà e rende più semplice l'equivalenza tra l'allocazione della memoria e l'interfaccia pubblica per gli oggetti `Student`.</span><span class="sxs-lookup"><span data-stu-id="1851d-123">The initialization is part of the property declaration, making it easier to equate the storage allocation with the public interface for `Student` objects.</span></span>

## <a name="expression-bodied-function-members"></a><span data-ttu-id="1851d-124">Membri di funzione con corpo di espressione</span><span class="sxs-lookup"><span data-stu-id="1851d-124">Expression-bodied function members</span></span>

<span data-ttu-id="1851d-125">Molti membri scritti dall'utente sono singole istruzioni che possono essere singole espressioni.</span><span class="sxs-lookup"><span data-stu-id="1851d-125">Many members that you write are single statements that could be single expressions.</span></span> <span data-ttu-id="1851d-126">Scrivere invece un membro con corpo di espressione.</span><span class="sxs-lookup"><span data-stu-id="1851d-126">Write an expression-bodied member instead.</span></span> <span data-ttu-id="1851d-127">Funziona per i metodi e le proprietà di sola lettura.</span><span class="sxs-lookup"><span data-stu-id="1851d-127">It works for methods and read-only properties.</span></span> <span data-ttu-id="1851d-128">Ad esempio, un override di `ToString()` è spesso un ottimo candidato:</span><span class="sxs-lookup"><span data-stu-id="1851d-128">For example, an override of `ToString()` is often a great candidate:</span></span>

[!code-csharp[ToStringExpressionMember](../../../samples/snippets/csharp/new-in-6/newcode.cs#ToStringExpressionMember)]

<span data-ttu-id="1851d-129">È anche possibile usare questa sintassi per le proprietà di sola lettura:</span><span class="sxs-lookup"><span data-stu-id="1851d-129">You can also use this syntax for read-only properties:</span></span>

[!code-csharp[FullNameExpressionMember](../../../samples/snippets/csharp/new-in-6/newcode.cs#FullNameExpressionMember)]

<span data-ttu-id="1851d-130">La modifica di un membro esistente in un membro con corpo di espressione è una [modifica compatibile a livello binario](version-update-considerations.md#binary-compatible-changes).</span><span class="sxs-lookup"><span data-stu-id="1851d-130">Changing an existing member to an expression bodied member is a [binary compatible change](version-update-considerations.md#binary-compatible-changes).</span></span>

## <a name="using-static"></a><span data-ttu-id="1851d-131">using static</span><span class="sxs-lookup"><span data-stu-id="1851d-131">using static</span></span>

<span data-ttu-id="1851d-132">L'elemento *using static* consente di importare i metodi statici di una singola classe.</span><span class="sxs-lookup"><span data-stu-id="1851d-132">The *using static* enhancement enables you to import the static methods of a single class.</span></span> <span data-ttu-id="1851d-133">Specificare la classe in uso:</span><span class="sxs-lookup"><span data-stu-id="1851d-133">You specify the class you're using:</span></span>

[!code-csharp[UsingStaticMath](../../../samples/snippets/csharp/new-in-6/newcode.cs#UsingStaticMath)]

<span data-ttu-id="1851d-134"><xref:System.Math> non contiene alcun metodo di istanza.</span><span class="sxs-lookup"><span data-stu-id="1851d-134">The <xref:System.Math> does not contain any instance methods.</span></span> <span data-ttu-id="1851d-135">È possibile usare `using static` anche per importare i metodi statici di una classe per una classe con metodi sia statici che di istanza.</span><span class="sxs-lookup"><span data-stu-id="1851d-135">You can also use `using static` to import a class' static methods for a class that has both static and instance methods.</span></span> <span data-ttu-id="1851d-136">Uno degli esempi più utili è <xref:System.String>:</span><span class="sxs-lookup"><span data-stu-id="1851d-136">One of the most useful examples is <xref:System.String>:</span></span>

[!code-csharp[UsingStatic](../../../samples/snippets/csharp/new-in-6/newcode.cs#UsingStatic)]

> [!NOTE]
> <span data-ttu-id="1851d-137">In un'istruzione using static è necessario usare il nome completo della classe, `System.String`.</span><span class="sxs-lookup"><span data-stu-id="1851d-137">You must use the fully qualified class name, `System.String`  in a static using statement.</span></span>  <span data-ttu-id="1851d-138">Non è invece possibile usare la parola chiave `string`.</span><span class="sxs-lookup"><span data-stu-id="1851d-138">You cannot use the `string` keyword instead.</span></span>

<span data-ttu-id="1851d-139">Se importati da un'istruzione `static using`, i metodi di estensione sono inclusi nell'ambito solo se vengono chiamati usando la sintassi di chiamata del metodo di estensione,</span><span class="sxs-lookup"><span data-stu-id="1851d-139">When imported from a `static using` statement, extension methods are only in scope when called using the extension method invocation syntax.</span></span> <span data-ttu-id="1851d-140">non se vengono chiamati come metodi statici.</span><span class="sxs-lookup"><span data-stu-id="1851d-140">They aren't in scope when called as a static method.</span></span> <span data-ttu-id="1851d-141">Questa situazione si verifica spesso nelle query LINQ.</span><span class="sxs-lookup"><span data-stu-id="1851d-141">You'll often see this in LINQ queries.</span></span> <span data-ttu-id="1851d-142">È possibile importare il modello LINQ importando <xref:System.Linq.Enumerable> o <xref:System.Linq.Queryable>.</span><span class="sxs-lookup"><span data-stu-id="1851d-142">You can import the LINQ pattern by importing <xref:System.Linq.Enumerable>, or <xref:System.Linq.Queryable>.</span></span>

[!code-csharp[UsingStaticLinq](../../../samples/snippets/csharp/new-in-6/newcode.cs#usingStaticLinq)]

<span data-ttu-id="1851d-143">In genere i metodi di estensione vengono chiamati usando espressioni di chiamata del metodo di estensione.</span><span class="sxs-lookup"><span data-stu-id="1851d-143">You typically call extension methods using extension method invocation expressions.</span></span> <span data-ttu-id="1851d-144">Nei rari casi in cui vengono chiamati tramite la sintassi di chiamata del metodo statico, l'aggiunta del nome della classe risolve l'ambiguità.</span><span class="sxs-lookup"><span data-stu-id="1851d-144">Adding the class name in the rare case where you call them using static method call syntax resolves ambiguity.</span></span>

<span data-ttu-id="1851d-145">La direttiva `static using` importa anche tutti i tipi annidati.</span><span class="sxs-lookup"><span data-stu-id="1851d-145">The `static using` directive also imports any nested types.</span></span> <span data-ttu-id="1851d-146">È possibile fare riferimento a tutti i tipi nidificati senza qualifica.</span><span class="sxs-lookup"><span data-stu-id="1851d-146">You can reference any nested types without qualification.</span></span>

## <a name="null-conditional-operators"></a><span data-ttu-id="1851d-147">Operatori condizionali Null</span><span class="sxs-lookup"><span data-stu-id="1851d-147">Null-conditional operators</span></span>

<span data-ttu-id="1851d-148">L'*operatore condizionale Null* rende i controlli Null molto più semplici e fluidi.</span><span class="sxs-lookup"><span data-stu-id="1851d-148">The *null conditional operator* makes null checks much easier and fluid.</span></span> <span data-ttu-id="1851d-149">Sostituire l'operatore di accesso ai membri `.` con `?.`:</span><span class="sxs-lookup"><span data-stu-id="1851d-149">Replace the member access `.` with `?.`:</span></span>

[!code-csharp[NullConditional](../../../samples/snippets/csharp/new-in-6/program.cs#NullConditional)]

<span data-ttu-id="1851d-150">Nell'esempio precedente alla variabile `first` è assegnato `null` se l'oggetto person è `null`.</span><span class="sxs-lookup"><span data-stu-id="1851d-150">In the preceding example, the variable `first` is assigned `null` if the person object is `null`.</span></span> <span data-ttu-id="1851d-151">In caso contrario, viene assegnato il valore della proprietà `FirstName`.</span><span class="sxs-lookup"><span data-stu-id="1851d-151">Otherwise, it is assigned the value of the `FirstName` property.</span></span> <span data-ttu-id="1851d-152">In particolare, l'operatore `?.` indica che questa riga di codice non genera un'eccezione `NullReferenceException` se la variabile `person` è `null`.</span><span class="sxs-lookup"><span data-stu-id="1851d-152">Most importantly, the `?.` means that this line of code doesn't generate a `NullReferenceException` if the `person` variable is `null`.</span></span> <span data-ttu-id="1851d-153">Provoca invece un corto circuito e restituisce `null`.</span><span class="sxs-lookup"><span data-stu-id="1851d-153">Instead, it short-circuits and returns `null`.</span></span> <span data-ttu-id="1851d-154">È anche possibile usare un operatore condizionale Null per l'accesso a una matrice o a un indicizzatore.</span><span class="sxs-lookup"><span data-stu-id="1851d-154">You can also use a null conditional operator for array or indexer access.</span></span> <span data-ttu-id="1851d-155">Sostituire `[]` con `?[]` nell'espressione di indice.</span><span class="sxs-lookup"><span data-stu-id="1851d-155">Replace `[]` with `?[]` in the index expression.</span></span>

<span data-ttu-id="1851d-156">L'espressione seguente restituisce un oggetto `string`, indipendentemente dal valore di `person`.</span><span class="sxs-lookup"><span data-stu-id="1851d-156">The following expression returns a `string`, regardless of the value of `person`.</span></span> <span data-ttu-id="1851d-157">Spesso questo costrutto viene usato con l'operatore *Null ridondante* per assegnare valori predefiniti quando una delle proprietà è `null`.</span><span class="sxs-lookup"><span data-stu-id="1851d-157">You often use this construct with the *null coalescing* operator to assign default values when one of the properties is `null`.</span></span> <span data-ttu-id="1851d-158">Se l'espressione genera un corto circuito, il valore `null` restituito è tipizzato in modo da corrispondere all'espressione completa.</span><span class="sxs-lookup"><span data-stu-id="1851d-158">When the expression short-circuits, the `null` value returned is typed to match the full expression.</span></span>

[!code-csharp[NullCoalescing](../../../samples/snippets/csharp/new-in-6/program.cs#NullCoalescing)]

<span data-ttu-id="1851d-159">È possibile usare `?.` anche per chiamare i metodi in modo condizionale.</span><span class="sxs-lookup"><span data-stu-id="1851d-159">You can also use `?.` to conditionally invoke methods.</span></span> <span data-ttu-id="1851d-160">L'uso più comune delle funzioni membro con l'operatore condizionale Null è chiamare in modo sicuro i delegati (o i gestori degli eventi) che possono essere `null`.</span><span class="sxs-lookup"><span data-stu-id="1851d-160">The most common use of member functions  with the null conditional operator is to safely invoke delegates (or event handlers) that may be `null`.</span></span>  <span data-ttu-id="1851d-161">A tale scopo si chiama il metodo `Invoke` del delegato usando l'operatore `?.` per accedere al membro.</span><span class="sxs-lookup"><span data-stu-id="1851d-161">You'll call the delegate's `Invoke` method using the `?.` operator to access the member.</span></span> <span data-ttu-id="1851d-162">È possibile vedere un esempio nell'articolo sui [criteri per i delegati](../delegates-patterns.md#handling-null-delegates).</span><span class="sxs-lookup"><span data-stu-id="1851d-162">You can see an example in the [delegate patterns](../delegates-patterns.md#handling-null-delegates) article.</span></span>

<span data-ttu-id="1851d-163">Le regole dell'operatore `?.` garantiscono che il lato sinistro dell'operatore venga valutato una sola volta.</span><span class="sxs-lookup"><span data-stu-id="1851d-163">The rules of the `?.` operator ensure that the left-hand side of the operator is evaluated only once.</span></span> <span data-ttu-id="1851d-164">Questo abilita molti idiomi, incluso l'esempio seguente che usa i gestori degli eventi:</span><span class="sxs-lookup"><span data-stu-id="1851d-164">It enables many idioms, including the following example using event handlers:</span></span>

```csharp
// preferred in C# 6:
this.SomethingHappened?.Invoke(this, eventArgs);
```

<span data-ttu-id="1851d-165">Se ci si assicura che il lato sinistro venga valutato una sola volta, è anche possibile usare qualsiasi espressione, incluse le chiamate a metodi, nel lato sinistro dell'operatore `?.`</span><span class="sxs-lookup"><span data-stu-id="1851d-165">Ensuring that the left side is evaluated only once also enables you to use any expression, including method calls, on the left side of the `?.`</span></span>

## <a name="string-interpolation"></a><span data-ttu-id="1851d-166">Interpolazione di stringhe</span><span class="sxs-lookup"><span data-stu-id="1851d-166">String interpolation</span></span>

<span data-ttu-id="1851d-167">Con C# 6 la nuova funzionalità di [interpolazione di stringhe](../language-reference/tokens/interpolated.md) consente di incorporare espressioni in una stringa.</span><span class="sxs-lookup"><span data-stu-id="1851d-167">With C# 6, the new [string interpolation](../language-reference/tokens/interpolated.md) feature enables you to embed expressions in a string.</span></span> <span data-ttu-id="1851d-168">È sufficiente anteporre `$` alla stringa e usare espressioni tra `{` e `}`, anziché ordinali:</span><span class="sxs-lookup"><span data-stu-id="1851d-168">Simply preface the string with `$`and use expressions between `{` and `}` instead of ordinals:</span></span>

[!code-csharp[stringInterpolation](../../../samples/snippets/csharp/new-in-6/newcode.cs#FullNameExpressionMember)]

<span data-ttu-id="1851d-169">Questo esempio usa proprietà per le espressioni sostituite.</span><span class="sxs-lookup"><span data-stu-id="1851d-169">This example uses properties for the substituted expressions.</span></span> <span data-ttu-id="1851d-170">È possibile usare qualsiasi espressione.</span><span class="sxs-lookup"><span data-stu-id="1851d-170">You can use any expression.</span></span> <span data-ttu-id="1851d-171">Ad esempio, è possibile calcolare la media dei voti di uno studente come parte dell'interpolazione:</span><span class="sxs-lookup"><span data-stu-id="1851d-171">For example, you could compute a student's grade point average as part of the interpolation:</span></span>

[!code-csharp[stringInterpolationFormat](../../../samples/snippets/csharp/new-in-6/newcode.cs#stringInterpolationFormat)]

<span data-ttu-id="1851d-172">La riga di codice precedente formatta il valore per `Grades.Average()` come numero a virgola mobile con due cifre decimali.</span><span class="sxs-lookup"><span data-stu-id="1851d-172">The preceding line of code formats the value for `Grades.Average()` as a floating-point number with two decimal places.</span></span>

<span data-ttu-id="1851d-173">Spesso può essere necessario formattare la stringa prodotta usando impostazioni cultura specifiche,</span><span class="sxs-lookup"><span data-stu-id="1851d-173">Often, you may need to format the string produced using a specific culture.</span></span> <span data-ttu-id="1851d-174">sfruttando il fatto che l'oggetto prodotto da un'interpolazione di stringhe può essere convertito in modo implicito in <xref:System.FormattableString?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="1851d-174">You use the fact that the object produced by a string interpolation can be implicitly converted to <xref:System.FormattableString?displayProperty=nameWithType>.</span></span> <span data-ttu-id="1851d-175">L'istanza <xref:System.FormattableString> contiene la stringa di formato composito e i risultati della valutazione delle espressioni prima della loro conversione in stringhe.</span><span class="sxs-lookup"><span data-stu-id="1851d-175">The <xref:System.FormattableString> instance contains the composite format string and the results of evaluating the expressions before converting them to strings.</span></span> <span data-ttu-id="1851d-176">Usare i metodi <xref:System.FormattableString.ToString(System.IFormatProvider)?displayProperty=nameWithType> per specificare le impostazioni cultura quando si formatta una stringa.</span><span class="sxs-lookup"><span data-stu-id="1851d-176">Use the <xref:System.FormattableString.ToString(System.IFormatProvider)?displayProperty=nameWithType> method to specify the culture when formatting a string.</span></span> <span data-ttu-id="1851d-177">L'esempio seguente produce una stringa con impostazioni cultura tedesche (de-DE).</span><span class="sxs-lookup"><span data-stu-id="1851d-177">The following example produces a string using the German (de-DE) culture.</span></span> <span data-ttu-id="1851d-178">Per impostazione predefinita, le impostazioni cultura tedesche usano il carattere ',' come separatore decimale e il carattere '.' come separatore delle migliaia.</span><span class="sxs-lookup"><span data-stu-id="1851d-178">(By default, the German culture uses the ',' character for the decimal separator, and the '.' character as the thousands separator.)</span></span>

```csharp
FormattableString str = $"Average grade is {s.Grades.Average()}";
var gradeStr = str.ToString(new System.Globalization.CultureInfo("de-DE"));
```

<span data-ttu-id="1851d-179">Per iniziare a usare l'interpolazione di stringhe, vedere l'esercitazione interattiva [Interpolazione di stringhe in C# ](../tutorials/exploration/interpolated-strings.yml), l'articolo [Interpolazione di stringhe](../language-reference/tokens/interpolated.md) e l'esercitazione [Interpolazione di stringhe in C#](../tutorials/string-interpolation.md).</span><span class="sxs-lookup"><span data-stu-id="1851d-179">To get started with string interpolation, see the [String interpolation in C#](../tutorials/exploration/interpolated-strings.yml) interactive tutorial, the [String interpolation](../language-reference/tokens/interpolated.md) article, and the [String interpolation in C#](../tutorials/string-interpolation.md) tutorial.</span></span>

## <a name="exception-filters"></a><span data-ttu-id="1851d-180">Filtri eccezioni</span><span class="sxs-lookup"><span data-stu-id="1851d-180">Exception filters</span></span>

<span data-ttu-id="1851d-181">I *filtri eccezioni* sono clausole che determinano quando deve essere applicata una clausola catch specifica.</span><span class="sxs-lookup"><span data-stu-id="1851d-181">*Exception Filters* are clauses that determine when a given catch clause should be applied.</span></span> <span data-ttu-id="1851d-182">Se l'espressione usata per un filtro eccezioni restituisce `true`, la clausola catch esegue la normale elaborazione per un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="1851d-182">If the expression used for an exception filter evaluates to `true`, the catch clause performs its normal processing on an exception.</span></span> <span data-ttu-id="1851d-183">Se l'espressione restituisce `false`, la clausola `catch` viene ignorata.</span><span class="sxs-lookup"><span data-stu-id="1851d-183">If the expression evaluates to `false`, then the `catch` clause is skipped.</span></span> <span data-ttu-id="1851d-184">Un utilizzo consiste nell'esaminare le informazioni relative a un'eccezione per determinare se una clausola `catch` può elaborare l'eccezione:</span><span class="sxs-lookup"><span data-stu-id="1851d-184">One use is to examine information about an exception to determine if a `catch` clause can process the exception:</span></span>

[!code-csharp[ExceptionFilter](../../../samples/snippets/csharp/new-in-6/NetworkClient.cs#ExceptionFilter)]

## <a name="the-nameof-expression"></a><span data-ttu-id="1851d-185">Espressione `nameof`</span><span class="sxs-lookup"><span data-stu-id="1851d-185">The `nameof` expression</span></span>

<span data-ttu-id="1851d-186">L'espressione [nameof](../language-reference/operators/nameof.md) restituisce il nome di un simbolo.</span><span class="sxs-lookup"><span data-stu-id="1851d-186">The [nameof](../language-reference/operators/nameof.md) expression evaluates to the name of a symbol.</span></span> <span data-ttu-id="1851d-187">È un sistema efficace per garantire il funzionamento degli strumenti ogni volta che è necessario il nome di una variabile, una proprietà o un campo membro.</span><span class="sxs-lookup"><span data-stu-id="1851d-187">It's a great way to get tools working whenever you need the name of a variable, a property, or a member field.</span></span> <span data-ttu-id="1851d-188">Uno degli usi più comuni di `nameof` è specificare il nome di un simbolo che ha causato un'eccezione:</span><span class="sxs-lookup"><span data-stu-id="1851d-188">One of the most common uses for `nameof` is to provide the name of a symbol that caused an exception:</span></span>

[!code-csharp[nameof](../../../samples/snippets/csharp/new-in-6/NewCode.cs#UsingStaticString)]

<span data-ttu-id="1851d-189">Un altro uso riguarda le applicazioni basate su XAML che implementano l'interfaccia `INotifyPropertyChanged`:</span><span class="sxs-lookup"><span data-stu-id="1851d-189">Another use is with XAML-based applications that implement the `INotifyPropertyChanged` interface:</span></span>

[!code-csharp[nameofNotify](../../../samples/snippets/csharp/new-in-6/viewmodel.cs#nameofNotify)]

## <a name="await-in-catch-and-finally-blocks"></a><span data-ttu-id="1851d-190">Await nei blocchi catch e finally</span><span class="sxs-lookup"><span data-stu-id="1851d-190">Await in Catch and Finally blocks</span></span>

<span data-ttu-id="1851d-191">C# 5 presentava diverse limitazioni riguardo al punto in cui posizionare le espressioni `await`.</span><span class="sxs-lookup"><span data-stu-id="1851d-191">C# 5 had several limitations around where you could place `await` expressions.</span></span> <span data-ttu-id="1851d-192">Con C# 6 è ora possibile usare `await` nelle espressioni `catch` o `finally`.</span><span class="sxs-lookup"><span data-stu-id="1851d-192">With C# 6, you can now use `await` in `catch` or `finally` expressions.</span></span> <span data-ttu-id="1851d-193">Questo uso è più frequente negli scenari di registrazione:</span><span class="sxs-lookup"><span data-stu-id="1851d-193">This is most often used with logging scenarios:</span></span>

[!code-csharp[AwaitFinally](../../../samples/snippets/csharp/new-in-6/NetworkClient.cs#AwaitFinally)]

<span data-ttu-id="1851d-194">I dettagli sull'implementazione per l'aggiunta del supporto di `await` all'interno delle clausole `catch` e `finally` assicura che il comportamento sia coerente con il comportamento per il codice sincrono.</span><span class="sxs-lookup"><span data-stu-id="1851d-194">The implementation details for adding `await` support inside `catch` and `finally` clauses ensure that the behavior is consistent with the behavior for synchronous code.</span></span> <span data-ttu-id="1851d-195">Quando il codice eseguito in una clausola `catch` o `finally` genera un elemento, l'esecuzione cerca una clausola `catch` appropriata nel successivo blocco circostante.</span><span class="sxs-lookup"><span data-stu-id="1851d-195">When code executed in a `catch` or `finally` clause throws, execution looks for a suitable `catch` clause in the next surrounding block.</span></span> <span data-ttu-id="1851d-196">Se si è verificata un'eccezione, tale eccezione viene persa.</span><span class="sxs-lookup"><span data-stu-id="1851d-196">If there was a current exception, that exception is lost.</span></span> <span data-ttu-id="1851d-197">Lo stesso accade con le espressioni attese nelle clausole `catch` e `finally`: viene cercato un valore `catch` appropriato e l'eccezione corrente, se presente, viene persa.</span><span class="sxs-lookup"><span data-stu-id="1851d-197">The same happens with awaited expressions in `catch` and `finally` clauses: a suitable `catch` is searched for, and the current exception, if any, is lost.</span></span>  

> [!NOTE]
> <span data-ttu-id="1851d-198">Questo comportamento è il motivo per cui è consigliabile scrivere le clausole `catch` e `finally` con attenzione, per evitare l'introduzione di nuove eccezioni.</span><span class="sxs-lookup"><span data-stu-id="1851d-198">This behavior is the reason it's recommended to write `catch` and `finally` clauses carefully, to avoid introducing new exceptions.</span></span>

## <a name="initialize-associative-collections-using-indexers"></a><span data-ttu-id="1851d-199">Inizializzare le raccolte associative tramite gli indicizzatori</span><span class="sxs-lookup"><span data-stu-id="1851d-199">Initialize associative collections using indexers</span></span>

<span data-ttu-id="1851d-200">Gli *inizializzatori di indice* sono una delle due funzionalità che rendono gli inizializzatori di insieme più coerenti con l'uso degli indici.</span><span class="sxs-lookup"><span data-stu-id="1851d-200">*Index Initializers* is one of two features that make collection initializers more consistent with index usage.</span></span> <span data-ttu-id="1851d-201">Nelle versioni precedenti di C# gli *inizializzatori di insieme* potevano essere usati con le raccolte di stili di sequenza, includendo <xref:System.Collections.Generic.Dictionary%602>, mediante l'aggiunta di coppie chiave/valore racchiuse tra parentesi graffe:</span><span class="sxs-lookup"><span data-stu-id="1851d-201">In earlier releases of C#, you could use *collection initializers* with sequence style collections, including <xref:System.Collections.Generic.Dictionary%602>, by adding braces around key and value pairs:</span></span>

[!code-csharp[ListInitializer](../../../samples/snippets/csharp/new-in-6/initializers.cs#CollectionInitializer)]

<span data-ttu-id="1851d-202">È possibile usare gli indicizzatori con raccolte <xref:System.Collections.Generic.Dictionary%602> e altri tipi, nei casi in cui il metodo `Add` accessibile accetta più argomenti.</span><span class="sxs-lookup"><span data-stu-id="1851d-202">You can use them with <xref:System.Collections.Generic.Dictionary%602> collections and other types where the accessible `Add` method accepts more than one argument.</span></span> <span data-ttu-id="1851d-203">La nuova sintassi supporta l'assegnazione mediante l'uso di un indice nella raccolta:</span><span class="sxs-lookup"><span data-stu-id="1851d-203">The new syntax supports assignment using an index into the collection:</span></span>

[!code-csharp[DictionaryInitializer](../../../samples/snippets/csharp/new-in-6/initializers.cs#DictionaryInitializer)]

<span data-ttu-id="1851d-204">Questa funzionalità significa che i contenitori associativi possono essere inizializzati usando una sintassi simile a ciò che è stato usato per i contenitori sequenziali in diverse versioni.</span><span class="sxs-lookup"><span data-stu-id="1851d-204">This feature means that associative containers can be initialized using syntax similar to what's been in place for sequence containers for several versions.</span></span>

## <a name="extension-add-methods-in-collection-initializers"></a><span data-ttu-id="1851d-205">Metodi di estensione `Add` negli inizializzatori di insieme</span><span class="sxs-lookup"><span data-stu-id="1851d-205">Extension `Add` methods in collection initializers</span></span>

<span data-ttu-id="1851d-206">Un'altra funzionalità che semplifica l'inizializzazione della raccolta è la possibilità di usare un *metodo di estensione* per il metodo `Add`.</span><span class="sxs-lookup"><span data-stu-id="1851d-206">Another feature that makes collection initialization easier is the ability to use an *extension method* for the `Add` method.</span></span> <span data-ttu-id="1851d-207">Questa funzionalità è stata aggiunta per la parità con Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="1851d-207">This feature was added for parity with Visual Basic.</span></span> <span data-ttu-id="1851d-208">La funzionalità è particolarmente utile quando si usa una classe di raccolta personalizzata con un metodo di nome diverso per aggiungere semanticamente nuovi elementi.</span><span class="sxs-lookup"><span data-stu-id="1851d-208">The feature is most useful when you have a custom collection class that has a method with a different name to semantically add new items.</span></span>

## <a name="improved-overload-resolution"></a><span data-ttu-id="1851d-209">Risoluzione dell'overload migliorata</span><span class="sxs-lookup"><span data-stu-id="1851d-209">Improved overload resolution</span></span>

<span data-ttu-id="1851d-210">Quest'ultima funzionalità probabilmente non viene notata.</span><span class="sxs-lookup"><span data-stu-id="1851d-210">This last feature is one you probably won't notice.</span></span> <span data-ttu-id="1851d-211">Esistevano costrutti in cui la versione precedente del compilatore C# poteva rilevare alcune chiamate al metodo che includevano espressioni lambda ambigue.</span><span class="sxs-lookup"><span data-stu-id="1851d-211">There were constructs where the previous version of the C# compiler may have found some method calls involving lambda expressions ambiguous.</span></span> <span data-ttu-id="1851d-212">Si consideri il metodo seguente:</span><span class="sxs-lookup"><span data-stu-id="1851d-212">Consider this method:</span></span>

[!code-csharp[AsyncMethod](../../../samples/snippets/csharp/new-in-6/overloads.cs#AsyncMethod)]

<span data-ttu-id="1851d-213">Nelle versioni precedenti di C# una chiamata a tale metodo usando la sintassi del gruppo di metodi avrebbe esito negativo:</span><span class="sxs-lookup"><span data-stu-id="1851d-213">In earlier versions of C#, calling that method using the method group syntax would fail:</span></span>

[!code-csharp[MethodGroup](../../../samples/snippets/csharp/new-in-6/overloads.cs#MethodGroup)]

<span data-ttu-id="1851d-214">Il compilatore precedente non era in grado di distinguere correttamente `Task.Run(Action)` da `Task.Run(Func<Task>())`.</span><span class="sxs-lookup"><span data-stu-id="1851d-214">The earlier compiler couldn't distinguish correctly between `Task.Run(Action)` and `Task.Run(Func<Task>())`.</span></span> <span data-ttu-id="1851d-215">Nelle versioni precedenti è necessario usare un'espressione lambda come argomento:</span><span class="sxs-lookup"><span data-stu-id="1851d-215">In previous versions, you'd need to use a lambda expression as an argument:</span></span>

[!code-csharp[Lambda](../../../samples/snippets/csharp/new-in-6/overloads.cs#Lambda)]

<span data-ttu-id="1851d-216">Il compilatore C# 6 determina correttamente che `Task.Run(Func<Task>())` è una scelta migliore.</span><span class="sxs-lookup"><span data-stu-id="1851d-216">The C# 6 compiler correctly determines that `Task.Run(Func<Task>())` is a better choice.</span></span>

### <a name="deterministic-compiler-output"></a><span data-ttu-id="1851d-217">Output del compilatore deterministico</span><span class="sxs-lookup"><span data-stu-id="1851d-217">Deterministic compiler output</span></span>

<span data-ttu-id="1851d-218">L'opzione `-deterministic` indica al compilatore di produrre un assembly di output identico byte per byte per le compilazioni successive degli stessi file di origine.</span><span class="sxs-lookup"><span data-stu-id="1851d-218">The `-deterministic` option instructs the compiler to produce a byte-for-byte identical output assembly for successive compilations of the same source files.</span></span>

<span data-ttu-id="1851d-219">Per impostazione predefinita, ogni compilazione produce un output univoco in ogni compilazione.</span><span class="sxs-lookup"><span data-stu-id="1851d-219">By default, every compilation produces unique output on each compilation.</span></span> <span data-ttu-id="1851d-220">Il compilatore aggiunge un timestamp e un GUID generato da numeri casuali.</span><span class="sxs-lookup"><span data-stu-id="1851d-220">The compiler adds a timestamp, and a GUID generated from random numbers.</span></span> <span data-ttu-id="1851d-221">Usare questa opzione se si vuole confrontare l'output byte per byte per garantire coerenza tra le compilazioni.</span><span class="sxs-lookup"><span data-stu-id="1851d-221">You use this option if you want to compare the byte-for-byte output to ensure consistency across builds.</span></span>

<span data-ttu-id="1851d-222">Per altre informazioni, vedere l'articolo [Opzione del compilatore -deterministic](../language-reference/compiler-options/deterministic-compiler-option.md).</span><span class="sxs-lookup"><span data-stu-id="1851d-222">For more information, see the [-deterministic compiler option](../language-reference/compiler-options/deterministic-compiler-option.md) article.</span></span>
