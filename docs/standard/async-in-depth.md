---
title: La programmazione asincrona in dettaglio
description: Informazioni su come la scrittura di codice asincrono associato a I/O e CPU risulta notevolmente semplificata dall'uso del modello asincrono basato su attività di .NET.
author: cartermp
ms.author: wiwagn
ms.date: 06/20/2016
ms.technology: dotnet-standard
ms.assetid: 1e38f9d9-8f84-46ee-a15f-199aec4f2e34
ms.openlocfilehash: 91fd37ce329c03b43b5472e4579be7f5ef961738
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 03/15/2020
ms.locfileid: "70169112"
---
# <a name="async-in-depth"></a><span data-ttu-id="78fe2-103">La programmazione asincrona in dettaglio</span><span class="sxs-lookup"><span data-stu-id="78fe2-103">Async in depth</span></span>

<span data-ttu-id="78fe2-104">La scrittura di codice asincrono associato a I/O e CPU risulta notevolmente semplificata dall'uso del modello asincrono basato su attività di .NET.</span><span class="sxs-lookup"><span data-stu-id="78fe2-104">Writing I/O- and CPU-bound asynchronous code is straightforward using the .NET Task-based async model.</span></span> <span data-ttu-id="78fe2-105">Il modello viene esposto dai tipi `Task` e `Task<T>` e dalle parole chiave `async` e `await` in C# e Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="78fe2-105">The model is exposed by the `Task` and `Task<T>` types and the `async` and `await` keywords in C# and Visual Basic.</span></span> <span data-ttu-id="78fe2-106">Le risorse specifiche della lingua sono disponibili nella sezione [Vedere anche.](#see-also) Questo articolo spiega come usare async .NET e fornisce informazioni dettagliate sul framework asincrono usato nelle copertine.</span><span class="sxs-lookup"><span data-stu-id="78fe2-106">(Language-specific resources are found in the [See also](#see-also) section.) This article explains how to use .NET async and provides insight into the async framework used under the covers.</span></span>

## <a name="task-and-taskt"></a><span data-ttu-id="78fe2-107">Task e Task\<T></span><span class="sxs-lookup"><span data-stu-id="78fe2-107">Task and Task\<T></span></span>

<span data-ttu-id="78fe2-108">Le attività sono costrutti usati per implementare il cosiddetto [Modello di concorrenza basato su promise](https://en.wikipedia.org/wiki/Futures_and_promises).</span><span class="sxs-lookup"><span data-stu-id="78fe2-108">Tasks are constructs used to implement what is known as the [Promise Model of Concurrency](https://en.wikipedia.org/wiki/Futures_and_promises).</span></span>  <span data-ttu-id="78fe2-109">In poche parole offrono la "promessa" che il lavoro verrà completato in un secondo memento, consentendo all'utente di coordinare la promessa con un'API nuova.</span><span class="sxs-lookup"><span data-stu-id="78fe2-109">In short, they offer you a "promise" that work will be completed at a later point, letting you coordinate with the promise with a clean API.</span></span>

- <span data-ttu-id="78fe2-110">`Task` rappresenta una singola operazione che non restituisce alcun valore.</span><span class="sxs-lookup"><span data-stu-id="78fe2-110">`Task` represents a single operation which does not return a value.</span></span>
- <span data-ttu-id="78fe2-111">`Task<T>` rappresenta una singola operazione che restituisce un valore di tipo `T`.</span><span class="sxs-lookup"><span data-stu-id="78fe2-111">`Task<T>` represents a single operation which returns a value of type `T`.</span></span>

<span data-ttu-id="78fe2-112">È importante considerare le attività come astrazioni del lavoro che si svolge in modo asincrono e *non* un'astrazione sul threading.</span><span class="sxs-lookup"><span data-stu-id="78fe2-112">It’s important to reason about tasks as abstractions of work happening asynchronously, and *not* an abstraction over threading.</span></span> <span data-ttu-id="78fe2-113">Per impostazione predefinita, le attività vengono eseguite sul thread corrente e delegano il lavoro al sistema operativo, in base alle necessità.</span><span class="sxs-lookup"><span data-stu-id="78fe2-113">By default, tasks execute on the current thread and delegate work to the Operating System, as appropriate.</span></span> <span data-ttu-id="78fe2-114">Facoltativamente, le attività possono essere esplicitamente richieste per l'esecuzione in un thread separato tramite l'API `Task.Run`.</span><span class="sxs-lookup"><span data-stu-id="78fe2-114">Optionally, tasks can be explicitly requested to run on a separate thread via the `Task.Run` API.</span></span>

<span data-ttu-id="78fe2-115">Le attività espongono un protocollo di API per il monitoraggio, attendendo il valore risultante di un'attività cui poi accedono (nel caso di `Task<T>`).</span><span class="sxs-lookup"><span data-stu-id="78fe2-115">Tasks expose an API protocol for monitoring, waiting upon and accessing the result value (in the case of `Task<T>`) of a task.</span></span> <span data-ttu-id="78fe2-116">L'integrazione del linguaggio, con la parola chiave `await`, offre un'astrazione di livello superiore per l'uso delle attività.</span><span class="sxs-lookup"><span data-stu-id="78fe2-116">Language integration, with the `await` keyword, provides a higher-level abstraction for using tasks.</span></span>

<span data-ttu-id="78fe2-117">L'uso di `await` consente all'applicazione o al servizio di eseguire operazioni utili mentre viene eseguita un'attività, cedendo il controllo al chiamante fino al completamento dell'attività.</span><span class="sxs-lookup"><span data-stu-id="78fe2-117">Using `await` allows your application or service to perform useful work while a task is running by yielding control to its caller until the task is done.</span></span> <span data-ttu-id="78fe2-118">Non è necessario che il codice si basi su callback o eventi perché continui a essere eseguito dopo il completamento dell'attività.</span><span class="sxs-lookup"><span data-stu-id="78fe2-118">Your code does not need to rely on callbacks or events to continue execution after the task has been completed.</span></span> <span data-ttu-id="78fe2-119">Sono il linguaggio e l'integrazione dell'API dell'attività a occuparsi di questo.</span><span class="sxs-lookup"><span data-stu-id="78fe2-119">The language and task API integration does that for you.</span></span> <span data-ttu-id="78fe2-120">Se si usa `Task<T>`, al completamento dell'attività la parola chiave `await` annullerà il wrapping del valore restituito.</span><span class="sxs-lookup"><span data-stu-id="78fe2-120">If you’re using `Task<T>`, the `await` keyword will additionally "unwrap" the value returned when the Task is complete.</span></span>  <span data-ttu-id="78fe2-121">I dettagli di questo processo sono illustrati più sotto.</span><span class="sxs-lookup"><span data-stu-id="78fe2-121">The details of how this works are explained further below.</span></span>

<span data-ttu-id="78fe2-122">Per altre informazioni sulle attività e i diversi modi per interagire con esse, vedere l'argomento [Task-based Asynchronous Pattern (TAP)](./asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md) (Modello asincrono basato su attività).</span><span class="sxs-lookup"><span data-stu-id="78fe2-122">You can learn more about tasks and the different ways to interact with them in the [Task-based Asynchronous Pattern (TAP)](./asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md) topic.</span></span>

## <a name="deeper-dive-into-tasks-for-an-io-bound-operation"></a><span data-ttu-id="78fe2-123">Approfondimento sulle attività per un'operazione associata ai I/O</span><span class="sxs-lookup"><span data-stu-id="78fe2-123">Deeper Dive into Tasks for an I/O-Bound Operation</span></span>

<span data-ttu-id="78fe2-124">La sezione seguente offre una panoramica di ciò che accade con una chiamata I/O asincrona tipica.</span><span class="sxs-lookup"><span data-stu-id="78fe2-124">The following section describes a 10,000 foot view of what happens with a typical async I/O call.</span></span> <span data-ttu-id="78fe2-125">Iniziamo con alcuni esempi.</span><span class="sxs-lookup"><span data-stu-id="78fe2-125">Let's start with a couple examples.</span></span>

<span data-ttu-id="78fe2-126">Nel primo esempio viene chiamato un metodo asincrono e viene restituita un'attività attiva, ancora da completare.</span><span class="sxs-lookup"><span data-stu-id="78fe2-126">The first example calls an async method and returns an active task, likely yet to complete.</span></span>

```csharp
public Task<string> GetHtmlAsync()
{
    // Execution is synchronous here
    var client = new HttpClient();

    return client.GetStringAsync("https://www.dotnetfoundation.org");
}
```

<span data-ttu-id="78fe2-127">Nel secondo esempio viene aggiunto l'uso delle parole chiave `async` e `await` per il funzionamento dell'attività.</span><span class="sxs-lookup"><span data-stu-id="78fe2-127">The second example adds the use of the `async` and `await` keywords to operate on the task.</span></span>

```csharp
public async Task<string> GetFirstCharactersCountAsync(string url, int count)
{
    // Execution is synchronous here
    var client = new HttpClient();

    // Execution of GetFirstCharactersCountAsync() is yielded to the caller here
    // GetStringAsync returns a Task<string>, which is *awaited*
    var page = await client.GetStringAsync("https://www.dotnetfoundation.org");

    // Execution resumes when the client.GetStringAsync task completes,
    // becoming synchronous again.

    if (count > page.Length)
    {
        return page;
    }
    else
    {
        return page.Substring(0, count);
    }
}
```

<span data-ttu-id="78fe2-128">La chiamata a `GetStringAsync()` chiama le librerie .NET di livello inferiore, che possono chiamare altri metodi asincroni, finché non raggiunge le chiamate all'interoperabilità P/Invoke in una libreria di rete nativa.</span><span class="sxs-lookup"><span data-stu-id="78fe2-128">The call to `GetStringAsync()` calls through lower-level .NET libraries (perhaps calling other async methods) until it reaches a P/Invoke interop call into a native networking library.</span></span> <span data-ttu-id="78fe2-129">Successivamente, la libreria nativa può eseguire una chiamata in una chiamata API di sistema, come ad esempio `write()` in un socket in Linux.</span><span class="sxs-lookup"><span data-stu-id="78fe2-129">The native library may subsequently call into a System API call (such as `write()` to a socket on Linux).</span></span> <span data-ttu-id="78fe2-130">Verrà creato un oggetto attività al limite nativo/gestito, usando possibilmente [TaskCompletionSource](xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult(%600)).</span><span class="sxs-lookup"><span data-stu-id="78fe2-130">A task object will be created at the native/managed boundary, possibly using [TaskCompletionSource](xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult(%600)).</span></span> <span data-ttu-id="78fe2-131">L'oggetto attività verrà passato attraverso i livelli, attraverso operazioni o restituzione diretta, e alla fine verrà restituito al chiamante iniziale.</span><span class="sxs-lookup"><span data-stu-id="78fe2-131">The task object will be passed up through the layers, possibly operated on or directly returned, eventually returned to the initial caller.</span></span>

<span data-ttu-id="78fe2-132">Nel secondo esempio qui sopra, un oggetto `Task<T>` viene restituito da `GetStringAsync`.</span><span class="sxs-lookup"><span data-stu-id="78fe2-132">In the second example above, a `Task<T>` object will be returned from `GetStringAsync`.</span></span> <span data-ttu-id="78fe2-133">L'uso della parola chiave `await` fa sì che il metodo restituisca un oggetto attività nuovo.</span><span class="sxs-lookup"><span data-stu-id="78fe2-133">The use of the `await` keyword causes the method to return a newly created task object.</span></span> <span data-ttu-id="78fe2-134">Il controllo ritorna al chiamante da questa posizione nel metodo `GetFirstCharactersCountAsync`.</span><span class="sxs-lookup"><span data-stu-id="78fe2-134">Control returns to the caller from this location in the `GetFirstCharactersCountAsync` method.</span></span> <span data-ttu-id="78fe2-135">I metodi e le proprietà dell'oggetto [Task&lt;T&gt;](xref:System.Threading.Tasks.Task%601) consentono ai chiamanti di controllare l'avanzamento dell'attività che verrà completata quando il codice rimanente in GetFirstCharactersCountAsync sarà stato eseguito.</span><span class="sxs-lookup"><span data-stu-id="78fe2-135">The methods and properties of the [Task&lt;T&gt;](xref:System.Threading.Tasks.Task%601) object enable callers to monitor the progress of the task, which will complete when the remaining code in GetFirstCharactersCountAsync has executed.</span></span>

<span data-ttu-id="78fe2-136">Dopo la chiamata all'API di sistema, la richiesta si trova nello spazio del kernel, in direzione del sottosistema di rete del sistema operativo, ad esempio `/net` in Linux Kernel.</span><span class="sxs-lookup"><span data-stu-id="78fe2-136">After the System API call, the request is now in kernel space, making its way to the networking subsystem of the OS (such as `/net` in the Linux Kernel).</span></span>  <span data-ttu-id="78fe2-137">A questo punto il sistema operativo gestisce la richiesta di rete *in modo asincrono*.</span><span class="sxs-lookup"><span data-stu-id="78fe2-137">Here the OS will handle the networking request *asynchronously*.</span></span>  <span data-ttu-id="78fe2-138">I dettagli possono variare a seconda del sistema operativo usato. La chiamata del driver di dispositivo può essere pianificata come un segnale reinviato al runtime oppure può essere eseguita una chiamata del driver di dispositivo e *successivamente* il segnale viene reinviato. Alla fine comunque l'informazione che la richiesta di rete è in corso arriverà al runtime.</span><span class="sxs-lookup"><span data-stu-id="78fe2-138">Details may be different depending on the OS used (the device driver call may be scheduled as a signal sent back to the runtime, or a device driver call may be made and *then* a signal sent back), but eventually the runtime will be informed that the networking request is in progress.</span></span>  <span data-ttu-id="78fe2-139">A questo punto, il lavoro per il driver di dispositivo sarà pianificato, in corso o già completato (la richiesta è già "in rete"), ma poiché tutto ciò accade in modo asincrono, il driver di dispositivo può gestire immediatamente un'altra operazione.</span><span class="sxs-lookup"><span data-stu-id="78fe2-139">At this time, the work for the device driver will either be scheduled, in-progress, or already finished (the request is already out "over the wire") - but because this is all happening asynchronously, the device driver is able to immediately handle something else!</span></span>

<span data-ttu-id="78fe2-140">Ad esempio, in Windows un thread del sistema operativo esegue una chiamata al driver di dispositivo di rete e richiede di eseguire l'operazione di rete tramite un pacchetto di richiesta di interrupt che rappresenta l'operazione.</span><span class="sxs-lookup"><span data-stu-id="78fe2-140">For example, in Windows an OS thread makes a call to the network device driver and asks it to perform the networking operation via an Interrupt Request Packet (IRP) which represents the operation.</span></span>  <span data-ttu-id="78fe2-141">Il driver di dispositivo riceve il pacchetto, esegue la chiamata alla rete, contrassegna il pacchetto come "in sospeso" e lo restituisce al sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="78fe2-141">The device driver receives the IRP, makes the call to the network, marks the IRP as "pending", and returns back to the OS.</span></span>  <span data-ttu-id="78fe2-142">Poiché a questo punto il thread del sistema operativo è a conoscenza del fatto che il pacchetto sia "in sospeso", non ha altro lavoro da eseguire per il processo e lo "restituisce" in modo che possa essere usato per eseguire altre operazioni.</span><span class="sxs-lookup"><span data-stu-id="78fe2-142">Because the OS thread now knows that the IRP is "pending", it doesn't have any more work to do for this job and "returns" back so that it can be used to perform other work.</span></span>

<span data-ttu-id="78fe2-143">Quando la richiesta viene soddisfatta e i dati vengono restituiti tramite il driver di dispositivo, viene inviata una notifica alla CPU del ricevimento dei nuovi dati tramite un interrupt.</span><span class="sxs-lookup"><span data-stu-id="78fe2-143">When the request is fulfilled and data comes back through the device driver, it notifies the CPU of new data received via an interrupt.</span></span>  <span data-ttu-id="78fe2-144">La modalità con cui viene gestito l'interrpt varia a seconda del sistema operativo, ma alla fine i dati vengono passati tramite il sistema operativo finché non raggiungono una chiamata di interoperabilità di sistema. Ad esempio, in Linux un gestore di interrupt pianificherà la metà inferiore dell'IRQ perché passi i dati nel sistema operativo in modo asincrono.</span><span class="sxs-lookup"><span data-stu-id="78fe2-144">How this interrupt gets handled will vary depending on the OS, but eventually the data will be passed through the OS until it reaches a system interop call (for example, in Linux an interrupt handler will schedule the bottom half of the IRQ to pass the data up through the OS asynchronously).</span></span>  <span data-ttu-id="78fe2-145">Si noti che *anche* questo avviene in modo asincrono.</span><span class="sxs-lookup"><span data-stu-id="78fe2-145">Note that this *also* happens asynchronously!</span></span>  <span data-ttu-id="78fe2-146">Il risultato viene inserito in coda fino a quando il thread disponibile successivo può eseguire il metodo asincrono e "dispiegare" il risultato dell'attività completata.</span><span class="sxs-lookup"><span data-stu-id="78fe2-146">The result is queued up until the next available thread is able to execute the async method and "unwrap" the result of the completed task.</span></span>

<span data-ttu-id="78fe2-147">In tutto questo processo il punto chiave è che **nessun thread è dedicato all'esecuzione dell'attività**.</span><span class="sxs-lookup"><span data-stu-id="78fe2-147">Throughout this entire process, a key takeaway is that **no thread is dedicated to running the task**.</span></span>  <span data-ttu-id="78fe2-148">Sebbene il lavoro venga eseguito in un determinato contesto, ad esempio il sistema operativo deve passare i dati a un driver di dispositivo e rispondere a un interrupt, nessun thread è dedicato all'*attesa* del ritorno dei dati della richiesta.</span><span class="sxs-lookup"><span data-stu-id="78fe2-148">Although work is executed in some context (that is, the OS does have to pass data to a device driver and respond to an interrupt), there is no thread dedicated to *waiting* for data from the request to come back.</span></span>  <span data-ttu-id="78fe2-149">Ciò consente al sistema di gestire un volume di lavoro maggiore, anziché attendere il completamento delle chiamate I/O.</span><span class="sxs-lookup"><span data-stu-id="78fe2-149">This allows the system to handle a much larger volume of work rather than waiting for some I/O call to finish.</span></span>

<span data-ttu-id="78fe2-150">Tutto ciò può sembrare una mole di lavoro davvero imponente ma, se misurato in termini di tempo, è solo una frazione minima di quanto occorre per il lavoro I/O effettivo.</span><span class="sxs-lookup"><span data-stu-id="78fe2-150">Although the above may seem like a lot of work to be done, when measured in terms of wall clock time, it’s miniscule compared to the time it takes to do the actual I/O work.</span></span> <span data-ttu-id="78fe2-151">Anche se tutt'altro che precisa, la seguente potrebbe essere la sequenza temporale per tale chiamata:</span><span class="sxs-lookup"><span data-stu-id="78fe2-151">Although not at all precise, a potential timeline for such a call would look like this:</span></span>

<span data-ttu-id="78fe2-152">0-1————————————————————————————————————————————————–2-3</span><span class="sxs-lookup"><span data-stu-id="78fe2-152">0-1————————————————————————————————————————————————–2-3</span></span>

- <span data-ttu-id="78fe2-153">Il tempo impiegato dai punti `0` a `1` è tutto quanto accade fino a quando un metodo asincrono cede il controllo al chiamante.</span><span class="sxs-lookup"><span data-stu-id="78fe2-153">Time spent from points `0` to `1` is everything up until an async method yields control to its caller.</span></span>
- <span data-ttu-id="78fe2-154">Il tempo impiegato dai punti `1` a `2` è il tempo dedicato alle chiamate I/O senza alcun costo della CPU.</span><span class="sxs-lookup"><span data-stu-id="78fe2-154">Time spent from points `1` to `2` is the time spent on I/O, with no CPU cost.</span></span>
- <span data-ttu-id="78fe2-155">Infine, il tempo impiegato dai punti `2` a `3` è il passaggio del controllo, e potenzialmente di un valore, nuovamente al metodo asincrono, che a quel punto è ancora in esecuzione.</span><span class="sxs-lookup"><span data-stu-id="78fe2-155">Finally, time spent from points `2` to `3` is passing control back (and potentially a value) to the async method, at which point it is executing again.</span></span>

### <a name="what-does-this-mean-for-a-server-scenario"></a><span data-ttu-id="78fe2-156">Che cosa significa questo in uno scenario server?</span><span class="sxs-lookup"><span data-stu-id="78fe2-156">What does this mean for a server scenario?</span></span>

<span data-ttu-id="78fe2-157">Questo modello funziona bene con un carico di lavoro di uno scenario di server tipico.</span><span class="sxs-lookup"><span data-stu-id="78fe2-157">This model works well with a typical server scenario workload.</span></span>  <span data-ttu-id="78fe2-158">Poiché non vi sono thread dedicati per il blocco delle attività non completate, il pool di thread del server può gestire un numero di richieste Web molto maggiore.</span><span class="sxs-lookup"><span data-stu-id="78fe2-158">Because there are no threads dedicated to blocking on unfinished tasks, the server threadpool can service a much higher volume of web requests.</span></span>

<span data-ttu-id="78fe2-159">Prendiamo ad esempio due server: uno esegue codice asincrono, l'altro no.</span><span class="sxs-lookup"><span data-stu-id="78fe2-159">Consider two servers: one that runs async code, and one that does not.</span></span>  <span data-ttu-id="78fe2-160">Ai fini di questo esempio, ogni server ha solo 5 thread disponibili per le richieste di servizio.</span><span class="sxs-lookup"><span data-stu-id="78fe2-160">For the purpose of this example, each server only has 5 threads available to service requests.</span></span>  <span data-ttu-id="78fe2-161">Si noti che questi numeri sono molto piccoli e servono solo a scopo dimostrativo.</span><span class="sxs-lookup"><span data-stu-id="78fe2-161">Note that these numbers are imaginarily small and serve only in a demonstrative context.</span></span>

<span data-ttu-id="78fe2-162">Si supponga che entrambi i server ricevano 6 richieste simultanee.</span><span class="sxs-lookup"><span data-stu-id="78fe2-162">Assume both servers receive 6 concurrent requests.</span></span> <span data-ttu-id="78fe2-163">Ogni richiesta esegue un'operazione I/O.</span><span class="sxs-lookup"><span data-stu-id="78fe2-163">Each request performs an I/O operation.</span></span>  <span data-ttu-id="78fe2-164">Il server *senza* codice asincrono deve inserire in coda tutte le sei richieste finché uno dei 5 thread non ha completato il lavoro associato a I/O e scritto la risposta.</span><span class="sxs-lookup"><span data-stu-id="78fe2-164">The server *without* async code has to queue up the 6th request until one of the 5 threads have finished the I/O-bound work and written a response.</span></span> <span data-ttu-id="78fe2-165">Nel momento in cui entra la ventesima richiesta il server potrebbe iniziare a rallentare, visto che la coda sta iniziando a diventare troppo lunga.</span><span class="sxs-lookup"><span data-stu-id="78fe2-165">At the point that the 20th request comes in, the server might start to slow down, because the queue is getting too long.</span></span>

<span data-ttu-id="78fe2-166">Il server *con* il codice asincrono in esecuzione inserisce in coda tutte le sei richieste ma, dal momento che usa `async` e `await`, tutti i thread vengono liberati all'inizio del lavoro associato a I/O, non al suo completamento.</span><span class="sxs-lookup"><span data-stu-id="78fe2-166">The server *with* async code running on it still queues up the 6th request, but because it uses `async` and `await`, each of its threads are freed up when the I/O-bound work starts, rather than when it finishes.</span></span>  <span data-ttu-id="78fe2-167">Quando entra la ventesima richiesta, la coda delle richieste in entrata è molto più piccola, sempre che vi sia una coda in entrata, e il server non risulta rallentato.</span><span class="sxs-lookup"><span data-stu-id="78fe2-167">By the time the 20th request comes in, the queue for incoming requests will be far smaller (if it has anything in it at all), and the server won't slow down.</span></span>

<span data-ttu-id="78fe2-168">Anche se questo è un esempio artificioso, uno scenario reale funzionerebbe in modo molto simile.</span><span class="sxs-lookup"><span data-stu-id="78fe2-168">Although this is a contrived example, it works in a very similar fashion in the real world.</span></span>  <span data-ttu-id="78fe2-169">Infatti, è assolutamente plausibile che un server sia in grado di gestire un numero molto maggiore di richieste usando `async` e `await` piuttosto che dedicando un thread per ogni richiesta che riceve.</span><span class="sxs-lookup"><span data-stu-id="78fe2-169">In fact, you can expect a server to be able to handle an order of magnitude more requests using `async` and `await` than if it were dedicating a thread for each request it receives.</span></span>

### <a name="what-does-this-mean-for-client-scenario"></a><span data-ttu-id="78fe2-170">Che cosa significa questo in uno scenario client?</span><span class="sxs-lookup"><span data-stu-id="78fe2-170">What does this mean for client scenario?</span></span>

<span data-ttu-id="78fe2-171">Il vantaggio principale dato dall'uso di `async` e `await` per un'app client è un aumento della velocità di risposta.</span><span class="sxs-lookup"><span data-stu-id="78fe2-171">The biggest gain for using `async` and `await` for a client app is an increase in responsiveness.</span></span>  <span data-ttu-id="78fe2-172">Sebbene sia possibile creare un'app reattiva generando thread manualmente, l'azione di generazione di un thread è un'operazione dispendiosa rispetto al solo suo di `async` e `await`.</span><span class="sxs-lookup"><span data-stu-id="78fe2-172">Although you can make an app responsive by spawning threads manually, the act of spawning a thread is an expensive operation relative to just using `async` and `await`.</span></span>  <span data-ttu-id="78fe2-173">Ridurre il più possibile l'impatto sul thread dell'interfaccia utente in materia di I/O è fondamentale, soprattutto per app come un videogame mobile.</span><span class="sxs-lookup"><span data-stu-id="78fe2-173">Especially for something like a mobile game, impacting the UI thread as little as possible where I/O is concerned is crucial.</span></span>

<span data-ttu-id="78fe2-174">E cosa ancora più importante, dal momento che il lavoro associato a I/O virtualmente non passa alcun tempo nella CPU, dedicare un thread della CPU intero all'esecuzione di attività poco utili costituirebbe un uso scarsamente efficiente delle risorse.</span><span class="sxs-lookup"><span data-stu-id="78fe2-174">More importantly, because I/O-bound work spends virtually no time on the CPU, dedicating an entire CPU thread to perform barely any useful work would be a poor use of resources.</span></span>

<span data-ttu-id="78fe2-175">Inviare lavoro al thread dell'interfaccia utente, ad esempio l'aggiornamento dell'interfaccia, è anche molto semplice con i metodi `async` e non richiede operazioni aggiuntive, come ad esempio la chiamata a un delegato thread-safe.</span><span class="sxs-lookup"><span data-stu-id="78fe2-175">Additionally, dispatching work to the UI thread (such as updating a UI) is very simple with `async` methods, and does not require extra work (such as calling a thread-safe delegate).</span></span>

## <a name="deeper-dive-into-task-and-taskt-for-a-cpu-bound-operation"></a><span data-ttu-id="78fe2-176">Approfondimento delle attività Task e Task\<T> per un'operazione associata alla CPU</span><span class="sxs-lookup"><span data-stu-id="78fe2-176">Deeper Dive into Task and Task\<T> for a CPU-Bound Operation</span></span>

<span data-ttu-id="78fe2-177">Il codice `async` associato alla CPU è un po' diverso rispetto al codice `async` associato a I/O.</span><span class="sxs-lookup"><span data-stu-id="78fe2-177">CPU-bound `async` code is a bit different than I/O-bound `async` code.</span></span>  <span data-ttu-id="78fe2-178">Dal momento che il lavoro viene eseguito sulla CPU, non c'è modo di evitare di dedicare un thread al calcolo.</span><span class="sxs-lookup"><span data-stu-id="78fe2-178">Because the work is done on the CPU, there's no way to get around dedicating a thread to the computation.</span></span>  <span data-ttu-id="78fe2-179">L'uso di `async` e `await` offre un metodo chiaro per interagire con un thread in background e mantenere reattivo il chiamante del metodo asincrono.</span><span class="sxs-lookup"><span data-stu-id="78fe2-179">The use of `async` and `await` provides you with a clean way to interact with a background thread and keep the caller of the async method responsive.</span></span>  <span data-ttu-id="78fe2-180">Si noti che ciò non offre alcuna protezione per i dati condivisi.</span><span class="sxs-lookup"><span data-stu-id="78fe2-180">Note that this does not provide any protection for shared data.</span></span>  <span data-ttu-id="78fe2-181">Se si usano dati condivisi, sarà necessario applicare una strategia di sincronizzazione appropriata.</span><span class="sxs-lookup"><span data-stu-id="78fe2-181">If you are using shared data, you will still need to apply an appropriate synchronization strategy.</span></span>

<span data-ttu-id="78fe2-182">Di seguito viene presentata una panoramica della chiamata asincrona associata alla CPU:</span><span class="sxs-lookup"><span data-stu-id="78fe2-182">Here's a 10,000 foot view of a CPU-bound async call:</span></span>

```csharp
public async Task<int> CalculateResult(InputData data)
{
    // This queues up the work on the threadpool.
    var expensiveResultTask = Task.Run(() => DoExpensiveCalculation(data));

    // Note that at this point, you can do some other work concurrently,
    // as CalculateResult() is still executing!

    // Execution of CalculateResult is yielded here!
    var result = await expensiveResultTask;

    return result;
}
```

<span data-ttu-id="78fe2-183">`CalculateResult()` viene eseguito sul thread in cui è stato chiamato.</span><span class="sxs-lookup"><span data-stu-id="78fe2-183">`CalculateResult()` executes on the thread it was called on.</span></span>  <span data-ttu-id="78fe2-184">Quando chiama `Task.Run`, inserisce in coda l'operazione dispendiosa associata alla CPU, `DoExpensiveCalculation()`, nel pool di thread e riceve un handle `Task<int>`.</span><span class="sxs-lookup"><span data-stu-id="78fe2-184">When it calls `Task.Run`, it queues the expensive CPU-bound operation, `DoExpensiveCalculation()`, on the thread pool and receives a `Task<int>` handle.</span></span>  <span data-ttu-id="78fe2-185">`DoExpensiveCalculation()` viene infine eseguito contemporaneamente nel thread disponibile successivo, probabilmente su un altro core della CPU.</span><span class="sxs-lookup"><span data-stu-id="78fe2-185">`DoExpensiveCalculation()` is eventually run concurrently on the next available thread, likely on another CPU core.</span></span>  <span data-ttu-id="78fe2-186">È possibile eseguire attività simultanee mentre `DoExpensiveCalculation()` è occupato in un altro thread, poiché il thread che ha chiamato `CalculateResult()` è ancora in esecuzione.</span><span class="sxs-lookup"><span data-stu-id="78fe2-186">It's possible to do concurrent work while `DoExpensiveCalculation()` is busy on another thread, because the thread which called `CalculateResult()` is still executing.</span></span>

<span data-ttu-id="78fe2-187">Quando viene rilevato `await`, l'esecuzione di `CalculateResult()` viene ceduta al chiamante, consentendo lo svolgimento di altro lavoro con il thread corrente mentre `DoExpensiveCalculation()` sta producendo un risultato.</span><span class="sxs-lookup"><span data-stu-id="78fe2-187">Once `await` is encountered, the execution of `CalculateResult()` is yielded to its caller, allowing other work to be done with the current thread while `DoExpensiveCalculation()` is churning out a result.</span></span>  <span data-ttu-id="78fe2-188">Al termine dell'operazione, il risultato viene inserito in coda per l'esecuzione sul thread principale.</span><span class="sxs-lookup"><span data-stu-id="78fe2-188">Once it has finished, the result is queued up to run on the main thread.</span></span>  <span data-ttu-id="78fe2-189">Alla fine, il thread principale tornerà all'esecuzione di `CalculateResult()` e a quel punto sarà disponibile il risultato di `DoExpensiveCalculation()`.</span><span class="sxs-lookup"><span data-stu-id="78fe2-189">Eventually, the main thread will return to executing `CalculateResult()`, at which point it will have the result of `DoExpensiveCalculation()`.</span></span>

### <a name="why-does-async-help-here"></a><span data-ttu-id="78fe2-190">In che modo il codice asincrono risulta utile in questo scenario?</span><span class="sxs-lookup"><span data-stu-id="78fe2-190">Why does async help here?</span></span>

<span data-ttu-id="78fe2-191">`async` e `await` sono la procedura consigliata per la gestione di attività associate alla CPU quando è necessaria velocità di risposta.</span><span class="sxs-lookup"><span data-stu-id="78fe2-191">`async` and `await` are the best practice for managing CPU-bound work when you need responsiveness.</span></span> <span data-ttu-id="78fe2-192">Vi sono diversi modelli per l'uso di codice asincrono con attività associate alla CPU.</span><span class="sxs-lookup"><span data-stu-id="78fe2-192">There are multiple patterns for using async with CPU-bound work.</span></span> <span data-ttu-id="78fe2-193">È importante tenere presente che esiste un costo minimo per l'uso del codice asincrono e che tale uso è sconsigliato per cicli ridotti.</span><span class="sxs-lookup"><span data-stu-id="78fe2-193">It's important to note that there is a small cost to using async and it's not recommended for tight loops.</span></span>  <span data-ttu-id="78fe2-194">Spetta all'utente determinare come scrivere il codice in base a questa nuova funzionalità.</span><span class="sxs-lookup"><span data-stu-id="78fe2-194">It's up to you to determine how you write your code around this new capability.</span></span>

## <a name="see-also"></a><span data-ttu-id="78fe2-195">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="78fe2-195">See also</span></span>

- [<span data-ttu-id="78fe2-196">Programmazione asincrona in C#</span><span class="sxs-lookup"><span data-stu-id="78fe2-196">Asynchronous programming in C#</span></span>](../csharp/async.md)
- [<span data-ttu-id="78fe2-197">Programmazione asincrona con async e await (C )Asynchronous programming with async and await (C</span><span class="sxs-lookup"><span data-stu-id="78fe2-197">Asynchronous programming with async and await (C#)</span></span>](../csharp/programming-guide/concepts/async/index.md)
- [<span data-ttu-id="78fe2-198">Programmazione asincrona in F#</span><span class="sxs-lookup"><span data-stu-id="78fe2-198">Async Programming in F#</span></span>](../fsharp/tutorials/asynchronous-and-concurrent-programming/async.md)
- [<span data-ttu-id="78fe2-199">Programmazione asincrona con Async e Await (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="78fe2-199">Asynchronous Programming with Async and Await (Visual Basic)</span></span>](../visual-basic/programming-guide/concepts/async/index.md)
