---
title: Panoramica di .NET
description: Panoramica guidata di alcune delle principali funzionalità di .NET.
author: cartermp
ms.author: wiwagn
ms.date: 05/22/2017
ms.technology: dotnet-standard
ms.assetid: bbfe6465-329d-4982-869d-472e7ef85d93
ms.openlocfilehash: 61d4792b1f1b92dd59442ee38810da96c6cf63bd
ms.sourcegitcommit: 43d10ef65f0f1fd6c3b515e363bde11a3fcd8d6d
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 03/03/2020
ms.locfileid: "78241143"
---
# <a name="tour-of-net"></a><span data-ttu-id="6c97d-103">Panoramica di .NET</span><span class="sxs-lookup"><span data-stu-id="6c97d-103">Tour of .NET</span></span>

<span data-ttu-id="6c97d-104">.NET è una piattaforma di sviluppo con finalità generali</span><span class="sxs-lookup"><span data-stu-id="6c97d-104">.NET is a general purpose development platform.</span></span> <span data-ttu-id="6c97d-105">che offre varie funzionalità chiave, ad esempio il supporto per più linguaggi di programmazione, modelli di programmazione asincroni e simultanei e l'interoperabilità nativa, che consente l'esecuzione di un'ampia gamma di scenari su più piattaforme.</span><span class="sxs-lookup"><span data-stu-id="6c97d-105">It has several key features, such as support for multiple programming languages, asynchronous and concurrent programming models, and native interoperability, which enable a wide range of scenarios across multiple platforms.</span></span>

<span data-ttu-id="6c97d-106">Questo articolo offre una panoramica guidata di alcune delle principali funzionalità di .NET.</span><span class="sxs-lookup"><span data-stu-id="6c97d-106">This article offers a guided tour through some of the key features of the .NET.</span></span> <span data-ttu-id="6c97d-107">Per informazioni sui componenti dell'architettura di .NET e sulle relative modalità d'uso, vedere l'argomento [Componenti dell'architettura .NET](components.md).</span><span class="sxs-lookup"><span data-stu-id="6c97d-107">See the [.NET Architectural Components](components.md) topic to learn about the architectural pieces of .NET and what they're used for.</span></span>

## <a name="how-to-run-the-code-samples"></a><span data-ttu-id="6c97d-108">Come eseguire i codici di esempio</span><span class="sxs-lookup"><span data-stu-id="6c97d-108">How to run the code samples</span></span>

<span data-ttu-id="6c97d-109">Per informazioni su come configurare un ambiente di sviluppo all'interno del quale eseguire i codici di esempio, vedere l'articolo [Introduzione](get-started.md).</span><span class="sxs-lookup"><span data-stu-id="6c97d-109">To learn how to set up a development environment to run the code samples, see the [Getting Started](get-started.md) topic.</span></span> <span data-ttu-id="6c97d-110">È possibile copiare i codici di esempio da questa pagina e incollarli nel proprio ambiente per eseguirli.</span><span class="sxs-lookup"><span data-stu-id="6c97d-110">Copy and paste code samples from this page into your environment to execute them.</span></span>

## <a name="programming-languages"></a><span data-ttu-id="6c97d-111">Linguaggi di programmazione</span><span class="sxs-lookup"><span data-stu-id="6c97d-111">Programming languages</span></span>

<span data-ttu-id="6c97d-112">.NET supporta più linguaggi di programmazione.</span><span class="sxs-lookup"><span data-stu-id="6c97d-112">.NET supports multiple programming languages.</span></span> <span data-ttu-id="6c97d-113">Le implementazioni di .NET implementano l'[infrastruttura CLI](https://visualstudio.microsoft.com/license-terms/ecma-c-common-language-infrastructure-standards/) che, tra altre cose, specifica un runtime indipendente dal linguaggio e l'interoperabilità di linguaggio.</span><span class="sxs-lookup"><span data-stu-id="6c97d-113">The .NET implementations implement the [Common Language Infrastructure (CLI)](https://visualstudio.microsoft.com/license-terms/ecma-c-common-language-infrastructure-standards/), which among other things specifies a language-independent runtime and language interoperability.</span></span> <span data-ttu-id="6c97d-114">In questo modo, è possibile scegliere qualsiasi linguaggio .NET per creare applicazioni e servizi in .NET.</span><span class="sxs-lookup"><span data-stu-id="6c97d-114">This means that you choose any .NET language to build apps and services on .NET.</span></span>

<span data-ttu-id="6c97d-115">Microsoft sviluppa e supporta attivamente tre linguaggi .NET: C#, F#e Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="6c97d-115">Microsoft actively develops and supports three .NET languages: C#, F#, and Visual Basic.</span></span>

* <span data-ttu-id="6c97d-116">C# è un linguaggio semplice, potente, indipendente dai tipi e orientato agli oggetti che mantiene al tempo stesso l'espressività e l'eleganza tipiche dei linguaggi di tipo C.</span><span class="sxs-lookup"><span data-stu-id="6c97d-116">C# is simple, powerful, type-safe, and object-oriented, while retaining the expressiveness and elegance of C-style languages.</span></span> <span data-ttu-id="6c97d-117">Gli sviluppatori che hanno familiarità con C e linguaggi simili si adattano con facilità a C#.</span><span class="sxs-lookup"><span data-stu-id="6c97d-117">Anyone familiar with C and similar languages finds few problems in adapting to C#.</span></span> <span data-ttu-id="6c97d-118">Per altre informazioni su C#, vedere [Guida a C#](../csharp/index.yml).</span><span class="sxs-lookup"><span data-stu-id="6c97d-118">Check out the [C# Guide](../csharp/index.yml) to learn more about C#.</span></span>

* <span data-ttu-id="6c97d-119">F# è un linguaggio di programmazione multipiattaforma e funzionale che supporta anche la programmazione tradizionale imperativa e orientata agli oggetti.</span><span class="sxs-lookup"><span data-stu-id="6c97d-119">F# is a cross-platform, functional-first programming language that also supports traditional object-oriented and imperative programming.</span></span> <span data-ttu-id="6c97d-120">Per altre informazioni su F#, vedere [Guida a F#](../fsharp/index.yml).</span><span class="sxs-lookup"><span data-stu-id="6c97d-120">Check out the [F# Guide](../fsharp/index.yml) to learn more about F#.</span></span>

* <span data-ttu-id="6c97d-121">Visual Basic è un linguaggio semplice da apprendere che consente di creare una vasta gamma di app da eseguire in .NET.</span><span class="sxs-lookup"><span data-stu-id="6c97d-121">Visual Basic is an easy language to learn that you use to build a variety of apps that run on .NET.</span></span> <span data-ttu-id="6c97d-122">Tra i linguaggi .NET, la sintassi di Visual Basic è la più vicina alla lingua umana comune, rendendo spesso più semplice per gli utenti nuovi allo sviluppo del software.</span><span class="sxs-lookup"><span data-stu-id="6c97d-122">Among the .NET languages, the syntax of Visual Basic is the closest to ordinary human language, often making it easier for people new to software development.</span></span>

## <a name="automatic-memory-management"></a><span data-ttu-id="6c97d-123">Gestione automatica della memoria</span><span class="sxs-lookup"><span data-stu-id="6c97d-123">Automatic memory management</span></span>

<span data-ttu-id="6c97d-124">.NET usa [Garbage Collection](garbage-collection/index.md) per consentire la gestione automatica della memoria per i programmi.</span><span class="sxs-lookup"><span data-stu-id="6c97d-124">.NET uses [garbage collection (GC)](garbage-collection/index.md) to provide automatic memory management for programs.</span></span> <span data-ttu-id="6c97d-125">Garbage Collection ha un approccio "lazy" alla gestione della memoria, anteponendo la velocità effettiva dell'app alla raccolta immediata di memoria.</span><span class="sxs-lookup"><span data-stu-id="6c97d-125">The GC operates on a lazy approach to memory management, preferring app throughput to the immediate collection of memory.</span></span> <span data-ttu-id="6c97d-126">Per altre informazioni sul Garbage Collector di.NET, vedere [Principi fondamentali di Garbage Collection](garbage-collection/fundamentals.md).</span><span class="sxs-lookup"><span data-stu-id="6c97d-126">To learn more about the .NET GC, check out [Fundamentals of garbage collection (GC)](garbage-collection/fundamentals.md).</span></span>

<span data-ttu-id="6c97d-127">Le due righe di codice seguenti allocano entrambe memoria:</span><span class="sxs-lookup"><span data-stu-id="6c97d-127">The following two lines both allocate memory:</span></span>

[!code-csharp[MemoryManagement](../../samples/snippets/csharp/snippets/tour/MemoryManagement.csx#L1-L2)]

<span data-ttu-id="6c97d-128">Non esiste una parola chiave analoga per deallocare la memoria, in quanto la deallocazione viene eseguita automaticamente quando il Garbage Collector recupera la memoria durante l'esecuzione pianificata.</span><span class="sxs-lookup"><span data-stu-id="6c97d-128">There's no analogous keyword to de-allocate memory, as de-allocation happens automatically when the garbage collector reclaims the memory through its scheduled run.</span></span>

<span data-ttu-id="6c97d-129">Garbage Collector è uno dei servizi che consentono di garantire la *sicurezza della memoria*.</span><span class="sxs-lookup"><span data-stu-id="6c97d-129">The garbage collector is one of the services that help ensure *memory safety*.</span></span> <span data-ttu-id="6c97d-130">Un programma è sicuro a livello di memoria se accede solo alla memoria allocata.</span><span class="sxs-lookup"><span data-stu-id="6c97d-130">A program is memory safe if it accesses only allocated memory.</span></span> <span data-ttu-id="6c97d-131">Il runtime assicura ad esempio che un'app non acceda a memoria non allocata oltre i limiti di una matrice.</span><span class="sxs-lookup"><span data-stu-id="6c97d-131">For instance, the runtime ensures that an app doesn't access unallocated memory beyond the bounds of an array.</span></span>

<span data-ttu-id="6c97d-132">Nell'esempio seguente il runtime genera un'eccezione <xref:System.IndexOutOfRangeException> per garantire la sicurezza della memoria:</span><span class="sxs-lookup"><span data-stu-id="6c97d-132">In the following example, the runtime throws an <xref:System.IndexOutOfRangeException> exception to enforce memory safety:</span></span>

[!code-csharp[MemoryManagement](../../samples/snippets/csharp/snippets/tour/MemoryManagement.csx#L4-L5)]

## <a name="working-with-unmanaged-resources"></a><span data-ttu-id="6c97d-133">Utilizzo di risorse non gestite</span><span class="sxs-lookup"><span data-stu-id="6c97d-133">Working with unmanaged resources</span></span>

<span data-ttu-id="6c97d-134">Alcuni oggetti fanno riferimento a *risorse non gestite*.</span><span class="sxs-lookup"><span data-stu-id="6c97d-134">Some objects reference *unmanaged resources*.</span></span> <span data-ttu-id="6c97d-135">Le risorse non gestite sono risorse che non vengono gestite automaticamente dal runtime di .NET.</span><span class="sxs-lookup"><span data-stu-id="6c97d-135">Unmanaged resources are resources that aren't automatically maintained by the .NET runtime.</span></span> <span data-ttu-id="6c97d-136">Ad esempio, un handle di file è una risorsa non gestita.</span><span class="sxs-lookup"><span data-stu-id="6c97d-136">For example, a file handle is an unmanaged resource.</span></span> <span data-ttu-id="6c97d-137">Un oggetto <xref:System.IO.FileStream> è un oggetto gestito, ma fa riferimento a un handle di file, che non è gestito.</span><span class="sxs-lookup"><span data-stu-id="6c97d-137">A <xref:System.IO.FileStream> object is a managed object, but it references a file handle, which is unmanaged.</span></span> <span data-ttu-id="6c97d-138">Dopo aver usato <xref:System.IO.FileStream>, è necessario rilasciare l'handle di file.</span><span class="sxs-lookup"><span data-stu-id="6c97d-138">When you're done using the <xref:System.IO.FileStream>, you need to release the file handle.</span></span>

<span data-ttu-id="6c97d-139">In .NET gli oggetti che fanno riferimento a risorse non gestite implementano l'interfaccia <xref:System.IDisposable>.</span><span class="sxs-lookup"><span data-stu-id="6c97d-139">In .NET, objects that reference unmanaged resources implement the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="6c97d-140">Dopo aver usato l'oggetto, è possibile chiamare il metodo <xref:System.IDisposable.Dispose> dell'oggetto, che è responsabile del rilascio delle risorse non gestite.</span><span class="sxs-lookup"><span data-stu-id="6c97d-140">When you're done using the object, you call the object's <xref:System.IDisposable.Dispose> method, which is responsible for releasing any unmanaged resources.</span></span> <span data-ttu-id="6c97d-141">I linguaggi .NET forniscono una comoda [istruzione`using`](../csharp/language-reference/keywords/using.md) per tali oggetti, come illustrato nell'esempio seguente:</span><span class="sxs-lookup"><span data-stu-id="6c97d-141">.NET languages provide a convenient [`using` statement](../csharp/language-reference/keywords/using.md) for such objects, as shown in the following example:</span></span>

[!code-csharp[UnmanagedResources](../../samples/snippets/csharp/snippets/tour/UnmanagedResources.csx#L1-L6)]

<span data-ttu-id="6c97d-142">Dopo che il blocco `using` è stato completato, il runtime di .NET chiama automaticamente il metodo `stream` dell'oggetto <xref:System.IDisposable.Dispose>, che rilascia l'handle di file.</span><span class="sxs-lookup"><span data-stu-id="6c97d-142">Once the `using` block completes, the .NET runtime automatically calls the `stream` object's <xref:System.IDisposable.Dispose> method, which releases the file handle.</span></span> <span data-ttu-id="6c97d-143">Il runtime esegue questa operazione anche se un'eccezione fa sì che il controllo lasci il blocco.</span><span class="sxs-lookup"><span data-stu-id="6c97d-143">The runtime also does this if an exception causes control to leave the block.</span></span>

<span data-ttu-id="6c97d-144">Per informazioni dettagliate, vedere gli argomenti seguenti:</span><span class="sxs-lookup"><span data-stu-id="6c97d-144">For more details, see the following topics:</span></span>

* <span data-ttu-id="6c97d-145">Per C#, vedere l'argomento [Istruzione using (Riferimenti per C#)](../csharp/language-reference/keywords/using-statement.md).</span><span class="sxs-lookup"><span data-stu-id="6c97d-145">For C#, see the [using Statement (C# Reference)](../csharp/language-reference/keywords/using-statement.md) topic.</span></span>
* <span data-ttu-id="6c97d-146">Per F#, vedere [Resource Management: The use Keyword](../fsharp/language-reference/resource-management-the-use-keyword.md) (Gestione delle risorse: la parola chiave use).</span><span class="sxs-lookup"><span data-stu-id="6c97d-146">For F#, see [Resource Management: The use Keyword](../fsharp/language-reference/resource-management-the-use-keyword.md).</span></span>
* <span data-ttu-id="6c97d-147">Per Visual Basic, vedere l'argomento [istruzioni using (Visual Basic)](../visual-basic/language-reference/statements/using-statement.md) .</span><span class="sxs-lookup"><span data-stu-id="6c97d-147">For Visual Basic, see the [Using Statement (Visual Basic)](../visual-basic/language-reference/statements/using-statement.md) topic.</span></span>

## <a name="type-safety"></a><span data-ttu-id="6c97d-148">Indipendenza dai tipi</span><span class="sxs-lookup"><span data-stu-id="6c97d-148">Type safety</span></span>

<span data-ttu-id="6c97d-149">Un oggetto è un'istanza di un tipo specifico.</span><span class="sxs-lookup"><span data-stu-id="6c97d-149">An object is an instance of a specific type.</span></span> <span data-ttu-id="6c97d-150">Le uniche operazioni consentite per un determinato oggetto sono quelle del relativo tipo.</span><span class="sxs-lookup"><span data-stu-id="6c97d-150">The only operations allowed for a given object are those of its type.</span></span> <span data-ttu-id="6c97d-151">Un oggetto `Dog` può avere i metodi `Jump` e `WagTail`, ma non un metodo `SumTotal`.</span><span class="sxs-lookup"><span data-stu-id="6c97d-151">A `Dog` type may have `Jump` and `WagTail` methods but not a `SumTotal` method.</span></span> <span data-ttu-id="6c97d-152">Un programma chiama solo i metodi appartenenti a un tipo specifico.</span><span class="sxs-lookup"><span data-stu-id="6c97d-152">A program only calls the methods belonging to a given type.</span></span> <span data-ttu-id="6c97d-153">Tutte le altre chiamate generano un errore in fase di compilazione o un'eccezione di runtime, se si usano funzionalità dinamiche o `object`.</span><span class="sxs-lookup"><span data-stu-id="6c97d-153">All other calls result in either a compile-time error or a run-time exception (in case of using dynamic features or `object`).</span></span>

<span data-ttu-id="6c97d-154">I linguaggi .NET sono orientati agli oggetti, con gerarchie di classi di base e derivate.</span><span class="sxs-lookup"><span data-stu-id="6c97d-154">.NET languages are object-oriented with hierarchies of base and derived classes.</span></span> <span data-ttu-id="6c97d-155">Il runtime .NET consente solo cast degli oggetti e chiamate allineate alla gerarchia di oggetti.</span><span class="sxs-lookup"><span data-stu-id="6c97d-155">The .NET runtime only allows object casts and calls that align with the object hierarchy.</span></span> <span data-ttu-id="6c97d-156">Si tenga presente che ogni tipo definito in un qualsiasi linguaggio .NET deriva dal tipo di base <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="6c97d-156">Remember that every type defined in any .NET language derives from the base <xref:System.Object> type.</span></span>

[!code-csharp[TypeSafety](../../samples/snippets/csharp/snippets/tour/TypeSafety.csx#L19-L23)]

<span data-ttu-id="6c97d-157">L'indipendenza dai tipi viene inoltre usata per forzare l'incapsulamento garantendo la fedeltà delle parole chiave di accesso.</span><span class="sxs-lookup"><span data-stu-id="6c97d-157">Type safety is also used to help enforce encapsulation by guaranteeing the fidelity of the accessor keywords.</span></span> <span data-ttu-id="6c97d-158">Le parole chiave di accesso sono elementi che controllano l'accesso ai membri di un determinato tipo da parte di altro codice.</span><span class="sxs-lookup"><span data-stu-id="6c97d-158">Accessor keywords are artifacts which control access to members of a given type by other code.</span></span> <span data-ttu-id="6c97d-159">Vengono in genere usate per diversi dati presenti all'interno di un tipo e per gestire il comportamento del tipo stesso.</span><span class="sxs-lookup"><span data-stu-id="6c97d-159">These are usually used for various kinds of data within a type that are used to manage its behavior.</span></span>

[!code-csharp[TypeSafety](../../samples/snippets/csharp/snippets/tour/TypeSafety.csx#L3-L3)]

<span data-ttu-id="6c97d-160">C#, Visual Basic e F# supportano l'*inferenza del tipo* locale.</span><span class="sxs-lookup"><span data-stu-id="6c97d-160">C#, Visual Basic, and F# support local *type inference*.</span></span> <span data-ttu-id="6c97d-161">Con l'inferenza del tipo, il compilatore deduce il tipo dell'espressione sul lato sinistro dall'espressione sul lato destro.</span><span class="sxs-lookup"><span data-stu-id="6c97d-161">Type inference means that the compiler deduces the type of the expression on the left-hand side from the expression on the right-hand side.</span></span> <span data-ttu-id="6c97d-162">Questo non significa che l'indipendenza dai tipi è interrotta o evitata.</span><span class="sxs-lookup"><span data-stu-id="6c97d-162">This doesn't mean that the type safety is broken or avoided.</span></span> <span data-ttu-id="6c97d-163">Il tipo risultante ha un tipo sicuro, con tutto quello che implica tale caratteristica.</span><span class="sxs-lookup"><span data-stu-id="6c97d-163">The resulting type does have a strong type with everything that implies.</span></span> <span data-ttu-id="6c97d-164">Nell'esempio precedente `dog` viene riscritto per introdurre l'inferenza del tipo e il resto dell'esempio non subisce modifiche:</span><span class="sxs-lookup"><span data-stu-id="6c97d-164">From the previous example, `dog` is rewritten to introduce type inference, and the remainder of the example is unchanged:</span></span>

[!code-csharp[TypeSafety](../../samples/snippets/csharp/snippets/tour/TypeSafety.csx#L28-L34)]

<span data-ttu-id="6c97d-165">F#dispone anche di altre funzionalità di inferenza del tipo rispetto all'inferenza del C# tipo locale del metodo disponibile in e Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="6c97d-165">F# has even further type inference capabilities than the method-local type inference found in C# and Visual Basic.</span></span> <span data-ttu-id="6c97d-166">Per altre informazioni, vedere [Inferenza del tipo](../fsharp/language-reference/type-inference.md).</span><span class="sxs-lookup"><span data-stu-id="6c97d-166">To learn more, see [Type Inference](../fsharp/language-reference/type-inference.md).</span></span>

## <a name="delegates-and-lambdas"></a><span data-ttu-id="6c97d-167">Delegati e lambda</span><span class="sxs-lookup"><span data-stu-id="6c97d-167">Delegates and lambdas</span></span>

<span data-ttu-id="6c97d-168">Un delegato è rappresentato da una firma del metodo.</span><span class="sxs-lookup"><span data-stu-id="6c97d-168">A delegate is represented by a method signature.</span></span> <span data-ttu-id="6c97d-169">Ogni metodo con tale firma può essere assegnato al delegato e viene eseguito quando viene richiamato il delegato.</span><span class="sxs-lookup"><span data-stu-id="6c97d-169">Any method with that signature can be assigned to the delegate and is executed when the delegate is invoked.</span></span>

<span data-ttu-id="6c97d-170">I delegati sono simili ai puntatori a funzione del linguaggio C++, ma sono indipendenti dai tipi.</span><span class="sxs-lookup"><span data-stu-id="6c97d-170">Delegates are like C++ function pointers except that they're type safe.</span></span> <span data-ttu-id="6c97d-171">Sono un tipo di metodo disconnesso all'interno del sistema di tipo CLR.</span><span class="sxs-lookup"><span data-stu-id="6c97d-171">They're a kind of disconnected method within the CLR type system.</span></span> <span data-ttu-id="6c97d-172">I metodi regolari sono collegati a una classe e possono essere chiamati direttamente solo tramite convenzioni di chiamata statiche o di istanza.</span><span class="sxs-lookup"><span data-stu-id="6c97d-172">Regular methods are attached to a class and are only directly callable through static or instance calling conventions.</span></span>

<span data-ttu-id="6c97d-173">In .NET i delegati vengono usati comunemente nei gestori dell'evento, nella definizione delle operazioni asincrone e nelle espressioni lambda, che costituiscono uno degli elementi fondamentali di LINQ.</span><span class="sxs-lookup"><span data-stu-id="6c97d-173">In .NET, delegates are commonly used in event handlers, in defining asynchronous operations, and in lambda expressions, which are a cornerstone of LINQ.</span></span> <span data-ttu-id="6c97d-174">Per altre informazioni, vedere l'argomento [Delegati e lambda](delegates-lambdas.md).</span><span class="sxs-lookup"><span data-stu-id="6c97d-174">Learn more in the [Delegates and lambdas](delegates-lambdas.md) topic.</span></span>

## <a name="generics"></a><span data-ttu-id="6c97d-175">Generics</span><span class="sxs-lookup"><span data-stu-id="6c97d-175">Generics</span></span>

<span data-ttu-id="6c97d-176">I generics consentono al programmatore di introdurre un *parametro di tipo* durante la definizione delle classi, operazione che consente al codice client (gli utenti del tipo) di specificare il tipo esatto da usare al posto del parametro di tipo.</span><span class="sxs-lookup"><span data-stu-id="6c97d-176">Generics allow the programmer to introduce a *type parameter* when designing their classes that allows the client code (the users of the type) to specify the exact type to use in place of the type parameter.</span></span>

<span data-ttu-id="6c97d-177">I generics sono stati aggiunti per consentire ai programmatori di implementare strutture dati generiche.</span><span class="sxs-lookup"><span data-stu-id="6c97d-177">Generics were added to help programmers implement generic data structures.</span></span> <span data-ttu-id="6c97d-178">Prima del loro arrivo, per un tipo, ad esempio il tipo `List` essere generico, sarebbe necessario utilizzare elementi di tipo `object`.</span><span class="sxs-lookup"><span data-stu-id="6c97d-178">Before their arrival, in order for a type such as the `List` type to be generic, it would have to work with elements that were of type `object`.</span></span> <span data-ttu-id="6c97d-179">Si sono verificati diversi problemi di prestazioni e semantica, oltre a possibili errori di run-time.</span><span class="sxs-lookup"><span data-stu-id="6c97d-179">This had various performance and semantic problems, along with possible subtle run-time errors.</span></span> <span data-ttu-id="6c97d-180">Un errore di run-time comune si verifica quando una struttura di dati contiene, ad esempio, sia numeri interi che stringhe e viene generata un'<xref:System.InvalidCastException> durante l'elaborazione dei membri dell'elenco.</span><span class="sxs-lookup"><span data-stu-id="6c97d-180">A common run-time error is when a data structure contains, for example, both integers and strings, and an <xref:System.InvalidCastException> is thrown while processing the list's members.</span></span>

<span data-ttu-id="6c97d-181">L'esempio seguente mostra un programma di base in esecuzione mediante un'istanza dei tipi <xref:System.Collections.Generic.List%601>:</span><span class="sxs-lookup"><span data-stu-id="6c97d-181">The following sample shows a basic program running using an instance of <xref:System.Collections.Generic.List%601> types:</span></span>

[!code-csharp[GenericsShort](../../samples/snippets/csharp/snippets/tour/GenericsShort.csx)]

<span data-ttu-id="6c97d-182">Per altre informazioni, vedere l'argomento [Panoramica di tipi generici (generics)](generics.md).</span><span class="sxs-lookup"><span data-stu-id="6c97d-182">For more information, see the [Generic types (Generics) overview](generics.md) topic.</span></span>

## <a name="async-programming"></a><span data-ttu-id="6c97d-183">Programmazione asincrona</span><span class="sxs-lookup"><span data-stu-id="6c97d-183">Async programming</span></span>

<span data-ttu-id="6c97d-184">La programmazione asincrona è uno dei concetti fondamentali di .NET, poiché offre supporto asincrono nel runtime, nelle librerie del framework e nei costrutti dei linguaggi .NET.</span><span class="sxs-lookup"><span data-stu-id="6c97d-184">Async programming is a first-class concept within .NET with async support in the runtime, framework libraries, and .NET language constructs.</span></span> <span data-ttu-id="6c97d-185">A livello interno, questi elementi sono basati su oggetti, ad esempio `Task`, e sfruttano i vantaggi offerti dal sistema operativo per eseguire i processi di I/O nel modo più efficiente possibile.</span><span class="sxs-lookup"><span data-stu-id="6c97d-185">Internally, they're based on objects (such as `Task`), which take advantage of the operating system to perform I/O-bound jobs as efficiently as possible.</span></span>

<span data-ttu-id="6c97d-186">Per altre informazioni sulla programmazione asincrona in .NET, iniziare con la lettura dell'argomento [Panoramica della programmazione asincrona](async.md).</span><span class="sxs-lookup"><span data-stu-id="6c97d-186">To learn more about async programming in .NET, start with the [Async overview](async.md) topic.</span></span>

## <a name="language-integrated-query-linq"></a><span data-ttu-id="6c97d-187">LINQ (Language-Integrated Query)</span><span class="sxs-lookup"><span data-stu-id="6c97d-187">Language Integrated Query (LINQ)</span></span>

<span data-ttu-id="6c97d-188">LINQ è un potente set di funzionalità per C# e Visual Basic che consentono di scrivere codice semplice e dichiarativo per operare sui dati.</span><span class="sxs-lookup"><span data-stu-id="6c97d-188">LINQ is a powerful set of features for C# and Visual Basic that allow you to write simple, declarative code for operating on data.</span></span> <span data-ttu-id="6c97d-189">I dati possono avere diverse forme, ad esempio oggetti in memoria, dati in un database SQL o un documento XML, ma il codice LINQ scritto non presenta in genere differenze in base alle origini dati.</span><span class="sxs-lookup"><span data-stu-id="6c97d-189">The data can be in many forms (such as in-memory objects, a SQL database, or an XML document), but the LINQ code you write typically doesn't differ by data source.</span></span>

<span data-ttu-id="6c97d-190">Per altre informazioni e alcuni esempi, vedere l'argomento [LINQ (Language-Integrated Query)](using-linq.md).</span><span class="sxs-lookup"><span data-stu-id="6c97d-190">To learn more and see some samples, see the [LINQ (Language Integrated Query)](using-linq.md) topic.</span></span>

## <a name="native-interoperability"></a><span data-ttu-id="6c97d-191">Interoperabilità nativa</span><span class="sxs-lookup"><span data-stu-id="6c97d-191">Native interoperability</span></span>

<span data-ttu-id="6c97d-192">Ogni sistema operativo include un'API (Application Programming Interface) che fornisce servizi di sistema.</span><span class="sxs-lookup"><span data-stu-id="6c97d-192">Every operating system includes an application programming interface (API) that provides system services.</span></span> <span data-ttu-id="6c97d-193">.NET consente di chiamare tali API in diversi modi.</span><span class="sxs-lookup"><span data-stu-id="6c97d-193">.NET provides several ways to call those APIs.</span></span>

<span data-ttu-id="6c97d-194">Il metodo principale per ottenere l'interoperabilità nativa è usare "platform invoke", abbreviato in P/Invoke, supportato nelle piattaforme Linux e Windows.</span><span class="sxs-lookup"><span data-stu-id="6c97d-194">The main way to do native interoperability is via "platform invoke" or P/Invoke for short, which is supported across Linux and Windows platforms.</span></span> <span data-ttu-id="6c97d-195">Un metodo, valido solo per Windows, per ottenere l'interoperabilità nativa è noto come "interoperabilità COM" ed è usato per operare con [componenti COM](/cpp/atl/introduction-to-com) nel codice gestito.</span><span class="sxs-lookup"><span data-stu-id="6c97d-195">A Windows-only way of doing native interoperability is known as "COM interop," which is used to work with [COM components](/cpp/atl/introduction-to-com) in managed code.</span></span> <span data-ttu-id="6c97d-196">Tale metodo è basato sull'infrastruttura P/Invoke, ma funziona in modo leggermente diverso.</span><span class="sxs-lookup"><span data-stu-id="6c97d-196">It's built on top of the P/Invoke infrastructure, but it works in subtly different ways.</span></span>

<span data-ttu-id="6c97d-197">La maggior parte del supporto per l'interoperabilità di Mono (e di Xamarin) per Java e Objective-C è realizzato in modo simile, nel senso che vengono usati gli stessi principi.</span><span class="sxs-lookup"><span data-stu-id="6c97d-197">Most of Mono's (and thus Xamarin's) interoperability support for Java and Objective-C are built similarly, that is, they use the same principles.</span></span>

<span data-ttu-id="6c97d-198">Per altre informazioni sull'interoperabilità nativa, vedere l'articolo [Interoperabilità nativa](native-interop/index.md).</span><span class="sxs-lookup"><span data-stu-id="6c97d-198">For more information about native interoperability, see the [Native interoperability](native-interop/index.md) article.</span></span>

## <a name="unsafe-code"></a><span data-ttu-id="6c97d-199">Codice di tipo unsafe</span><span class="sxs-lookup"><span data-stu-id="6c97d-199">Unsafe code</span></span>

<span data-ttu-id="6c97d-200">In base al supporto del linguaggio, CLR consente di accedere alla memoria nativa e di eseguire l'aritmetica dei puntatori tramite il codice `unsafe`.</span><span class="sxs-lookup"><span data-stu-id="6c97d-200">Depending on language support, the CLR lets you access native memory and do pointer arithmetic via `unsafe` code.</span></span> <span data-ttu-id="6c97d-201">Queste operazioni sono necessarie per determinati algoritmi e per l'interoperabilità dei sistemi.</span><span class="sxs-lookup"><span data-stu-id="6c97d-201">These operations are needed for certain algorithms and system interoperability.</span></span> <span data-ttu-id="6c97d-202">Anche se il codice di tipo unsafe è uno strumento potente, non è consigliabile usarlo a meno che non sia necessario per l'interoperabilità con API di sistema o per implementare l'algoritmo più efficiente.</span><span class="sxs-lookup"><span data-stu-id="6c97d-202">Although powerful, use of unsafe code is discouraged unless it's necessary to interop with system APIs or implement the most efficient algorithm.</span></span> <span data-ttu-id="6c97d-203">Il codice di tipo unsafe non può essere eseguito nello stesso modo in ambienti diversi e inoltre non sfrutta i vantaggi offerti da un Garbage Collector e dall'indipendenza dai tipi.</span><span class="sxs-lookup"><span data-stu-id="6c97d-203">Unsafe code may not execute the same way in different environments and also loses the benefits of a garbage collector and type safety.</span></span> <span data-ttu-id="6c97d-204">È consigliabile limitare e centralizzare il codice di tipo unsafe nella misura massima possibile. È inoltre necessario testare tale codice in modo accurato.</span><span class="sxs-lookup"><span data-stu-id="6c97d-204">It's recommended to confine and centralize unsafe code as much as possible and test that code thoroughly.</span></span>

<span data-ttu-id="6c97d-205">L'esempio seguente è una versione modificata del metodo `ToString()` della classe `StringBuilder`</span><span class="sxs-lookup"><span data-stu-id="6c97d-205">The following example is a modified version of the `ToString()` method from the `StringBuilder` class.</span></span> <span data-ttu-id="6c97d-206">e illustra come l'uso di codice `unsafe` possa implementare in modo efficiente un algoritmo spostando direttamente blocchi di memoria:</span><span class="sxs-lookup"><span data-stu-id="6c97d-206">It illustrates how using `unsafe` code can efficiently implement an algorithm by moving around chunks of memory directly:</span></span>

[!code-csharp[Unsafe](../../samples/snippets/csharp/snippets/tour/Unsafe.csx)]

## <a name="next-steps"></a><span data-ttu-id="6c97d-207">Passaggi successivi</span><span class="sxs-lookup"><span data-stu-id="6c97d-207">Next steps</span></span>

<span data-ttu-id="6c97d-208">Per una panoramica delle funzionalità di C#, vedere [Tour of C#](../csharp/tour-of-csharp/index.md) (Panoramica di C#).</span><span class="sxs-lookup"><span data-stu-id="6c97d-208">If you're interested in a tour of C# features, check out [Tour of C#](../csharp/tour-of-csharp/index.md).</span></span>

<span data-ttu-id="6c97d-209">Per una panoramica delle funzionalità di F#, vedere l'articolo [Tour of F#](../fsharp/tour.md) (Panoramica di F#).</span><span class="sxs-lookup"><span data-stu-id="6c97d-209">If you're interested in a tour of F# features, see [Tour of F#](../fsharp/tour.md).</span></span>

<span data-ttu-id="6c97d-210">Per un'introduzione alla scrittura di codice personalizzato, vedere [Introduzione](get-started.md).</span><span class="sxs-lookup"><span data-stu-id="6c97d-210">If you want to get started with writing code of your own, visit [Getting Started](get-started.md).</span></span>

<span data-ttu-id="6c97d-211">Per informazioni sui componenti principali di .NET, vedere [Componenti dell'architettura .NET](components.md).</span><span class="sxs-lookup"><span data-stu-id="6c97d-211">To learn about important components of .NET, check out [.NET Architectural Components](components.md).</span></span>
