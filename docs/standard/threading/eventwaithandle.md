---
title: EventWaitHandle
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- threading [.NET Framework], EventWaitHandle class
- EventWaitHandle class
- event wait handles [.NET Framework]
- threading [.NET Framework], cross-process synchronization
ms.assetid: 11ee0b38-d663-4617-b793-35eb6c64e9fc
ms.openlocfilehash: 80c90254978495a58d228c4302eda84d6165c800
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 03/15/2020
ms.locfileid: "73138080"
---
# <a name="eventwaithandle"></a><span data-ttu-id="3cbaa-102">EventWaitHandle</span><span class="sxs-lookup"><span data-stu-id="3cbaa-102">EventWaitHandle</span></span>
<span data-ttu-id="3cbaa-103">La classe <xref:System.Threading.EventWaitHandle> consente la comunicazione tra i thread inviando e attendendo i segnali.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-103">The <xref:System.Threading.EventWaitHandle> class allows threads to communicate with each other by signaling and by waiting for signals.</span></span> <span data-ttu-id="3cbaa-104">Gli handle di attesa degli eventi (detti anche semplicemente eventi) sono handle di attesa che possono essere segnalati per rilasciare uno o più thread in attesa.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-104">Event wait handles (also referred to simply as events) are wait handles that can be signaled in order to release one or more waiting threads.</span></span> <span data-ttu-id="3cbaa-105">Un handle di attesa di un evento, dopo essere stato segnalato, viene reimpostato manualmente o automaticamente.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-105">After it is signaled, an event wait handle is reset either manually or automatically.</span></span> <span data-ttu-id="3cbaa-106">La classe <xref:System.Threading.EventWaitHandle> può rappresentare un handle di attesa di un evento locale (evento locale) o un handle di attesa di un evento di sistema denominato (evento denominato o evento di sistema, visibile a tutti i processi).</span><span class="sxs-lookup"><span data-stu-id="3cbaa-106">The <xref:System.Threading.EventWaitHandle> class can represent either a local event wait handle (local event) or a named system event wait handle (named event or system event, visible to all processes).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="3cbaa-107">Gli handle di attesa evento non sono [eventi](../events/index.md) .NET.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-107">Event wait handles are not .NET [events](../events/index.md).</span></span> <span data-ttu-id="3cbaa-108">Non sono coinvolti delegati o gestori eventi.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-108">There are no delegates or event handlers involved.</span></span> <span data-ttu-id="3cbaa-109">Si usa la parola "evento" per descriverli perché sono sempre stati indicati come eventi del sistema operativo e perché l'azione di segnalare l'handle di attesa indica ai thread in attesa che si è verificato un evento.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-109">The word "event" is used to describe them because they have traditionally been referred to as operating-system events, and because the act of signaling the wait handle indicates to waiting threads that an event has occurred.</span></span>  
  
 <span data-ttu-id="3cbaa-110">Sia gli handle di attesa degli eventi locali che quelli denominati usano oggetti di sincronizzazione del sistema, protetti da wrapper <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> per assicurare che le risorse vengano rilasciate.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-110">Both local and named event wait handles use system synchronization objects, which are protected by <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> wrappers to ensure that the resources are released.</span></span> <span data-ttu-id="3cbaa-111">È possibile usare il metodo <xref:System.Threading.WaitHandle.Dispose%2A> per liberare le risorse immediatamente dopo aver finito di usare l'oggetto.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-111">You can use the <xref:System.Threading.WaitHandle.Dispose%2A> method to free the resources immediately when you have finished using the object.</span></span>  
  
## <a name="event-wait-handles-that-reset-automatically"></a><span data-ttu-id="3cbaa-112">Handle di attesa degli eventi reimpostati automaticamente</span><span class="sxs-lookup"><span data-stu-id="3cbaa-112">Event Wait Handles That Reset Automatically</span></span>  
 <span data-ttu-id="3cbaa-113">Per creare un evento di reimpostazione automatica, specificare <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> quando si crea l'oggetto <xref:System.Threading.EventWaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-113">You create an automatic reset event by specifying <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> when you create the <xref:System.Threading.EventWaitHandle> object.</span></span> <span data-ttu-id="3cbaa-114">Come indica il nome, questo evento di sincronizzazione viene reimpostato automaticamente quando viene segnalato, dopo avere rilasciato un singolo thread in attesa.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-114">As its name implies, this synchronization event resets automatically when signaled, after releasing a single waiting thread.</span></span> <span data-ttu-id="3cbaa-115">Per segnalare l'evento, chiamare il metodo <xref:System.Threading.EventWaitHandle.Set%2A>.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-115">Signal the event by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method.</span></span>  
  
 <span data-ttu-id="3cbaa-116">Gli eventi di reimpostazione automatica vengono in genere usati per fornire l'accesso esclusivo a una risorsa per un singolo thread per volta.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-116">Automatic reset events are usually used to provide exclusive access to a resource for a single thread at a time.</span></span> <span data-ttu-id="3cbaa-117">Un thread richiede la risorsa chiamando il metodo <xref:System.Threading.WaitHandle.WaitOne%2A>.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-117">A thread requests the resource by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="3cbaa-118">Se nessun altro thread contiene l'handle di attesa, il metodo restituisce `true` e il thread chiamante ha il controllo della risorsa.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-118">If no other thread is holding the wait handle, the method returns `true` and the calling thread has control of the resource.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="3cbaa-119">Come per tutti i meccanismi di sincronizzazione, è necessario assicurarsi che tutti i percorsi del codice attendano l'handle di attesa appropriato prima di accedere a una risorsa protetta.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-119">As with all synchronization mechanisms, you must ensure that all code paths wait on the appropriate wait handle before accessing a protected resource.</span></span> <span data-ttu-id="3cbaa-120">La sincronizzazione dei thread è cooperativa.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-120">Thread synchronization is cooperative.</span></span>  
  
 <span data-ttu-id="3cbaa-121">Se un evento di reimpostazione automatica viene segnalato quando nessun thread è in attesa, rimane segnalato finché un thread non prova ad attenderlo.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-121">If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it.</span></span> <span data-ttu-id="3cbaa-122">L'evento rilascia il thread e viene immediatamente reimpostato, bloccando i thread successivi.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-122">The event releases the thread and immediately resets, blocking subsequent threads.</span></span>  
  
## <a name="event-wait-handles-that-reset-manually"></a><span data-ttu-id="3cbaa-123">Handle di attesa degli eventi reimpostati manualmente</span><span class="sxs-lookup"><span data-stu-id="3cbaa-123">Event Wait Handles That Reset Manually</span></span>  
 <span data-ttu-id="3cbaa-124">Per creare un evento di reimpostazione manuale, specificare <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> quando si crea l'oggetto <xref:System.Threading.EventWaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-124">You create a manual reset event by specifying <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> when you create the <xref:System.Threading.EventWaitHandle> object.</span></span> <span data-ttu-id="3cbaa-125">Come indica il nome, questo evento di sincronizzazione deve essere reimpostato manualmente dopo essere stato segnalato.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-125">As its name implies, this synchronization event must be reset manually after it has been signaled.</span></span> <span data-ttu-id="3cbaa-126">Finché non viene reimpostato, chiamando il metodo <xref:System.Threading.EventWaitHandle.Reset%2A>, i thread in attesa dell'handle dell'evento procedono immediatamente senza bloccarsi.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-126">Until it is reset, by calling its <xref:System.Threading.EventWaitHandle.Reset%2A> method, threads that wait on the event handle proceed immediately without blocking.</span></span>  
  
 <span data-ttu-id="3cbaa-127">Un evento di reimpostazione manuale è paragonabile al cancello di un recinto.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-127">A manual reset event acts like the gate of a corral.</span></span> <span data-ttu-id="3cbaa-128">Quando l'evento non viene segnalato, i thread che lo attendono vengono bloccati, come cavalli in un recinto.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-128">When the event is not signaled, threads that wait on it block, like horses in a corral.</span></span> <span data-ttu-id="3cbaa-129">Quando l'evento viene segnalato, chiamando il metodo <xref:System.Threading.EventWaitHandle.Set%2A>, tutti i thread in attesa possono procedere.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-129">When the event is signaled, by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, all waiting threads are free to proceed.</span></span> <span data-ttu-id="3cbaa-130">L'evento rimane segnalato finché non viene chiamato il metodo <xref:System.Threading.EventWaitHandle.Reset%2A>.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-130">The event remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="3cbaa-131">L'evento di reimpostazione manuale risulta quindi un modo ideale per bloccare i thread che devono attendere finché un thread non termina un'attività.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-131">This makes the manual reset event an ideal way to hold up threads that need to wait until one thread finishes a task.</span></span>  
  
 <span data-ttu-id="3cbaa-132">Come quando i cavalli escono da un recinto, la pianificazione, tramite il sistema operativo, dei thread rilasciati e la ripresa dell'esecuzione richiedono tempo.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-132">Like horses leaving a corral, it takes time for the released threads to be scheduled by the operating system and to resume execution.</span></span> <span data-ttu-id="3cbaa-133">Se il metodo <xref:System.Threading.EventWaitHandle.Reset%2A> viene chiamato prima che tutti i thread abbiano ripreso l'esecuzione, i thread rimanenti vengono bloccati ancora una volta.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-133">If the <xref:System.Threading.EventWaitHandle.Reset%2A> method is called before all the threads have resumed execution, the remaining threads once again block.</span></span> <span data-ttu-id="3cbaa-134">Quali thread riprendono e quali si bloccano dipende da fattori casuali, ad esempio il carico sul sistema, il numero di thread in attesa dell'utilità di pianificazione e così via.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-134">Which threads resume and which threads block depends on random factors like the load on the system, the number of threads waiting for the scheduler, and so on.</span></span> <span data-ttu-id="3cbaa-135">Ciò non rappresenta un problema se il thread che segnala l'evento termina dopo la segnalazione, che è il modello di utilizzo più comune.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-135">This is not a problem if the thread that signals the event ends after signaling, which is the most common usage pattern.</span></span> <span data-ttu-id="3cbaa-136">Se si vuole che il thread che ha segnalato l'evento inizi una nuova attività dopo che tutti i thread in attesa sono stati ripresi, è necessario bloccarlo finché tutti i thread in attesa non sono stati ripresi.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-136">If you want the thread that signaled the event to begin a new task after all the waiting threads have resumed, you must block it until all the waiting threads have resumed.</span></span> <span data-ttu-id="3cbaa-137">In caso contrario, si verifica una race condition e il comportamento del codice non è prevedibile.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-137">Otherwise, you have a race condition, and the behavior of your code is unpredictable.</span></span>  
  
## <a name="features-common-to-automatic-and-manual-events"></a><span data-ttu-id="3cbaa-138">Funzionalità comuni a eventi automatici e manuali</span><span class="sxs-lookup"><span data-stu-id="3cbaa-138">Features Common to Automatic and Manual Events</span></span>  
 <span data-ttu-id="3cbaa-139">Uno o più thread vengono in genere bloccati su una classe <xref:System.Threading.EventWaitHandle> finché un thread non bloccato non chiama il metodo <xref:System.Threading.EventWaitHandle.Set%2A>, che rilascia uno dei thread in attesa (in caso di eventi di reimpostazione automatica) oppure tutti (in caso di eventi di reimpostazione manuale).</span><span class="sxs-lookup"><span data-stu-id="3cbaa-139">Typically, one or more threads block on an <xref:System.Threading.EventWaitHandle> until an unblocked thread calls the <xref:System.Threading.EventWaitHandle.Set%2A> method, which releases one of the waiting threads (in the case of automatic reset events) or all of them (in the case of manual reset events).</span></span> <span data-ttu-id="3cbaa-140">Un thread può segnalare una classe <xref:System.Threading.EventWaitHandle> e quindi venire bloccato, come un'operazione atomica, chiamando il metodo statico <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-140">A thread can signal an <xref:System.Threading.EventWaitHandle> and then block on it, as an atomic operation, by calling the static <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="3cbaa-141">Gli oggetti <xref:System.Threading.EventWaitHandle> possono essere usati con i metodi statici <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> e <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-141"><xref:System.Threading.EventWaitHandle> objects can be used with the static <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="3cbaa-142">Poiché le classi <xref:System.Threading.EventWaitHandle> e <xref:System.Threading.Mutex> derivano entrambe da <xref:System.Threading.WaitHandle>, è possibile usare entrambe le classi con questi metodi.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-142">Because the <xref:System.Threading.EventWaitHandle> and <xref:System.Threading.Mutex> classes both derive from <xref:System.Threading.WaitHandle>, you can use both classes with these methods.</span></span>  
  
### <a name="named-events"></a><span data-ttu-id="3cbaa-143">Eventi denominati</span><span class="sxs-lookup"><span data-stu-id="3cbaa-143">Named Events</span></span>  
 <span data-ttu-id="3cbaa-144">Il sistema operativo Windows consente di assegnare nomi agli handle di attesa degli eventi.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-144">The Windows operating system allows event wait handles to have names.</span></span> <span data-ttu-id="3cbaa-145">Un evento denominato è a livello di sistema,</span><span class="sxs-lookup"><span data-stu-id="3cbaa-145">A named event is system wide.</span></span> <span data-ttu-id="3cbaa-146">vale a dire che, dopo essere stato creato, l'evento denominato è visibile a tutti i thread in tutti i processi.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-146">That is, once the named event is created, it is visible to all threads in all processes.</span></span> <span data-ttu-id="3cbaa-147">In questo modo, gli eventi denominati possono essere usati per sincronizzare le attività di processi e thread.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-147">Thus, named events can be used to synchronize the activities of processes as well as threads.</span></span>  
  
 <span data-ttu-id="3cbaa-148">È possibile creare un oggetto <xref:System.Threading.EventWaitHandle> che rappresenta un evento di sistema denominato usando uno dei costruttori che specifica un nome di evento.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-148">You can create an <xref:System.Threading.EventWaitHandle> object that represents a named system event by using one of the constructors that specifies an event name.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="3cbaa-149">Poiché gli eventi denominati sono a livello di sistema, è possibile avere più oggetti <xref:System.Threading.EventWaitHandle> che rappresentano lo stesso evento denominato.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-149">Because named events are system wide, it is possible to have multiple <xref:System.Threading.EventWaitHandle> objects that represent the same named event.</span></span> <span data-ttu-id="3cbaa-150">A ogni chiamata a un costruttore o al metodo <xref:System.Threading.EventWaitHandle.OpenExisting%2A> viene creato un nuovo oggetto <xref:System.Threading.EventWaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-150">Each time you call a constructor, or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method, a new <xref:System.Threading.EventWaitHandle> object is created.</span></span> <span data-ttu-id="3cbaa-151">Specificando lo stesso nome ripetutamente verranno creati più oggetti che rappresentano lo stesso evento denominato.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-151">Specifying the same name repeatedly creates multiple objects that represent the same named event.</span></span>  
  
 <span data-ttu-id="3cbaa-152">È consigliabile prestare attenzione nell'uso degli eventi denominati.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-152">Caution is advised in using named events.</span></span> <span data-ttu-id="3cbaa-153">Poiché sono a livello di sistema, un altro processo che usa lo stesso nome può bloccare i thread in modo imprevisto.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-153">Because they are system wide, another process that uses the same name can block your threads unexpectedly.</span></span> <span data-ttu-id="3cbaa-154">Il malware in esecuzione sullo stesso computer potrebbe sfruttare questa opportunità per un attacco Denial of Service.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-154">Malicious code executing on the same computer could use this as the basis of a denial-of-service attack.</span></span>  
  
 <span data-ttu-id="3cbaa-155">Usare il controllo di accesso per proteggere un oggetto <xref:System.Threading.EventWaitHandle> che rappresenta un evento denominato, preferibilmente usando un costruttore che specifichi un oggetto <xref:System.Security.AccessControl.EventWaitHandleSecurity>.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-155">Use access control security to protect an <xref:System.Threading.EventWaitHandle> object that represents a named event, preferably by using a constructor that specifies an <xref:System.Security.AccessControl.EventWaitHandleSecurity> object.</span></span> <span data-ttu-id="3cbaa-156">È anche possibile applicare la sicurezza del controllo di accesso usando il metodo <xref:System.Threading.EventWaitHandle.SetAccessControl%2A>, ma in tal modo verrà creata una finestra di vulnerabilità tra l'ora di creazione dell'handle di attesa degli eventi e l'ora in cui viene protetto.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-156">You can also apply access control security using the <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> method, but this leaves a window of vulnerability between the time the event wait handle is created and the time it is protected.</span></span> <span data-ttu-id="3cbaa-157">La protezione degli eventi con la sicurezza del controllo di accesso aiuta a impedire gli attacchi dannosi, ma non risolve il problema dei conflitti di nomi non intenzionali.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-157">Protecting events with access control security helps prevent malicious attacks, but it does not solve the problem of unintentional name collisions.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="3cbaa-158">Diversamente dalla classe <xref:System.Threading.EventWaitHandle>, le classi derivate <xref:System.Threading.AutoResetEvent> e <xref:System.Threading.ManualResetEvent> possono rappresentare solo handle di attesa locali.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-158">Unlike the <xref:System.Threading.EventWaitHandle> class, the derived classes <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> can represent only local wait handles.</span></span> <span data-ttu-id="3cbaa-159">Non possono rappresentare gli eventi di sistema denominati.</span><span class="sxs-lookup"><span data-stu-id="3cbaa-159">They cannot represent named system events.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="3cbaa-160">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="3cbaa-160">See also</span></span>

- <xref:System.Threading.EventWaitHandle>
- <xref:System.Threading.WaitHandle>
- <xref:System.Threading.AutoResetEvent>
- <xref:System.Threading.ManualResetEvent>
