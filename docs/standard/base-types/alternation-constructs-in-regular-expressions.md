---
title: Costrutti di alternanza nelle espressioni regolari .NET
description: Informazioni su come usare i costrutti di alternanza per la corrispondenza condizionale nelle espressioni regolari.
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- either/or matching
- alternative matching patterns
- regular expressions, alternation constructs
- alternation constructs
- optional matching patterns
- constructs, alternation
- .NET Framework regular expressions, alternation constructs
ms.assetid: 071e22e9-fbb0-4ecf-add1-8d2424f9f2d1
ms.openlocfilehash: 02664bd2812f89649ec933483161263bae530a75
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 03/15/2020
ms.locfileid: "78159689"
---
# <a name="alternation-constructs-in-regular-expressions"></a><span data-ttu-id="388dc-103">Costrutti di alternanza nelle espressioni regolari</span><span class="sxs-lookup"><span data-stu-id="388dc-103">Alternation Constructs in Regular Expressions</span></span>

<span data-ttu-id="388dc-104">I costrutti di alternanza modificano un'espressione regolare per abilitare la corrispondenza di tipo either/or o condizionale.</span><span class="sxs-lookup"><span data-stu-id="388dc-104">Alternation constructs modify a regular expression to enable either/or or conditional matching.</span></span> <span data-ttu-id="388dc-105">.NET supporta tre costrutti di alternanza:</span><span class="sxs-lookup"><span data-stu-id="388dc-105">.NET supports three alternation constructs:</span></span>

- [<span data-ttu-id="388dc-106">Criteri di ricerca con &#124;</span><span class="sxs-lookup"><span data-stu-id="388dc-106">Pattern matching with &#124;</span></span>](#Either_Or)
- [<span data-ttu-id="388dc-107">Corrispondenza condizionale con (?(espressione)yes&#124;no)</span><span class="sxs-lookup"><span data-stu-id="388dc-107">Conditional matching with (?(expression)yes&#124;no)</span></span>](#Conditional_Expr)
- [<span data-ttu-id="388dc-108">Corrispondenza condizionale basata su un gruppo acquisito validoConditional matching based on a valid captured group</span><span class="sxs-lookup"><span data-stu-id="388dc-108">Conditional matching based on a valid captured group</span></span>](#Conditional_Group)

<a name="Either_Or"></a>
## <a name="pattern-matching-with-124"></a><span data-ttu-id="388dc-109">Criteri di ricerca con &#124;</span><span class="sxs-lookup"><span data-stu-id="388dc-109">Pattern Matching with &#124;</span></span>

<span data-ttu-id="388dc-110">È possibile usare la barra verticale (`|`) per trovare la corrispondenza con uno qualsiasi di una serie di criteri, dove i singoli criteri sono separati dal carattere `|`.</span><span class="sxs-lookup"><span data-stu-id="388dc-110">You can use the vertical bar (`|`) character to match any one of a series of patterns, where the `|` character separates each pattern.</span></span>

<span data-ttu-id="388dc-111">Analogamente alla classe di caratteri positivi, il carattere `|` può essere usato per trovare la corrispondenza con uno qualsiasi tra diversi caratteri singoli.</span><span class="sxs-lookup"><span data-stu-id="388dc-111">Like the positive character class, the `|` character can be used to match any one of a number of single characters.</span></span> <span data-ttu-id="388dc-112">L'esempio seguente usa sia una classe di caratteri positivi sia criteri di ricerca di tipo either/or con il carattere `|` per individuare le occorrenze delle parole "gray" o "grey" in una stringa.</span><span class="sxs-lookup"><span data-stu-id="388dc-112">The following example uses both a positive character class and either/or pattern matching with the `|` character to locate occurrences of the words "gray" or "grey" in a string.</span></span> <span data-ttu-id="388dc-113">In questo caso, `|` produce un'espressione regolare più dettagliata.</span><span class="sxs-lookup"><span data-stu-id="388dc-113">In this case, the `|` character produces a regular expression that is more verbose.</span></span>

[!code-csharp[RegularExpressions.Language.Alternation#1](~/samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.alternation/cs/alternation1.cs#1)]
[!code-vb[RegularExpressions.Language.Alternation#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.alternation/vb/alternation1.vb#1)]

<span data-ttu-id="388dc-114">L'espressione regolare `|` che `\bgr(a|e)y\b`utilizza il carattere , , viene interpretata come illustrato nella tabella seguente:</span><span class="sxs-lookup"><span data-stu-id="388dc-114">The regular expression that uses the `|` character, `\bgr(a|e)y\b`, is interpreted as shown in the following table:</span></span>

|<span data-ttu-id="388dc-115">Modello</span><span class="sxs-lookup"><span data-stu-id="388dc-115">Pattern</span></span>|<span data-ttu-id="388dc-116">Descrizione</span><span class="sxs-lookup"><span data-stu-id="388dc-116">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="388dc-117">Inizia dal confine di una parola.</span><span class="sxs-lookup"><span data-stu-id="388dc-117">Start at a word boundary.</span></span>|  
|`gr`|<span data-ttu-id="388dc-118">Corrisponde ai caratteri "gr".</span><span class="sxs-lookup"><span data-stu-id="388dc-118">Match the characters "gr".</span></span>|  
|<code>(a&#124;e)</code>|<span data-ttu-id="388dc-119">Corrisponde a una "a" o una "e".</span><span class="sxs-lookup"><span data-stu-id="388dc-119">Match either an "a" or an "e".</span></span>|  
|`y\b`|<span data-ttu-id="388dc-120">Corrisponde a una "y" in un confine di parola.</span><span class="sxs-lookup"><span data-stu-id="388dc-120">Match a "y" on a word boundary.</span></span>|  

<span data-ttu-id="388dc-121">Il carattere `|` può essere usato anche per trovare una corrispondenza di tipo either/or con più caratteri o sottoesspressioni, che possono includere qualsiasi combinazione di valori letterali carattere ed elementi del linguaggio di espressioni regolari.</span><span class="sxs-lookup"><span data-stu-id="388dc-121">The `|` character can also be used to perform an either/or match with multiple characters or subexpressions, which can include any combination of character literals and regular expression language elements.</span></span> <span data-ttu-id="388dc-122">La classe di caratteri non fornisce questa funzionalità. Nell'esempio seguente `|` viene utilizzato il carattere per estrarre un numero di previdenza sociale statunitense (SSN), ovvero un numero a 9 cifre con il formato *ddd*-*ddd*-*ddddd*, o un numero di identificazione del datore di lavoro (EIN, Employer Identification Number) degli Stati Uniti, ovvero un numero a 9 cifre con il formato dd*dddddddd* *dd*-.</span><span class="sxs-lookup"><span data-stu-id="388dc-122">(The character class does not provide this functionality.) The following example uses the `|` character to extract either a U.S. Social Security Number (SSN), which is a 9-digit number with the format *ddd*-*dd*-*dddd*, or a U.S. Employer Identification Number (EIN), which is a 9-digit number with the format *dd*-*ddddddd*.</span></span>

[!code-csharp[RegularExpressions.Language.Alternation#2](~/samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.alternation/cs/alternation2.cs#2)]
[!code-vb[RegularExpressions.Language.Alternation#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.alternation/vb/alternation2.vb#2)]  

<span data-ttu-id="388dc-123">L'espressione `\b(\d{2}-\d{7}|\d{3}-\d{2}-\d{4})\b` regolare viene interpretata come illustrato nella tabella seguente:The regular expression is interpreted as shown in the following table:</span><span class="sxs-lookup"><span data-stu-id="388dc-123">The regular expression `\b(\d{2}-\d{7}|\d{3}-\d{2}-\d{4})\b` is interpreted as shown in the following table:</span></span>
  
|<span data-ttu-id="388dc-124">Modello</span><span class="sxs-lookup"><span data-stu-id="388dc-124">Pattern</span></span>|<span data-ttu-id="388dc-125">Descrizione</span><span class="sxs-lookup"><span data-stu-id="388dc-125">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="388dc-126">Inizia dal confine di una parola.</span><span class="sxs-lookup"><span data-stu-id="388dc-126">Start at a word boundary.</span></span>|  
|<code>(\d{2}-\d{7}&#124;\d{3}-\d{2}-\d{4})</code>|<span data-ttu-id="388dc-127">Corrisponde a una delle due opzioni seguenti: due cifre decimali seguite da un trattino seguito da sette cifre decimali oppure tre cifre decimali, un trattino, due cifre decimali, un altro trattino e quattro cifre decimali.</span><span class="sxs-lookup"><span data-stu-id="388dc-127">Match either of the following: two decimal digits followed by a hyphen followed by seven decimal digits; or three decimal digits, a hyphen, two decimal digits, another hyphen, and four decimal digits.</span></span>|  
|`\d`|<span data-ttu-id="388dc-128">Termina la corrispondenza sul confine di parola.</span><span class="sxs-lookup"><span data-stu-id="388dc-128">End the match at a word boundary.</span></span>|  
  
<a name="Conditional_Expr"></a>
## <a name="conditional-matching-with-an-expression"></a><span data-ttu-id="388dc-129">Corrispondenza condizionale con un'espressione</span><span class="sxs-lookup"><span data-stu-id="388dc-129">Conditional matching with an expression</span></span>

<span data-ttu-id="388dc-130">Questo elemento del linguaggio tenta di trovare una corrispondenza con uno di due criteri, a seconda della possibilità di trovare una corrispondenza con un criterio iniziale.</span><span class="sxs-lookup"><span data-stu-id="388dc-130">This language element attempts to match one of two patterns depending on whether it can match an initial pattern.</span></span> <span data-ttu-id="388dc-131">La relativa sintassi è la seguente:</span><span class="sxs-lookup"><span data-stu-id="388dc-131">Its syntax is:</span></span>  

<span data-ttu-id="388dc-132">`(?(` *expression* `)` *yes* `|` *no* `)`</span><span class="sxs-lookup"><span data-stu-id="388dc-132">`(?(` *expression* `)` *yes* `|` *no* `)`</span></span>

<span data-ttu-id="388dc-133">dove *espressione* è il criterio iniziale per la corrispondenza, *sì* è il criterio di corrispondenza se viene trovata una corrispondenza per *espressione* e *no* è il criterio facoltativo di corrispondenza se non viene trovata una corrispondenza per *espressione* .</span><span class="sxs-lookup"><span data-stu-id="388dc-133">where *expression* is the initial pattern to match, *yes* is the pattern to match if *expression* is matched, and *no* is the optional pattern to match if *expression* is not matched.</span></span> <span data-ttu-id="388dc-134">Il motore delle espressioni regolari considera *espressione* come un'asserzione di larghezza zero, ovvero questo motore non avanza nel flusso di input dopo aver valutato *espressione*.</span><span class="sxs-lookup"><span data-stu-id="388dc-134">The regular expression engine treats *expression* as a zero-width assertion; that is, the regular expression engine does not advance in the input stream after it evaluates *expression*.</span></span> <span data-ttu-id="388dc-135">Questo costrutto è pertanto equivalente a quanto segue:</span><span class="sxs-lookup"><span data-stu-id="388dc-135">Therefore, this construct is equivalent to the following:</span></span>

<span data-ttu-id="388dc-136">`(?(?=` *expression* `)` *yes* `|` *no* `)`</span><span class="sxs-lookup"><span data-stu-id="388dc-136">`(?(?=` *expression* `)` *yes* `|` *no* `)`</span></span>

<span data-ttu-id="388dc-137">dove `(?=` *expression* `)` è un costrutto di asserzione di larghezza zero.</span><span class="sxs-lookup"><span data-stu-id="388dc-137">where `(?=`*expression*`)` is a zero-width assertion construct.</span></span> <span data-ttu-id="388dc-138">Per altre informazioni, vedere Costrutti di [raggruppamento.](grouping-constructs-in-regular-expressions.md) Poiché il motore delle espressioni regolari interpreta *l'espressione* come un ancoraggio (asserzione di larghezza zero), *expression* deve essere un'asserzione di larghezza zero (per ulteriori informazioni, vedere [Anchors](anchors-in-regular-expressions.md)) o una sottoespressione anch'esso contenuto in *yes*.</span><span class="sxs-lookup"><span data-stu-id="388dc-138">(For more information, see [Grouping Constructs](grouping-constructs-in-regular-expressions.md).) Because the regular expression engine interprets *expression* as an anchor (a zero-width assertion), *expression* must either be a zero-width assertion (for more information, see [Anchors](anchors-in-regular-expressions.md)) or a subexpression that is also contained in *yes*.</span></span> <span data-ttu-id="388dc-139">In caso contrario, non è possibile trovare una corrispondenza per il criterio *sì* .</span><span class="sxs-lookup"><span data-stu-id="388dc-139">Otherwise, the *yes* pattern cannot be matched.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="388dc-140">Se *expression* è un gruppo di acquisizione denominato o numerato, il costrutto di alternanza viene interpretato come test di acquisizione. Per ulteriori informazioni, vedere la sezione successiva, [Corrispondenza condizionale basata su un gruppo di acquisizione valido](#Conditional_Group).</span><span class="sxs-lookup"><span data-stu-id="388dc-140">If *expression* is a named or numbered capturing group, the alternation construct is interpreted as a capture test; for more information, see the next section, [Conditional Matching Based on a Valid Capture Group](#Conditional_Group).</span></span> <span data-ttu-id="388dc-141">In altre parole, il motore delle espressioni regolari non tenta di trovare la corrispondenza con la sottostringa acquisita, ma verifica invece la presenza o l'assenza del gruppo.</span><span class="sxs-lookup"><span data-stu-id="388dc-141">In other words, the regular expression engine does not attempt to match the captured substring, but instead tests for the presence or absence of the group.</span></span>  
  
<span data-ttu-id="388dc-142">L'esempio seguente è una variante dell'esempio visualizzato nella sezione relativa ai [criteri di ricerca either/or con &#124;](#Either_Or).</span><span class="sxs-lookup"><span data-stu-id="388dc-142">The following example is a variation of the example that appears in the [Either/Or Pattern Matching with &#124;](#Either_Or) section.</span></span> <span data-ttu-id="388dc-143">L'esempio usa la corrispondenza condizionale per determinare se i primi tre caratteri dopo un confine di parola sono due cifre seguite da un trattino.</span><span class="sxs-lookup"><span data-stu-id="388dc-143">It uses conditional matching to determine whether the first three characters after a word boundary are two digits followed by a hyphen.</span></span> <span data-ttu-id="388dc-144">In caso affermativo, viene effettuato un tentativo di trovare una corrispondenza con un identificativo del datore di lavoro (EIN) degli Stati Uniti.</span><span class="sxs-lookup"><span data-stu-id="388dc-144">If they are, it attempts to match a U.S. Employer Identification Number (EIN).</span></span> <span data-ttu-id="388dc-145">In caso contrario, viene effettuato un tentativo di trovare una corrispondenza con un numero di previdenza sociale (SSN) degli Stati Uniti.</span><span class="sxs-lookup"><span data-stu-id="388dc-145">If not, it attempts to match a U.S. Social Security Number (SSN).</span></span>

[!code-csharp[RegularExpressions.Language.Alternation#3](~/samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.alternation/cs/alternation3.cs#3)]
[!code-vb[RegularExpressions.Language.Alternation#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.alternation/vb/alternation3.vb#3)]

<span data-ttu-id="388dc-146">Il modello `\b(?(\d{2}-)\d{2}-\d{7}|\d{3}-\d{2}-\d{4})\b` di espressione regolare viene interpretato come illustrato nella tabella seguente:The regular expression pattern is interpreted as shown in the following table:</span><span class="sxs-lookup"><span data-stu-id="388dc-146">The regular expression pattern `\b(?(\d{2}-)\d{2}-\d{7}|\d{3}-\d{2}-\d{4})\b` is interpreted as shown in the following table:</span></span>

|<span data-ttu-id="388dc-147">Modello</span><span class="sxs-lookup"><span data-stu-id="388dc-147">Pattern</span></span>|<span data-ttu-id="388dc-148">Descrizione</span><span class="sxs-lookup"><span data-stu-id="388dc-148">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="388dc-149">Inizia dal confine di una parola.</span><span class="sxs-lookup"><span data-stu-id="388dc-149">Start at a word boundary.</span></span>|  
|`(?(\d{2}-)`|<span data-ttu-id="388dc-150">Determina se i tre caratteri successivi sono costituiti da due cifre seguite da un trattino.</span><span class="sxs-lookup"><span data-stu-id="388dc-150">Determine whether the next three characters consist of two digits followed by a hyphen.</span></span>|  
|`\d{2}-\d{7}`|<span data-ttu-id="388dc-151">Se il criterio precedente viene soddisfatto, trova la corrispondenza con due cifre seguite da un trattino seguito da sette cifre.</span><span class="sxs-lookup"><span data-stu-id="388dc-151">If the previous pattern matches, match two digits followed by a hyphen followed by seven digits.</span></span>|  
|`\d{3}-\d{2}-\d{4}`|<span data-ttu-id="388dc-152">Se il criterio precedente non viene soddisfatto, trova la corrispondenza con tre cifre decimali, un trattino, due cifre decimali, un altro trattino e quattro cifre decimali.</span><span class="sxs-lookup"><span data-stu-id="388dc-152">If the previous pattern does not match, match three decimal digits, a hyphen, two decimal digits, another hyphen, and four decimal digits.</span></span>|  
|`\b`|<span data-ttu-id="388dc-153">Trova la corrispondenza di un confine di parola.</span><span class="sxs-lookup"><span data-stu-id="388dc-153">Match a word boundary.</span></span>|  

<a name="Conditional_Group"></a>
## <a name="conditional-matching-based-on-a-valid-captured-group"></a><span data-ttu-id="388dc-154">Corrispondenza condizionale in base a un gruppo acquisito valido</span><span class="sxs-lookup"><span data-stu-id="388dc-154">Conditional matching based on a valid captured group</span></span>

<span data-ttu-id="388dc-155">Tramite questo elemento di linguaggio viene effettuato un tentativo di corrispondenza con uno dei due modelli, a seconda dell'effettiva corrispondenza con un gruppo di acquisizione specificato.</span><span class="sxs-lookup"><span data-stu-id="388dc-155">This language element attempts to match one of two patterns depending on whether it has matched a specified capturing group.</span></span> <span data-ttu-id="388dc-156">La relativa sintassi è la seguente:</span><span class="sxs-lookup"><span data-stu-id="388dc-156">Its syntax is:</span></span>

<span data-ttu-id="388dc-157">`(?(` *name* `)` *yes* `|` *no* `)`</span><span class="sxs-lookup"><span data-stu-id="388dc-157">`(?(` *name* `)` *yes* `|` *no* `)`</span></span>

<span data-ttu-id="388dc-158">o</span><span class="sxs-lookup"><span data-stu-id="388dc-158">or</span></span>

<span data-ttu-id="388dc-159">`(?(` *numero* `)` *sì* `|` *no* `)`</span><span class="sxs-lookup"><span data-stu-id="388dc-159">`(?(` *number* `)` *yes* `|` *no* `)`</span></span>

<span data-ttu-id="388dc-160">dove *nome* è il nome e *numero* è il numero di un gruppo di acquisizione, *sì* è l'espressione di cui trovare la corrispondenza se per *nome* o *numero* è disponibile una corrispondenza e *no* è l'espressione facoltativa di cui trovare la corrispondenza in caso contrario.</span><span class="sxs-lookup"><span data-stu-id="388dc-160">where *name* is the name and *number* is the number of a capturing group, *yes* is the expression to match if *name* or *number* has a match, and *no* is the optional expression to match if it does not.</span></span>

<span data-ttu-id="388dc-161">Se *nome* non corrisponde al nome di un gruppo di acquisizione usato nel criterio di espressione regolare, il costrutto di alternanza viene interpretato come un test di espressione, come illustrato nella sezione precedente.</span><span class="sxs-lookup"><span data-stu-id="388dc-161">If *name* does not correspond to the name of a capturing group that is used in the regular expression pattern, the alternation construct is interpreted as an expression test, as explained in the previous section.</span></span> <span data-ttu-id="388dc-162">In genere, ciò significa che *espressione* restituisce `false`.</span><span class="sxs-lookup"><span data-stu-id="388dc-162">Typically, this means that *expression* evaluates to `false`.</span></span> <span data-ttu-id="388dc-163">Se *numero* non corrisponde a un gruppo di acquisizione numerato usato nel criterio di espressione regolare, il motore delle espressioni regolari genera un'eccezione <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="388dc-163">If *number* does not correspond to a numbered capturing group that is used in the regular expression pattern, the regular expression engine throws an <xref:System.ArgumentException>.</span></span>

<span data-ttu-id="388dc-164">L'esempio seguente è una variante dell'esempio visualizzato nella sezione relativa ai [criteri di ricerca either/or con &#124;](#Either_Or).</span><span class="sxs-lookup"><span data-stu-id="388dc-164">The following example is a variation of the example that appears in the [Either/Or Pattern Matching with &#124;](#Either_Or) section.</span></span> <span data-ttu-id="388dc-165">L'esempio usa un gruppo di acquisizione denominato `n2` costituito da due cifre seguite da un trattino.</span><span class="sxs-lookup"><span data-stu-id="388dc-165">It uses a capturing group named `n2` that consists of two digits followed by a hyphen.</span></span> <span data-ttu-id="388dc-166">Il costrutto di alternanza verifica se per questo gruppo di acquisizione è presente una corrispondenza nella stringa di input.</span><span class="sxs-lookup"><span data-stu-id="388dc-166">The alternation construct tests whether this capturing group has been matched in the input string.</span></span> <span data-ttu-id="388dc-167">In caso affermativo, il costrutto di alternanza tenta di trovare la corrispondenza con le ultime sette cifre delle nove cifre di un identificativo del datore di lavoro (EIN) degli Stati Uniti.</span><span class="sxs-lookup"><span data-stu-id="388dc-167">If it has, the alternation construct attempts to match the last seven digits of a nine-digit U.S. Employer Identification Number (EIN).</span></span> <span data-ttu-id="388dc-168">In caso contrario, tenta di trovare la corrispondenza con le nove cifre di un numero di previdenza sociale (SSN) degli Stati Uniti.</span><span class="sxs-lookup"><span data-stu-id="388dc-168">If it has not, it attempts to match a nine-digit U.S. Social Security Number (SSN).</span></span>

[!code-csharp[RegularExpressions.Language.Alternation#4](~/samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.alternation/cs/alternation4.cs#4)]
[!code-vb[RegularExpressions.Language.Alternation#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.alternation/vb/alternation4.vb#4)]

<span data-ttu-id="388dc-169">Il modello `\b(?<n2>\d{2}-)?(?(n2)\d{7}|\d{3}-\d{2}-\d{4})\b` di espressione regolare viene interpretato come illustrato nella tabella seguente:The regular expression pattern is interpreted as shown in the following table:</span><span class="sxs-lookup"><span data-stu-id="388dc-169">The regular expression pattern `\b(?<n2>\d{2}-)?(?(n2)\d{7}|\d{3}-\d{2}-\d{4})\b` is interpreted as shown in the following table:</span></span>

|<span data-ttu-id="388dc-170">Modello</span><span class="sxs-lookup"><span data-stu-id="388dc-170">Pattern</span></span>|<span data-ttu-id="388dc-171">Descrizione</span><span class="sxs-lookup"><span data-stu-id="388dc-171">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="388dc-172">Inizia dal confine di una parola.</span><span class="sxs-lookup"><span data-stu-id="388dc-172">Start at a word boundary.</span></span>|  
|`(?<n2>\d{2}-)?`|<span data-ttu-id="388dc-173">Corrisponde a zero o una occorrenza di due cifre seguite da un trattino.</span><span class="sxs-lookup"><span data-stu-id="388dc-173">Match zero or one occurrence of two digits followed by a hyphen.</span></span> <span data-ttu-id="388dc-174">Il nome di questo gruppo di acquisizione è `n2`.</span><span class="sxs-lookup"><span data-stu-id="388dc-174">Name this capturing group `n2`.</span></span>|  
|`(?(n2)`|<span data-ttu-id="388dc-175">Verificare se per `n2` è stata individuata una corrispondenza nella stringa di input.</span><span class="sxs-lookup"><span data-stu-id="388dc-175">Test whether `n2` was matched in the input string.</span></span>|  
|`\d{7}`|<span data-ttu-id="388dc-176">Se per `n2` è stata individuata una corrispondenza, far corrispondere sette cifre decimali.</span><span class="sxs-lookup"><span data-stu-id="388dc-176">If `n2` was matched, match seven decimal digits.</span></span>|  
|<code>&#124;\d{3}-\d{2}-\d{4}</code>|<span data-ttu-id="388dc-177">Se per `n2` non è stata trovata alcuna corrispondenza, far corrispondere tre cifre decimali, un trattino, due cifre decimali, un altro trattino e quattro cifre decimali.</span><span class="sxs-lookup"><span data-stu-id="388dc-177">If `n2` was not matched, match three decimal digits, a hyphen, two decimal digits, another hyphen, and four decimal digits.</span></span>|  
|`\b`|<span data-ttu-id="388dc-178">Trova la corrispondenza di un confine di parola.</span><span class="sxs-lookup"><span data-stu-id="388dc-178">Match a word boundary.</span></span>|  

<span data-ttu-id="388dc-179">Nell'esempio seguente è illustrata una variante di questo esempio che usa un gruppo numerato anziché un gruppo denominato.</span><span class="sxs-lookup"><span data-stu-id="388dc-179">A variation of this example that uses a numbered group instead of a named group is shown in the following example.</span></span> <span data-ttu-id="388dc-180">Il criterio di espressione regolare è `\b(\d{2}-)?(?(1)\d{7}|\d{3}-\d{2}-\d{4})\b`.</span><span class="sxs-lookup"><span data-stu-id="388dc-180">Its regular expression pattern is `\b(\d{2}-)?(?(1)\d{7}|\d{3}-\d{2}-\d{4})\b`.</span></span>

[!code-csharp[RegularExpressions.Language.Alternation#5](~/samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.alternation/cs/alternation5.cs#5)]
[!code-vb[RegularExpressions.Language.Alternation#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.alternation/vb/alternation5.vb#5)]

## <a name="see-also"></a><span data-ttu-id="388dc-181">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="388dc-181">See also</span></span>

- [<span data-ttu-id="388dc-182">Linguaggio delle espressioni regolari - Guida di riferimento rapidoRegular Expression Language - Quick Reference</span><span class="sxs-lookup"><span data-stu-id="388dc-182">Regular Expression Language - Quick Reference</span></span>](regular-expression-language-quick-reference.md)
