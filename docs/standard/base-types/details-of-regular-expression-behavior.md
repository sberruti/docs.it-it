---
title: Comportamento delle espressioni regolari
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- regular expressions, behavior
- .NET Framework regular expressions, behavior
ms.assetid: 0ee1a6b8-caac-41d2-917f-d35570021b10
ms.openlocfilehash: 504e315dda4e76f56a88d97149b1515b6743668b
ms.sourcegitcommit: 011314e0c8eb4cf4a11d92078f58176c8c3efd2d
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 02/11/2020
ms.locfileid: "77124351"
---
# <a name="details-of-regular-expression-behavior"></a><span data-ttu-id="aeb81-102">Dettagli sul comportamento delle espressioni regolari</span><span class="sxs-lookup"><span data-stu-id="aeb81-102">Details of regular expression behavior</span></span>

<span data-ttu-id="aeb81-103">Il motore delle espressioni regolari di .NET Framework è un selettore di espressioni regolari di backtracking che incorpora un motore NFA (Nondeterministic Finite Automaton) tradizionale come quello usato da Perl, Python, Emacs e Tcl.</span><span class="sxs-lookup"><span data-stu-id="aeb81-103">The .NET Framework regular expression engine is a backtracking regular expression matcher that incorporates a traditional Nondeterministic Finite Automaton (NFA) engine such as that used by Perl, Python, Emacs, and Tcl.</span></span> <span data-ttu-id="aeb81-104">Ciò lo distingue dai motori delle espressioni regolari puri DFA (Deterministic Finite Automaton), più veloci ma più limitati, come quelli usati in awk, egrep o lex.</span><span class="sxs-lookup"><span data-stu-id="aeb81-104">This distinguishes it from faster, but more limited, pure regular expression Deterministic Finite Automaton (DFA) engines such as those found in awk, egrep, or lex.</span></span> <span data-ttu-id="aeb81-105">Lo distingue anche dai motori NFA POSIX, standardizzati ma più lenti.</span><span class="sxs-lookup"><span data-stu-id="aeb81-105">This also distinguishes it from standardized, but slower, POSIX NFAs.</span></span> <span data-ttu-id="aeb81-106">Nella sezione seguente vengono descritti i tre tipi di motori delle espressioni regolari e viene spiegato perché le espressioni regolari in .NET Framework vengono implementate usando un motore NFA tradizionale.</span><span class="sxs-lookup"><span data-stu-id="aeb81-106">The following section describes the three types of regular expression engines, and explains why regular expressions in the .NET Framework are implemented by using a traditional NFA engine.</span></span>

## <a name="benefits-of-the-nfa-engine"></a><span data-ttu-id="aeb81-107">Vantaggi del motore NFA</span><span class="sxs-lookup"><span data-stu-id="aeb81-107">Benefits of the NFA engine</span></span>

 <span data-ttu-id="aeb81-108">Quando i motori DFA eseguono criteri di ricerca, l'ordine di elaborazione è basato sulla stringa di input.</span><span class="sxs-lookup"><span data-stu-id="aeb81-108">When DFA engines perform pattern matching, their processing order is driven by the input string.</span></span> <span data-ttu-id="aeb81-109">Il motore inizia all'inizio della stringa di input e procede in sequenza per determinare se il carattere successivo corrisponde al criterio di espressione regolare.</span><span class="sxs-lookup"><span data-stu-id="aeb81-109">The engine begins at the beginning of the input string and proceeds sequentially to determine whether the next character matches the regular expression pattern.</span></span> <span data-ttu-id="aeb81-110">È in grado di garantire la corrispondenza con la stringa più lunga possibile.</span><span class="sxs-lookup"><span data-stu-id="aeb81-110">They can guarantee to match the longest string possible.</span></span> <span data-ttu-id="aeb81-111">Poiché non testano mai due volte lo stesso carattere, i motori DFA non supportano il backtracking.</span><span class="sxs-lookup"><span data-stu-id="aeb81-111">Because they never test the same character twice, DFA engines do not support backtracking.</span></span> <span data-ttu-id="aeb81-112">Tuttavia, poiché un motore DFA contiene solo stati finiti, non è in grado di trovare corrispondenze con i backreference e dato che non crea un'espansione esplicita, non è in grado di acquisire sottoespressioni.</span><span class="sxs-lookup"><span data-stu-id="aeb81-112">However, because a DFA engine contains only finite state, it cannot match a pattern with backreferences, and because it does not construct an explicit expansion, it cannot capture subexpressions.</span></span>

 <span data-ttu-id="aeb81-113">A differenza dei motori DFA, quando i motori NFA tradizionali eseguono criteri di ricerca, l'ordine di elaborazione dipende dal criterio di espressione regolare.</span><span class="sxs-lookup"><span data-stu-id="aeb81-113">Unlike DFA engines, when traditional NFA engines perform pattern matching, their processing order is driven by the regular expression pattern.</span></span> <span data-ttu-id="aeb81-114">Durante l'elaborazione di un elemento di linguaggio specifico, il motore usa la corrispondenza greedy, ossia trova la corrispondenza con la maggior parte possibile della stringa di input.</span><span class="sxs-lookup"><span data-stu-id="aeb81-114">As it processes a particular language element, the engine uses greedy matching; that is, it matches as much of the input string as it possibly can.</span></span> <span data-ttu-id="aeb81-115">Ma salva anche il proprio stato dopo aver trovato la corrispondenza con una sottoespressione.</span><span class="sxs-lookup"><span data-stu-id="aeb81-115">But it also saves its state after successfully matching a subexpression.</span></span> <span data-ttu-id="aeb81-116">Se la ricerca di una corrispondenza ha esito negativo, il motore torna allo stato salvato in modo da tentare altre corrispondenze.</span><span class="sxs-lookup"><span data-stu-id="aeb81-116">If a match eventually fails, the engine can return to a saved state so it can try additional matches.</span></span> <span data-ttu-id="aeb81-117">Questo processo di abbandono di una corrispondenza riuscita con una sottoespressione per poter consentire la corrispondenza di altri elementi del linguaggio nell'espressione regolare è noto come *backtracking*.</span><span class="sxs-lookup"><span data-stu-id="aeb81-117">This process of abandoning a successful subexpression match so that later language elements in the regular expression can also match is known as *backtracking*.</span></span> <span data-ttu-id="aeb81-118">I motori NFA usano il backtracking per testare tutte le possibili espansioni di un'espressione regolare in un ordine specifico e accettano la prima corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="aeb81-118">NFA engines use backtracking to test all possible expansions of a regular expression in a specific order and accept the first match.</span></span> <span data-ttu-id="aeb81-119">Poiché un motore NFA tradizionale crea un'espansione specifica dell'espressione regolare per trovare una corrispondenza, è in grado di acquisire corrispondenze di sottoespressioni e backreference corrispondenti.</span><span class="sxs-lookup"><span data-stu-id="aeb81-119">Because a traditional NFA engine constructs a specific expansion of the regular expression for a successful match, it can capture subexpression matches and matching backreferences.</span></span> <span data-ttu-id="aeb81-120">Tuttavia, dato che un motore NFA tradizionale usa il backtracking, è possibile che visiti lo stesso stato più volte se arriva allo stato attraverso percorsi diversi.</span><span class="sxs-lookup"><span data-stu-id="aeb81-120">However, because a traditional NFA backtracks, it can visit the same state multiple times if it arrives at the state over different paths.</span></span> <span data-ttu-id="aeb81-121">Di conseguenza, può diventare estremamente lento nel peggiore dei casi.</span><span class="sxs-lookup"><span data-stu-id="aeb81-121">As a result, it can run exponentially slowly in the worst case.</span></span> <span data-ttu-id="aeb81-122">Un motore NFA tradizionale accetta la prima corrispondenza trovata, quindi tralascia altre corrispondenze che potrebbero essere più lunghe.</span><span class="sxs-lookup"><span data-stu-id="aeb81-122">Because a traditional NFA engine accepts the first match it finds, it can also leave other (possibly longer) matches undiscovered.</span></span>

 <span data-ttu-id="aeb81-123">I motori NFA POSIX sono come i motori NFA tradizionali, ad eccezione del fatto che continuano a eseguire il backtracking fino a quando possono di aver trovato la corrispondenza più lunga possibile.</span><span class="sxs-lookup"><span data-stu-id="aeb81-123">POSIX NFA engines are like traditional NFA engines, except that they continue to backtrack until they can guarantee that they have found the longest match possible.</span></span> <span data-ttu-id="aeb81-124">Di conseguenza, un motore NFA POSIX è più lento rispetto a un motore NFA tradizionale e quando si usa un motore NFA POSIX, non è possibile preferire una corrispondenza più breve rispetto a una più lunga modificando l'ordine di ricerca di backtracking.</span><span class="sxs-lookup"><span data-stu-id="aeb81-124">As a result, a POSIX NFA engine is slower than a traditional NFA engine, and when you use a POSIX NFA engine, you cannot favor a shorter match over a longer one by changing the order of the backtracking search.</span></span>

 <span data-ttu-id="aeb81-125">I motori NFA tradizionali sono i preferiti dei programmatori perché offrono un maggiore controllo sulla corrispondenza delle stringhe rispetto ai motori DFA o NFA POSIX.</span><span class="sxs-lookup"><span data-stu-id="aeb81-125">Traditional NFA engines are favored by programmers because they offer greater control over string matching than either DFA or POSIX NFA engines.</span></span> <span data-ttu-id="aeb81-126">Benché nel peggiore dei casi possano essere lenti, è possibile impostarli in modo che trovino le corrispondenze in tempo lineare o polinomiale usando criteri che riducono le ambiguità e limitano il backtracking.</span><span class="sxs-lookup"><span data-stu-id="aeb81-126">Although, in the worst case, they can run slowly, you can steer them to find matches in linear or polynomial time by using patterns that reduce ambiguities and limit backtracking.</span></span> <span data-ttu-id="aeb81-127">In altre parole, sebbene i motori NFA offrano prestazioni di potenza e flessibilità, nella maggior parte dei casi offrono prestazioni ottimali se un'espressione regolare è ben scritta ed evita i casi in cui il backtracking peggiora le prestazioni in modo esponenziale.</span><span class="sxs-lookup"><span data-stu-id="aeb81-127">In other words, although NFA engines trade performance for power and flexibility, in most cases they offer good to acceptable performance if a regular expression is well written and avoids cases in which backtracking degrades performance exponentially.</span></span>

> [!NOTE]
> <span data-ttu-id="aeb81-128">Per informazioni sui problemi di prestazioni causati dall'uso eccessivo del backtracking e su come elaborare un'espressione regolare per risolverli, vedere [Backtracking](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="aeb81-128">For information about the performance penalty caused by excessive backtracking and ways to craft a regular expression to work around them, see [Backtracking](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span></span>

## <a name="net-framework-engine-capabilities"></a><span data-ttu-id="aeb81-129">Funzionalità del motore di .NET Framework</span><span class="sxs-lookup"><span data-stu-id="aeb81-129">.NET Framework engine capabilities</span></span>

 <span data-ttu-id="aeb81-130">Per usufruire dei vantaggi offerti da un motore NFA tradizionale, il motore delle espressioni regolari di .NET Framework include un set completo di costrutti per consentire ai programmatori di controllare il motore di backtracking.</span><span class="sxs-lookup"><span data-stu-id="aeb81-130">To take advantage of the benefits of a traditional NFA engine, the .NET Framework regular expression engine includes a complete set of constructs to enable programmers to steer the backtracking engine.</span></span> <span data-ttu-id="aeb81-131">Tali costrutti possono essere usati per trovare più rapidamente le corrispondenze o per favorire espansioni specifiche rispetto ad altre.</span><span class="sxs-lookup"><span data-stu-id="aeb81-131">These constructs can be used to find matches faster or to favor specific expansions over others.</span></span>

 <span data-ttu-id="aeb81-132">Altre funzionalità del motore delle espressioni regolari di .NET Framework sono:</span><span class="sxs-lookup"><span data-stu-id="aeb81-132">Other features of the .NET Framework regular expression engine include the following:</span></span>

- <span data-ttu-id="aeb81-133">Quantificatori lazy: `??`, `*?`, `+?`, `{`*n*`,`*m*`}?`.</span><span class="sxs-lookup"><span data-stu-id="aeb81-133">Lazy quantifiers: `??`, `*?`, `+?`, `{`*n*`,`*m*`}?`.</span></span> <span data-ttu-id="aeb81-134">Questi costrutti indicano al motore di backtracking di cercare prima il numero minimo di ripetizioni.</span><span class="sxs-lookup"><span data-stu-id="aeb81-134">These constructs tell the backtracking engine to search the minimum number of repetitions first.</span></span> <span data-ttu-id="aeb81-135">Al contrario, i normali quantificatori greedy tentano di trovare prima il numero massimo di ripetizioni.</span><span class="sxs-lookup"><span data-stu-id="aeb81-135">In contrast, ordinary greedy quantifiers try to match the maximum number of repetitions first.</span></span> <span data-ttu-id="aeb81-136">L'esempio che segue illustrata la differenza tra i due tipi.</span><span class="sxs-lookup"><span data-stu-id="aeb81-136">The following example illustrates the difference between the two.</span></span> <span data-ttu-id="aeb81-137">Un'espressione regolare trova la corrispondenza con una frase che termina con un numero e un gruppo di acquisizione deve estrarre tale numero.</span><span class="sxs-lookup"><span data-stu-id="aeb81-137">A regular expression matches a sentence that ends in a number, and a capturing group is intended to extract that number.</span></span> <span data-ttu-id="aeb81-138">L'espressione regolare `.+(\d+)\.` include il quantificatore greedy `.+`, che fa in modo che il motore delle espressioni regolari acquisisca solo l'ultima cifra del numero.</span><span class="sxs-lookup"><span data-stu-id="aeb81-138">The regular expression `.+(\d+)\.` includes the greedy quantifier `.+`, which causes the regular expression engine to capture only the last digit of the number.</span></span> <span data-ttu-id="aeb81-139">Al contrario, l'espressione regolare `.+?(\d+)\.` include il quantificatore lazy `.+?`, che fa in modo che il motore delle espressioni regolari acquisisca l'intero numero.</span><span class="sxs-lookup"><span data-stu-id="aeb81-139">In contrast, the regular expression `.+?(\d+)\.` includes the lazy quantifier `.+?`, which causes the regular expression engine to capture the entire number.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lazy1.cs#1)]
     [!code-vb[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lazy1.vb#1)]

     <span data-ttu-id="aeb81-140">Le versioni greedy e lazy di questa espressione regolare vengono definite come illustrato nella tabella seguente:</span><span class="sxs-lookup"><span data-stu-id="aeb81-140">The greedy and lazy versions of this regular expression are defined as shown in the following table:</span></span>

    |<span data-ttu-id="aeb81-141">Modello</span><span class="sxs-lookup"><span data-stu-id="aeb81-141">Pattern</span></span>|<span data-ttu-id="aeb81-142">Descrizione</span><span class="sxs-lookup"><span data-stu-id="aeb81-142">Description</span></span>|
    |-------------|-----------------|
    |<span data-ttu-id="aeb81-143">`.+` (quantificatore greedy)</span><span class="sxs-lookup"><span data-stu-id="aeb81-143">`.+` (greedy quantifier)</span></span>|<span data-ttu-id="aeb81-144">Trova almeno un'occorrenza di qualsiasi carattere.</span><span class="sxs-lookup"><span data-stu-id="aeb81-144">Match at least one occurrence of any character.</span></span> <span data-ttu-id="aeb81-145">In questo modo il motore delle espressioni regolari considera soddisfatta la corrispondenza con l'intera stringa ed esegue il backtracking, necessario per verificare le corrispondenze con il resto del criterio.</span><span class="sxs-lookup"><span data-stu-id="aeb81-145">This causes the regular expression engine to match the entire string, and then to backtrack as needed to match the remainder of the pattern.</span></span>|
    |<span data-ttu-id="aeb81-146">`.+?` (quantificatore lazy)</span><span class="sxs-lookup"><span data-stu-id="aeb81-146">`.+?` (lazy quantifier)</span></span>|<span data-ttu-id="aeb81-147">Trova almeno un'occorrenza di qualsiasi carattere, ma accetta la corrispondenza con il minor numero possibile di caratteri.</span><span class="sxs-lookup"><span data-stu-id="aeb81-147">Match at least one occurrence of any character, but match as few as possible.</span></span>|
    |`(\d+)`|<span data-ttu-id="aeb81-148">Trova la corrispondenza con almeno un carattere alfanumerico e la assegna al primo gruppo di acquisizione.</span><span class="sxs-lookup"><span data-stu-id="aeb81-148">Match at least one numeric character, and assign it to the first capturing group.</span></span>|
    |`\.`|<span data-ttu-id="aeb81-149">Trova la corrispondenza con un punto.</span><span class="sxs-lookup"><span data-stu-id="aeb81-149">Match a period.</span></span>|

     <span data-ttu-id="aeb81-150">Per altre informazioni sui quantificatori lazy, vedere [Quantificatori](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="aeb81-150">For more information about lazy quantifiers, see [Quantifiers](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span></span>

- <span data-ttu-id="aeb81-151">Lookahead positivo: `(?=`*subexpression*`)`.</span><span class="sxs-lookup"><span data-stu-id="aeb81-151">Positive lookahead: `(?=`*subexpression*`)`.</span></span> <span data-ttu-id="aeb81-152">Questa funzionalità consente al motore di backtracking tornare alla stessa posizione nel testo dopo aver trovato la corrispondenza con una sottoespressione.</span><span class="sxs-lookup"><span data-stu-id="aeb81-152">This feature allows the backtracking engine to return to the same spot in the text after matching a subexpression.</span></span> <span data-ttu-id="aeb81-153">È utile per eseguire una ricerca in tutto il testo verificando più criteri a partire dalla stessa posizione.</span><span class="sxs-lookup"><span data-stu-id="aeb81-153">It is useful for searching throughout the text by verifying multiple patterns that start from the same position.</span></span> <span data-ttu-id="aeb81-154">Ciò consente anche al motore di verificare che una sottostringa esista alla fine della corrispondenza senza includere la sottostringa nel testo di cui è stata trovata la corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="aeb81-154">It also allows the engine to verify that a substring exists at the end of the match without including the substring in the matched text.</span></span> <span data-ttu-id="aeb81-155">Nell'esempio seguente il lookahead positivo viene usato per estrarre le parole di una frase che non sono seguite da simboli di punteggiatura.</span><span class="sxs-lookup"><span data-stu-id="aeb81-155">The following example uses positive lookahead to extract the words in a sentence that are not followed by punctuation symbols.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead1.cs#2)]
     [!code-vb[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead1.vb#2)]

     <span data-ttu-id="aeb81-156">L'espressione regolare `\b[A-Z]+\b(?=\P{P})` viene definita come illustrato nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="aeb81-156">The regular expression `\b[A-Z]+\b(?=\P{P})` is defined as shown in the following table.</span></span>

    |<span data-ttu-id="aeb81-157">Modello</span><span class="sxs-lookup"><span data-stu-id="aeb81-157">Pattern</span></span>|<span data-ttu-id="aeb81-158">Descrizione</span><span class="sxs-lookup"><span data-stu-id="aeb81-158">Description</span></span>|
    |-------------|-----------------|
    |`\b`|<span data-ttu-id="aeb81-159">Inizia la corrispondenza sul confine di parola.</span><span class="sxs-lookup"><span data-stu-id="aeb81-159">Begin the match at a word boundary.</span></span>|
    |`[A-Z]+`|<span data-ttu-id="aeb81-160">Trova la corrispondenza con qualsiasi carattere alfabetico una o più volte.</span><span class="sxs-lookup"><span data-stu-id="aeb81-160">Match any alphabetic character one or more times.</span></span> <span data-ttu-id="aeb81-161">Poiché il metodo <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> viene chiamato con l'opzione <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType>, il confronto non rileva la distinzione tra maiuscole e minuscole.</span><span class="sxs-lookup"><span data-stu-id="aeb81-161">Because the <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option, the comparison is case-insensitive.</span></span>|
    |`\b`|<span data-ttu-id="aeb81-162">Termina la corrispondenza sul confine di parola.</span><span class="sxs-lookup"><span data-stu-id="aeb81-162">End the match at a word boundary.</span></span>|
    |`(?=\P{P})`|<span data-ttu-id="aeb81-163">Esegue il lookahead per determinare se il carattere successivo è un simbolo di punteggiatura.</span><span class="sxs-lookup"><span data-stu-id="aeb81-163">Look ahead to determine whether the next character is a punctuation symbol.</span></span> <span data-ttu-id="aeb81-164">In caso contrario, la corrispondenza ha esito positivo.</span><span class="sxs-lookup"><span data-stu-id="aeb81-164">If it is not, the match succeeds.</span></span>|

     <span data-ttu-id="aeb81-165">Per altre informazioni sulle asserzioni per il lookahead positivo, vedere [Costrutti di raggruppamento](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="aeb81-165">For more information about positive lookahead assertions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="aeb81-166">Lookahead negativo: `(?!`*subexpression*`)`.</span><span class="sxs-lookup"><span data-stu-id="aeb81-166">Negative lookahead: `(?!`*subexpression*`)`.</span></span> <span data-ttu-id="aeb81-167">Questa funzionalità aggiunge la capacità di considerare soddisfatta la corrispondenza con un'espressione solo se non trova la corrispondenza con una sottoespressione.</span><span class="sxs-lookup"><span data-stu-id="aeb81-167">This feature adds the ability to match an expression only if a subexpression fails to match.</span></span> <span data-ttu-id="aeb81-168">Ciò risulta particolarmente utile per abbreviare una ricerca, poiché spesso è più semplice formulare un'espressione per un caso da eliminare che un'espressione che individua i casi da includere.</span><span class="sxs-lookup"><span data-stu-id="aeb81-168">This is particularly powerful for pruning a search, because it is often simpler to provide an expression for a case that should be eliminated than an expression for cases that must be included.</span></span> <span data-ttu-id="aeb81-169">Ad esempio, è difficile scrivere un'espressione per le parole che non iniziano con "non".</span><span class="sxs-lookup"><span data-stu-id="aeb81-169">For example, it is difficult to write an expression for words that do not begin with "non".</span></span> <span data-ttu-id="aeb81-170">Nell'esempio seguente viene usato il lookahead negativo per escluderle.</span><span class="sxs-lookup"><span data-stu-id="aeb81-170">The following example uses negative lookahead to exclude them.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead2.cs#3)]
     [!code-vb[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead2.vb#3)]

     <span data-ttu-id="aeb81-171">Il criterio di espressione regolare `\b(?!non)\w+\b` è definito nel modo illustrato nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="aeb81-171">The regular expression pattern `\b(?!non)\w+\b` is defined as shown in the following table.</span></span>

    |<span data-ttu-id="aeb81-172">Modello</span><span class="sxs-lookup"><span data-stu-id="aeb81-172">Pattern</span></span>|<span data-ttu-id="aeb81-173">Descrizione</span><span class="sxs-lookup"><span data-stu-id="aeb81-173">Description</span></span>|
    |-------------|-----------------|
    |`\b`|<span data-ttu-id="aeb81-174">Inizia la corrispondenza sul confine di parola.</span><span class="sxs-lookup"><span data-stu-id="aeb81-174">Begin the match at a word boundary.</span></span>|
    |`(?!non)`|<span data-ttu-id="aeb81-175">Esegue il lookahead per verificare che la stringa corrente non inizi con "non".</span><span class="sxs-lookup"><span data-stu-id="aeb81-175">Look ahead to ensure that the current string does not begin with "non".</span></span> <span data-ttu-id="aeb81-176">In caso contrario, la corrispondenza ha esito negativo.</span><span class="sxs-lookup"><span data-stu-id="aeb81-176">If it does, the match fails.</span></span>|
    |`(\w+)`|<span data-ttu-id="aeb81-177">Trova la corrispondenza di uno o più caratteri alfanumerici.</span><span class="sxs-lookup"><span data-stu-id="aeb81-177">Match one or more word characters.</span></span>|
    |`\b`|<span data-ttu-id="aeb81-178">Termina la corrispondenza sul confine di parola.</span><span class="sxs-lookup"><span data-stu-id="aeb81-178">End the match at a word boundary.</span></span>|

     <span data-ttu-id="aeb81-179">Per altre informazioni sulle asserzioni per il lookahead negativo, vedere [Costrutti di raggruppamento](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="aeb81-179">For more information about negative lookahead assertions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="aeb81-180">Valutazione condizionale: `(?(`*expression*`)`*yes*`|`*no*`)` e `(?(`*name*`)`*yes*`|`*no*`)`, dove *expression* è una sottoespressione di cui trovare la corrispondenza, *name* è il nome di un gruppo di acquisizione, *yes* è la stringa di cui trovare la corrispondenza se viene soddisfatta la corrispondenza con *expression* o *name* è un gruppo valido, non vuoto e acquisito e *no* è la sottoespressione di cui trovare la corrispondenza se la corrispondenza se *expression* non è soddisfatta o *name* non è un gruppo valido, non vuoto e acquisito.</span><span class="sxs-lookup"><span data-stu-id="aeb81-180">Conditional evaluation: `(?(`*expression*`)`*yes*`|`*no*`)` and `(?(`*name*`)`*yes*`|`*no*`)`, where *expression* is a subexpression to match, *name* is the name of a capturing group, *yes* is the string to match if *expression* is matched or *name* is a valid, non-empty captured group, and *no* is the subexpression to match if *expression* is not matched or *name* is not a valid, non-empty captured group.</span></span> <span data-ttu-id="aeb81-181">Questa funzionalità consente al motore di eseguire la ricerca usando più di un criterio alternativo, in base al risultato della corrispondenza di una sottoespressione precedente o al risultato di un'asserzione di larghezza zero.</span><span class="sxs-lookup"><span data-stu-id="aeb81-181">This feature allows the engine to search by using more than one alternate pattern, depending on the result of a previous subexpression match or the result of a zero-width assertion.</span></span> <span data-ttu-id="aeb81-182">Ciò offre una forma più efficace di backreference che consente, ad esempio, di trovare la corrispondenza con una sottoespressione in base al fatto che sia stata trovata o meno la corrispondenza con una sottoespressione precedente.</span><span class="sxs-lookup"><span data-stu-id="aeb81-182">This allows a more powerful form of backreference that permits, for example, matching a subexpression based on whether a previous subexpression was matched.</span></span> <span data-ttu-id="aeb81-183">L'espressione regolare nell'esempio seguente trova la corrispondenza con paragrafi destinati all'uso sia pubblico che interno.</span><span class="sxs-lookup"><span data-stu-id="aeb81-183">The regular expression in the following example matches paragraphs that are intended for both public and internal use.</span></span> <span data-ttu-id="aeb81-184">I paragrafi destinati solo all'uso interno iniziano con un tag `<PRIVATE>`.</span><span class="sxs-lookup"><span data-stu-id="aeb81-184">Paragraphs intended only for internal use begin with a `<PRIVATE>` tag.</span></span> <span data-ttu-id="aeb81-185">Il criterio di espressione regolare `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$` usa la valutazione condizionale per assegnare il contenuto dei paragrafi destinati all'uso pubblico e all'uso interno a gruppi di acquisizione separati.</span><span class="sxs-lookup"><span data-stu-id="aeb81-185">The regular expression pattern `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$` uses conditional evaluation to assign the contents of paragraphs intended for public and for internal use to separate capturing groups.</span></span> <span data-ttu-id="aeb81-186">I paragrafi possono quindi essere gestiti in modo diverso.</span><span class="sxs-lookup"><span data-stu-id="aeb81-186">These paragraphs can then be handled differently.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/conditional1.cs#4)]
     [!code-vb[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/conditional1.vb#4)]

     <span data-ttu-id="aeb81-187">Il criterio di ricerca di espressioni regolari è definito nel modo illustrato nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="aeb81-187">The regular expression pattern is defined as shown in the following table.</span></span>

    |<span data-ttu-id="aeb81-188">Modello</span><span class="sxs-lookup"><span data-stu-id="aeb81-188">Pattern</span></span>|<span data-ttu-id="aeb81-189">Descrizione</span><span class="sxs-lookup"><span data-stu-id="aeb81-189">Description</span></span>|
    |-------------|-----------------|
    |`^`|<span data-ttu-id="aeb81-190">Inizia la corrispondenza all'inizio di una riga.</span><span class="sxs-lookup"><span data-stu-id="aeb81-190">Begin the match at the beginning of a line.</span></span>|
    |`(?<Pvt>\<PRIVATE\>\s)?`|<span data-ttu-id="aeb81-191">Trova la corrispondenza con zero o un'occorrenza della stringa `<PRIVATE>` seguita da un carattere di spazio vuoto.</span><span class="sxs-lookup"><span data-stu-id="aeb81-191">Match zero or one occurrence of the string `<PRIVATE>` followed by a white-space character.</span></span> <span data-ttu-id="aeb81-192">Assegna la corrispondenza a un gruppo di acquisizione denominato `Pvt`.</span><span class="sxs-lookup"><span data-stu-id="aeb81-192">Assign the match to a capturing group named `Pvt`.</span></span>|
    |`(?(Pvt)((\w+\p{P}?\s)+)`|<span data-ttu-id="aeb81-193">Se il gruppo di acquisizione `Pvt` esiste, trova una o più occorrenze di uno o più caratteri alfanumerici seguiti da zero o un separatore di punteggiatura seguito da un carattere di spazio vuoto.</span><span class="sxs-lookup"><span data-stu-id="aeb81-193">If the `Pvt` capturing group exists, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="aeb81-194">Assegna la sottostringa al primo gruppo di acquisizione.</span><span class="sxs-lookup"><span data-stu-id="aeb81-194">Assign the substring to the first capturing group.</span></span>|
    |<code>&#124;((\w+\p{P}?\s)+))</code>|<span data-ttu-id="aeb81-195">Se il gruppo di acquisizione `Pvt` non esiste, trova una o più occorrenze di uno o più caratteri alfanumerici seguiti da zero o un separatore di punteggiatura seguito da un carattere di spazio vuoto.</span><span class="sxs-lookup"><span data-stu-id="aeb81-195">If the `Pvt` capturing group does not exist, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="aeb81-196">Assegna la sottostringa al terzo gruppo di acquisizione.</span><span class="sxs-lookup"><span data-stu-id="aeb81-196">Assign the substring to the third capturing group.</span></span>|
    |`\r?$`|<span data-ttu-id="aeb81-197">Trova la corrispondenza alla fine di una riga o alla fine della stringa.</span><span class="sxs-lookup"><span data-stu-id="aeb81-197">Match the end of a line or the end of the string.</span></span>|

     <span data-ttu-id="aeb81-198">Per altre informazioni sulla valutazione condizionale, vedere [Costrutti di alternanza](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="aeb81-198">For more information about conditional evaluation, see [Alternation Constructs](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="aeb81-199">Definizioni di gruppo di bilanciamento: `(?<`*name1*`-`*name2*`>` *sottoespressione*`)`.</span><span class="sxs-lookup"><span data-stu-id="aeb81-199">Balancing group definitions: `(?<`*name1*`-`*name2*`>` *subexpression*`)`.</span></span> <span data-ttu-id="aeb81-200">Questa funzionalità consente al motore delle espressioni regolari di tenere traccia dei costrutti annidati, ad esempio parentesi o parentesi quadre di apertura e chiusura.</span><span class="sxs-lookup"><span data-stu-id="aeb81-200">This feature allows the regular expression engine to keep track of nested constructs such as parentheses or opening and closing brackets.</span></span> <span data-ttu-id="aeb81-201">Per un esempio, vedere [Costrutti di raggruppamento](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="aeb81-201">For an example, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="aeb81-202">Gruppi atomici:`)``(?>`*sottoespressione* .</span><span class="sxs-lookup"><span data-stu-id="aeb81-202">Atomic groups: `(?>`*subexpression*`)`.</span></span> <span data-ttu-id="aeb81-203">Questa funzionalità consente al motore di backtracking di garantire che una sottoespressione corrisponda solo alla prima corrispondenza trovata per tale sottoespressione, come se l'espressione venisse eseguita indipendentemente dall'espressione che la contiene.</span><span class="sxs-lookup"><span data-stu-id="aeb81-203">This feature allows the backtracking engine to guarantee that a subexpression matches only the first match found for that subexpression, as if the expression were running independent of its containing expression.</span></span> <span data-ttu-id="aeb81-204">Se non si usa questo costrutto, il backtracking dall'espressione più ampia può modificare il comportamento di una sottoespressione.</span><span class="sxs-lookup"><span data-stu-id="aeb81-204">If you do not use this construct, backtracking searches from the larger expression can change the behavior of a subexpression.</span></span> <span data-ttu-id="aeb81-205">Ad esempio, l'espressione regolare `(a+)\w` trova la corrispondenza con uno o più caratteri "a", insieme a un carattere alfanumerico che segue la sequenza di caratteri "a" e assegna la sequenza di caratteri "a" al primo gruppo di acquisizione.</span><span class="sxs-lookup"><span data-stu-id="aeb81-205">For example, the regular expression `(a+)\w` matches one or more "a" characters, along with a word character that follows the sequence of "a" characters, and assigns the sequence of "a" characters to the first capturing group.</span></span> <span data-ttu-id="aeb81-206">Tuttavia, se il carattere finale della stringa di input è anche un "a", viene abbinato dall'elemento di linguaggio `\w` e non è incluso nel gruppo acquisito.</span><span class="sxs-lookup"><span data-stu-id="aeb81-206">However, if the final character of the input string is also an "a", it is matched by the `\w` language element and is not included in the captured group.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking2.cs#7)]
     [!code-vb[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking2.vb#7)]

     <span data-ttu-id="aeb81-207">L'espressione regolare `((?>a+))\w` evita questo comportamento.</span><span class="sxs-lookup"><span data-stu-id="aeb81-207">The regular expression `((?>a+))\w` prevents this behavior.</span></span> <span data-ttu-id="aeb81-208">Poiché la corrispondenza di tutti i caratteri "a" consecutivi viene determinata senza backtracking, il primo gruppo di acquisizione include tutti i caratteri "a" consecutivi.</span><span class="sxs-lookup"><span data-stu-id="aeb81-208">Because all consecutive "a" characters are matched without backtracking, the first capturing group includes all consecutive "a" characters.</span></span> <span data-ttu-id="aeb81-209">Se i caratteri "a" non sono seguiti da almeno un carattere diverso da "a", la corrispondenza ha esito negativo.</span><span class="sxs-lookup"><span data-stu-id="aeb81-209">If the "a" characters are not followed by at least one more character other than "a", the match fails.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking1.cs#8)]
     [!code-vb[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking1.vb#8)]

     <span data-ttu-id="aeb81-210">Per ulteriori informazioni sui gruppi atomici, vedere [costrutti di raggruppamento](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="aeb81-210">For more information about atomic groups, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="aeb81-211">Corrispondenza da destra a sinistra specificata passando l'opzione <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> a un costruttore della classe <xref:System.Text.RegularExpressions.Regex> o al metodo corrispondente dell'istanza statica.</span><span class="sxs-lookup"><span data-stu-id="aeb81-211">Right-to-left matching, which is specified by supplying the <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> option to a <xref:System.Text.RegularExpressions.Regex> class constructor or static instance matching method.</span></span> <span data-ttu-id="aeb81-212">Questa funzionalità è utile durante la ricerca da destra verso sinistra anziché da sinistra verso destra oppure nei casi in cui risulta più efficace iniziare una corrispondenza nella parte destra del criterio anziché in quella sinistra.</span><span class="sxs-lookup"><span data-stu-id="aeb81-212">This feature is useful when searching from right to left instead of from left to right, or in cases where it is more efficient to begin a match at the right part of the pattern instead of the left.</span></span> <span data-ttu-id="aeb81-213">Come illustrato nell'esempio seguente, l'uso della corrispondenza da destra a sinistra può modificare il comportamento dei quantificatori greedy.</span><span class="sxs-lookup"><span data-stu-id="aeb81-213">As the following example illustrates, using right-to-left matching can change the behavior of greedy quantifiers.</span></span> <span data-ttu-id="aeb81-214">Nell'esempio vengono condotte due ricerche di una frase che termina con un numero.</span><span class="sxs-lookup"><span data-stu-id="aeb81-214">The example conducts two searches for a sentence that ends in a number.</span></span> <span data-ttu-id="aeb81-215">La ricerca da sinistra a destra che usa il quantificatore greedy `+` trova la corrispondenza con una delle sei cifre nella frase, mentre la ricerca da destra a sinistra trova la corrispondenza con tutte le sei cifre.</span><span class="sxs-lookup"><span data-stu-id="aeb81-215">The left-to-right search that uses the greedy quantifier `+` matches one of the six digits in the sentence, whereas the right-to-left search matches all six digits.</span></span> <span data-ttu-id="aeb81-216">Per una descrizione del criterio di espressione regolare, vedere l'esempio che illustra i quantificatori lazy in precedenza in questa sezione.</span><span class="sxs-lookup"><span data-stu-id="aeb81-216">For a description of the regular expression pattern, see the example that illustrates lazy quantifiers earlier in this section.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/rtl1.cs#6)]
     [!code-vb[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/rtl1.vb#6)]

     <span data-ttu-id="aeb81-217">Per altre informazioni sulla corrispondenza da destra a sinistra, vedere [Opzioni di espressioni regolari](../../../docs/standard/base-types/regular-expression-options.md).</span><span class="sxs-lookup"><span data-stu-id="aeb81-217">For more information about right-to-left matching, see [Regular Expression Options](../../../docs/standard/base-types/regular-expression-options.md).</span></span>

- <span data-ttu-id="aeb81-218">Lookbehind positivo e negativo: `(?<=`*subexpression*`)` per lookbehind positivo e `(?<!`*subexpression*`)` per lookbehind negativo.</span><span class="sxs-lookup"><span data-stu-id="aeb81-218">Positive and negative lookbehind: `(?<=`*subexpression*`)` for positive lookbehind, and `(?<!`*subexpression*`)` for negative lookbehind.</span></span> <span data-ttu-id="aeb81-219">Questa funzionalità è simile a lookahead, illustrata in precedenza in questo argomento.</span><span class="sxs-lookup"><span data-stu-id="aeb81-219">This feature is similar to lookahead, which is discussed earlier in this topic.</span></span> <span data-ttu-id="aeb81-220">Poiché il motore delle espressioni regolari consente la corrispondenza da destra a sinistra completa, le espressioni regolari consentono lookbehind illimitati.</span><span class="sxs-lookup"><span data-stu-id="aeb81-220">Because the regular expression engine allows complete right-to-left matching, regular expressions allow unrestricted lookbehinds.</span></span> <span data-ttu-id="aeb81-221">Il lookbehind positivo e negativo consente inoltre di evitare l'annidamento di quantificatori quando la sottoespressione annidata è un superset di un'espressione esterna.</span><span class="sxs-lookup"><span data-stu-id="aeb81-221">Positive and negative lookbehind can also be used to avoid nesting quantifiers when the nested subexpression is a superset of an outer expression.</span></span> <span data-ttu-id="aeb81-222">Le espressioni regolari con tali quantificatori spesso influiscono negativamente sulle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="aeb81-222">Regular expressions with such nested quantifiers often offer poor performance.</span></span> <span data-ttu-id="aeb81-223">L'esempio seguente, ad esempio, verifica se una stringa inizia e termina con un carattere alfanumerico e se qualsiasi altro carattere nella stringa appartiene a un subset più ampio.</span><span class="sxs-lookup"><span data-stu-id="aeb81-223">For example, the following example verifies that a string begins and ends with an alphanumeric character, and that any other character in the string is one of a larger subset.</span></span> <span data-ttu-id="aeb81-224">Il criterio costituisce una parte dell'espressione regolare usata per convalidare gli indirizzi di posta elettronica. Per altre informazioni, vedere [Procedura: Verificare che le stringhe siano nel formato di posta elettronica valido](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md).</span><span class="sxs-lookup"><span data-stu-id="aeb81-224">It forms a portion of the regular expression used to validate email addresses; for more information, see [How to: Verify that Strings Are in Valid Email Format](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md).</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookbehind1.cs#5)]
     [!code-vb[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookbehind1.vb#5)]

     <span data-ttu-id="aeb81-225">L'espressione regolare ``^[A-Z0-9]([-!#$%&'.*+/=?^`{}|~\w])*(?<=[A-Z0-9])$`` viene definita come illustrato nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="aeb81-225">The regular expression ``^[A-Z0-9]([-!#$%&'.*+/=?^`{}|~\w])*(?<=[A-Z0-9])$`` is defined as shown in the following table.</span></span>

    |<span data-ttu-id="aeb81-226">Modello</span><span class="sxs-lookup"><span data-stu-id="aeb81-226">Pattern</span></span>|<span data-ttu-id="aeb81-227">Descrizione</span><span class="sxs-lookup"><span data-stu-id="aeb81-227">Description</span></span>|
    |-------------|-----------------|
    |`^`|<span data-ttu-id="aeb81-228">Inizia la ricerca della corrispondenza all'inizio della stringa.</span><span class="sxs-lookup"><span data-stu-id="aeb81-228">Begin the match at the beginning of the string.</span></span>|
    |`[A-Z0-9]`|<span data-ttu-id="aeb81-229">Trova la corrispondenza con qualsiasi carattere numerico o alfanumerico.</span><span class="sxs-lookup"><span data-stu-id="aeb81-229">Match any numeric or alphanumeric character.</span></span> <span data-ttu-id="aeb81-230">Il confronto non rileva la differenza tra maiuscole e minuscole.</span><span class="sxs-lookup"><span data-stu-id="aeb81-230">(The comparison is case-insensitive.)</span></span>|
    |<code>([-!#$%&'.*+/=?^\`{}&#124;~\w])\*</code>|<span data-ttu-id="aeb81-231">Trovare la corrispondenza con zero o più occorrenze di qualsiasi carattere alfanumerico o con uno dei caratteri seguenti:-,!, #, $,%, &,',., \*, +,/, =,?, &#96;^,, {, &#124;}, o ~.</span><span class="sxs-lookup"><span data-stu-id="aeb81-231">Match zero or more occurrences of any word character, or any of the following characters:  -, !, #, $, %, &, ', ., \*, +, /, =, ?, ^, &#96;, {, }, &#124;, or ~.</span></span>|
    |`(?<=[A-Z0-9])`|<span data-ttu-id="aeb81-232">Esegue il lookbehind al carattere precedente, che deve essere numerico o alfanumerico.</span><span class="sxs-lookup"><span data-stu-id="aeb81-232">Look behind to the previous character, which must be numeric or alphanumeric.</span></span> <span data-ttu-id="aeb81-233">Il confronto non rileva la differenza tra maiuscole e minuscole.</span><span class="sxs-lookup"><span data-stu-id="aeb81-233">(The comparison is case-insensitive.)</span></span>|
    |`$`|<span data-ttu-id="aeb81-234">Terminare la corrispondenza alla fine della stringa.</span><span class="sxs-lookup"><span data-stu-id="aeb81-234">End the match at the end of the string.</span></span>|

     <span data-ttu-id="aeb81-235">Per altre informazioni sul lookbehind positivo e negativo, vedere [Costrutti di raggruppamento](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="aeb81-235">For more information about positive and negative lookbehind, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

## <a name="related-articles"></a><span data-ttu-id="aeb81-236">Articoli correlati</span><span class="sxs-lookup"><span data-stu-id="aeb81-236">Related articles</span></span>

|<span data-ttu-id="aeb81-237">Titolo</span><span class="sxs-lookup"><span data-stu-id="aeb81-237">Title</span></span>|<span data-ttu-id="aeb81-238">Descrizione</span><span class="sxs-lookup"><span data-stu-id="aeb81-238">Description</span></span>|
|-----------|-----------------|
|[<span data-ttu-id="aeb81-239">Backtracking</span><span class="sxs-lookup"><span data-stu-id="aeb81-239">Backtracking</span></span>](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)|<span data-ttu-id="aeb81-240">Informazioni su come il backtracking delle espressioni regolari si dirama per trovare corrispondenze alternative.</span><span class="sxs-lookup"><span data-stu-id="aeb81-240">Provides information about how regular expression backtracking branches to find alternative matches.</span></span>|
|[<span data-ttu-id="aeb81-241">Compilazione e riutilizzo</span><span class="sxs-lookup"><span data-stu-id="aeb81-241">Compilation and Reuse</span></span>](../../../docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md)|<span data-ttu-id="aeb81-242">Informazioni sulla compilazione e sul riutilizzo di espressioni regolari per ottimizzare le prestazioni.</span><span class="sxs-lookup"><span data-stu-id="aeb81-242">Provides information about compiling and reusing regular expressions to increase performance.</span></span>|
|[<span data-ttu-id="aeb81-243">Thread safety</span><span class="sxs-lookup"><span data-stu-id="aeb81-243">Thread Safety</span></span>](../../../docs/standard/base-types/thread-safety-in-regular-expressions.md)|<span data-ttu-id="aeb81-244">Informazioni sulla modalità di thread safety delle espressioni regolari in cui viene spiegato quando è necessario sincronizzare l'accesso a oggetti di espressione regolare.</span><span class="sxs-lookup"><span data-stu-id="aeb81-244">Provides information about regular expression thread safety and explains when you should synchronize access to regular expression objects.</span></span>|
|[<span data-ttu-id="aeb81-245">Espressioni regolari di .NET Framework</span><span class="sxs-lookup"><span data-stu-id="aeb81-245">.NET Framework Regular Expressions</span></span>](../../../docs/standard/base-types/regular-expressions.md)|<span data-ttu-id="aeb81-246">Panoramica dell'aspetto del linguaggio di programmazione delle espressioni regolari.</span><span class="sxs-lookup"><span data-stu-id="aeb81-246">Provides an overview of the programming language aspect of regular expressions.</span></span>|
|[<span data-ttu-id="aeb81-247">Modello a oggetti delle espressioni regolari</span><span class="sxs-lookup"><span data-stu-id="aeb81-247">The Regular Expression Object Model</span></span>](../../../docs/standard/base-types/the-regular-expression-object-model.md)|<span data-ttu-id="aeb81-248">Esempi di codice e informazioni che illustrano l'uso delle classi di espressioni regolari.</span><span class="sxs-lookup"><span data-stu-id="aeb81-248">Provides information and code examples illustrating how to use the regular expression classes.</span></span>|
|[<span data-ttu-id="aeb81-249">Esempi di espressioni regolari</span><span class="sxs-lookup"><span data-stu-id="aeb81-249">Regular Expression Examples</span></span>](../../../docs/standard/base-types/regular-expression-examples.md)|<span data-ttu-id="aeb81-250">Esempi di codice che illustrano l'uso delle espressioni regolari nelle applicazioni comuni.</span><span class="sxs-lookup"><span data-stu-id="aeb81-250">Contains code examples that illustrate the use of regular expressions in common applications.</span></span>|
|[<span data-ttu-id="aeb81-251">Linguaggio di espressioni regolari - Riferimento rapido</span><span class="sxs-lookup"><span data-stu-id="aeb81-251">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)|<span data-ttu-id="aeb81-252">Informazioni su set di caratteri, operatori e costrutti che è possibile usare per definire le espressioni regolari.</span><span class="sxs-lookup"><span data-stu-id="aeb81-252">Provides information about the set of characters, operators, and constructs that you can use to define regular expressions.</span></span>|

## <a name="reference"></a><span data-ttu-id="aeb81-253">Riferimento</span><span class="sxs-lookup"><span data-stu-id="aeb81-253">Reference</span></span>

- <xref:System.Text.RegularExpressions?displayProperty=nameWithType>
