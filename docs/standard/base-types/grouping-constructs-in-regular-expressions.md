---
title: Costrutti di raggruppamento nelle espressioni regolari
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- lookbehinds
- regular expressions, grouping constructs
- lookaheads
- .NET Framework regular expressions, grouping constructs
- constructs, grouping
- grouping constructs
ms.assetid: 0fc18634-f590-4062-8d5c-f0b71abe405b
ms.openlocfilehash: 5b2ea110837d9d5b905f97ab706af52a594f1c43
ms.sourcegitcommit: 00aa62e2f469c2272a457b04e66b4cc3c97a800b
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 02/28/2020
ms.locfileid: "78159221"
---
# <a name="grouping-constructs-in-regular-expressions"></a><span data-ttu-id="ac2b2-102">Costrutti di raggruppamento nelle espressioni regolari</span><span class="sxs-lookup"><span data-stu-id="ac2b2-102">Grouping Constructs in Regular Expressions</span></span>
<span data-ttu-id="ac2b2-103">I costrutti di raggruppamento delineano sottoespressioni di un'espressione regolare e acquisiscono sottostringhe di una stringa di input.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-103">Grouping constructs delineate the subexpressions of a regular expression and capture the substrings of an input string.</span></span> <span data-ttu-id="ac2b2-104">È possibile usare i costrutti di raggruppamento per effettuare le operazioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="ac2b2-104">You can use grouping constructs to do the following:</span></span>  
  
- <span data-ttu-id="ac2b2-105">Trovare la corrispondenza di una sottoespressione ripetuta nella stringa di input.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-105">Match a subexpression that is repeated in the input string.</span></span>  
  
- <span data-ttu-id="ac2b2-106">Applicare un quantificatore a una sottoespressione che dispone di più elementi del linguaggio di espressioni regolari.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-106">Apply a quantifier to a subexpression that has multiple regular expression language elements.</span></span> <span data-ttu-id="ac2b2-107">Per altre informazioni sui quantificatori, vedere [Quantifiers](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="ac2b2-107">For more information about quantifiers, see [Quantifiers](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span></span>  
  
- <span data-ttu-id="ac2b2-108">Includere una sottoespressione nella stringa restituita dai metodi <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> e <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="ac2b2-108">Include a subexpression in the string that is returned by the <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> methods.</span></span>  
  
- <span data-ttu-id="ac2b2-109">Recuperare le singole sottoespressioni dalla proprietà <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> ed elaborarle separatamente dal testo corrispondente nel suo complesso.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-109">Retrieve individual subexpressions from the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property and process them separately from the matched text as a whole.</span></span>  
  
 <span data-ttu-id="ac2b2-110">La tabella seguente elenca i costrutti di raggruppamento supportati dal motore delle espressioni regolari di .NET e indica se sono di acquisizione o non acquisizione.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-110">The following table lists the grouping constructs supported by the .NET regular expression engine and indicates whether they are capturing or non-capturing.</span></span>  
  
|<span data-ttu-id="ac2b2-111">Costrutto di raggruppamento</span><span class="sxs-lookup"><span data-stu-id="ac2b2-111">Grouping construct</span></span>|<span data-ttu-id="ac2b2-112">Acquisizione o non acquisizione</span><span class="sxs-lookup"><span data-stu-id="ac2b2-112">Capturing or noncapturing</span></span>|  
|------------------------|-------------------------------|  
|[<span data-ttu-id="ac2b2-113">Sottoespressioni corrispondenti</span><span class="sxs-lookup"><span data-stu-id="ac2b2-113">Matched subexpressions</span></span>](#matched_subexpression)|<span data-ttu-id="ac2b2-114">Acquisizione</span><span class="sxs-lookup"><span data-stu-id="ac2b2-114">Capturing</span></span>|  
|[<span data-ttu-id="ac2b2-115">Sottoespressioni corrispondenti denominate</span><span class="sxs-lookup"><span data-stu-id="ac2b2-115">Named matched subexpressions</span></span>](#named_matched_subexpression)|<span data-ttu-id="ac2b2-116">Acquisizione</span><span class="sxs-lookup"><span data-stu-id="ac2b2-116">Capturing</span></span>|  
|[<span data-ttu-id="ac2b2-117">Definizioni di gruppo di bilanciamento</span><span class="sxs-lookup"><span data-stu-id="ac2b2-117">Balancing group definitions</span></span>](#balancing_group_definition)|<span data-ttu-id="ac2b2-118">Acquisizione</span><span class="sxs-lookup"><span data-stu-id="ac2b2-118">Capturing</span></span>|  
|[<span data-ttu-id="ac2b2-119">Gruppi di non acquisizione</span><span class="sxs-lookup"><span data-stu-id="ac2b2-119">Noncapturing groups</span></span>](#noncapturing_group)|<span data-ttu-id="ac2b2-120">Non acquisizione</span><span class="sxs-lookup"><span data-stu-id="ac2b2-120">Noncapturing</span></span>|  
|[<span data-ttu-id="ac2b2-121">Opzioni di gruppo</span><span class="sxs-lookup"><span data-stu-id="ac2b2-121">Group options</span></span>](#group_options)|<span data-ttu-id="ac2b2-122">Non acquisizione</span><span class="sxs-lookup"><span data-stu-id="ac2b2-122">Noncapturing</span></span>|  
|[<span data-ttu-id="ac2b2-123">Asserzioni lookahead positive di larghezza zero</span><span class="sxs-lookup"><span data-stu-id="ac2b2-123">Zero-width positive lookahead assertions</span></span>](#zerowidth_positive_lookahead_assertion)|<span data-ttu-id="ac2b2-124">Non acquisizione</span><span class="sxs-lookup"><span data-stu-id="ac2b2-124">Noncapturing</span></span>|  
|[<span data-ttu-id="ac2b2-125">Asserzioni lookahead negative di larghezza zero</span><span class="sxs-lookup"><span data-stu-id="ac2b2-125">Zero-width negative lookahead assertions</span></span>](#zerowidth_negative_lookahead_assertion)|<span data-ttu-id="ac2b2-126">Non acquisizione</span><span class="sxs-lookup"><span data-stu-id="ac2b2-126">Noncapturing</span></span>|  
|[<span data-ttu-id="ac2b2-127">Asserzioni lookbehind positive di larghezza zero</span><span class="sxs-lookup"><span data-stu-id="ac2b2-127">Zero-width positive lookbehind assertions</span></span>](#zerowidth_positive_lookbehind_assertion)|<span data-ttu-id="ac2b2-128">Non acquisizione</span><span class="sxs-lookup"><span data-stu-id="ac2b2-128">Noncapturing</span></span>|  
|[<span data-ttu-id="ac2b2-129">Asserzioni lookbehind negative di larghezza zero</span><span class="sxs-lookup"><span data-stu-id="ac2b2-129">Zero-width negative lookbehind assertions</span></span>](#zerowidth_negative_lookbehind_assertion)|<span data-ttu-id="ac2b2-130">Non acquisizione</span><span class="sxs-lookup"><span data-stu-id="ac2b2-130">Noncapturing</span></span>|  
|[<span data-ttu-id="ac2b2-131">Gruppi atomici</span><span class="sxs-lookup"><span data-stu-id="ac2b2-131">Atomic groups</span></span>](#atomic_groups)|<span data-ttu-id="ac2b2-132">Non acquisizione</span><span class="sxs-lookup"><span data-stu-id="ac2b2-132">Noncapturing</span></span>|  
  
 <span data-ttu-id="ac2b2-133">Per informazioni sui gruppi e sul modello a oggetti delle espressioni regolari, vedere l'argomento relativo ai [costrutti di raggruppamento e oggetti delle espressioni regolari](#Objects).</span><span class="sxs-lookup"><span data-stu-id="ac2b2-133">For information on groups and the regular expression object model, see [Grouping constructs and regular expression objects](#Objects).</span></span>  
  
<a name="matched_subexpression"></a>
## <a name="matched-subexpressions"></a><span data-ttu-id="ac2b2-134">Sottoespressioni corrispondenti</span><span class="sxs-lookup"><span data-stu-id="ac2b2-134">Matched Subexpressions</span></span>  
 <span data-ttu-id="ac2b2-135">Nel costrutto di raggruppamento seguente viene acquisita una sottoespressione corrispondente:</span><span class="sxs-lookup"><span data-stu-id="ac2b2-135">The following grouping construct captures a matched subexpression:</span></span>  
  
 <span data-ttu-id="ac2b2-136">`(` *sottoespressione* `)`</span><span class="sxs-lookup"><span data-stu-id="ac2b2-136">`(` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="ac2b2-137">dove *sottoespressione* è un qualsiasi criterio di espressioni regolari valido.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-137">where *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="ac2b2-138">Le acquisizioni che usano parentesi sono numerate automaticamente da sinistra verso destra in base all'ordine delle parentesi di apertura nell'espressione regolare, a partire da uno.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-138">Captures that use parentheses are numbered automatically from left to right based on the order of the opening parentheses in the regular expression, starting from one.</span></span> <span data-ttu-id="ac2b2-139">L'acquisizione che viene numerata zero è il testo corrispondente all'intero criterio dell'espressione regolare.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-139">The capture that is numbered zero is the text matched by the entire regular expression pattern.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="ac2b2-140">Per impostazione predefinita, l'elemento di linguaggio `(`*sottoespressione*`)` acquisisce la sottoespressione corrispondente.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-140">By default, the `(`*subexpression*`)` language element captures the matched subexpression.</span></span> <span data-ttu-id="ac2b2-141">Tuttavia, se il parametro <xref:System.Text.RegularExpressions.RegexOptions> di un metodo dei criteri di ricerca di espressioni regolari include il flag <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> o se l'opzione `n` viene applicata a questa sottoespressione (vedere [Opzioni di gruppo](#group_options) più avanti in questo argomento), la sottoespressione corrispondente non viene acquisita.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-141">But if the <xref:System.Text.RegularExpressions.RegexOptions> parameter of a regular expression pattern matching method includes the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> flag, or if the `n` option is applied to this subexpression (see [Group options](#group_options) later in this topic), the matched subexpression is not captured.</span></span>  
  
 <span data-ttu-id="ac2b2-142">È possibile accedere a questi gruppi acquisiti in quattro modi diversi:</span><span class="sxs-lookup"><span data-stu-id="ac2b2-142">You can access captured groups in four ways:</span></span>  
  
- <span data-ttu-id="ac2b2-143">Tramite il costrutto del backreference all'interno dell'espressione regolare.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-143">By using the backreference construct within the regular expression.</span></span> <span data-ttu-id="ac2b2-144">Si fa riferimento alla sottoespressione corrispondente nella stessa espressione regolare tramite la sintassi `\`*numero*, dove *numero* è il numero ordinale della sottoespressione acquisita.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-144">The matched subexpression is referenced in the same regular expression by using the syntax `\`*number*, where *number* is the ordinal number of the captured subexpression.</span></span>  
  
- <span data-ttu-id="ac2b2-145">Tramite il costrutto del backreference denominato all'interno dell'espressione regolare.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-145">By using the named backreference construct within the regular expression.</span></span> <span data-ttu-id="ac2b2-146">Si fa riferimento alla sottoespressione corrispondente nella stessa espressione regolare tramite la sintassi `\k<`*nome*`>`, dove *nome* è il nome di un gruppo di acquisizione, o `\k<`*numero*`>`, dove *numero* è il numero ordinale di un gruppo di acquisizione.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-146">The matched subexpression is referenced in the same regular expression by using the syntax `\k<`*name*`>`, where *name* is the name of a capturing group, or `\k<`*number*`>`, where *number* is the ordinal number of a capturing group.</span></span> <span data-ttu-id="ac2b2-147">Un gruppo di acquisizione ha un nome predefinito identico al relativo numero ordinale.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-147">A capturing group has a default name that is identical to its ordinal number.</span></span> <span data-ttu-id="ac2b2-148">Per altre informazioni, vedere [Sottoespressioni corrispondenti denominate](#named_matched_subexpression) più avanti in questo argomento.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-148">For more information, see [Named matched subexpressions](#named_matched_subexpression) later in this topic.</span></span>  
  
- <span data-ttu-id="ac2b2-149">Tramite la sequenza di sostituzione `$`*numero* in una <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> o la chiamata al metodo <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> , dove *numero* è il numero ordinale della sottoespressione acquisita.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-149">By using the `$`*number* replacement sequence in a <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> method call, where *number* is the ordinal number of the captured subexpression.</span></span>  
  
- <span data-ttu-id="ac2b2-150">A livello di codice, usando l'oggetto <xref:System.Text.RegularExpressions.GroupCollection> restituito dalla proprietà <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="ac2b2-150">Programmatically, by using the <xref:System.Text.RegularExpressions.GroupCollection> object returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="ac2b2-151">Il membro alla posizione zero nella raccolta rappresenta l'intera corrispondenza dell'espressione regolare.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-151">The member at position zero in the collection represents the entire regular expression match.</span></span> <span data-ttu-id="ac2b2-152">Ogni membro successivo rappresenta una sottoespressione corrispondente.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-152">Each subsequent member represents a matched subexpression.</span></span> <span data-ttu-id="ac2b2-153">Per altre informazioni, vedere la sezione [Grouping Constructs and Regular Expression Objects](#Objects) .</span><span class="sxs-lookup"><span data-stu-id="ac2b2-153">For more information, see the [Grouping Constructs and Regular Expression Objects](#Objects) section.</span></span>  
  
 <span data-ttu-id="ac2b2-154">Nell'esempio seguente viene illustrata un'espressione regolare che identifica le parole duplicate in un testo.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-154">The following example illustrates a regular expression that identifies duplicated words in text.</span></span> <span data-ttu-id="ac2b2-155">I due gruppi di acquisizione del criterio di ricerca di espressioni regolari rappresentano le due istanze della parola duplicata.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-155">The regular expression pattern's two capturing groups represent the two instances of the duplicated word.</span></span> <span data-ttu-id="ac2b2-156">La seconda istanza è acquisita per riportare la posizione iniziale nella stringa di input.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-156">The second instance is captured to report its starting position in the input string.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#1](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/grouping1.cs#1)]
 [!code-vb[RegularExpressions.Language.Grouping#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/grouping1.vb#1)]  
  
 <span data-ttu-id="ac2b2-157">Il criterio dell'espressione regolare è il seguente:</span><span class="sxs-lookup"><span data-stu-id="ac2b2-157">The regular expression pattern is the following:</span></span>  
  
`(\w+)\s(\1)\W`  
  
 <span data-ttu-id="ac2b2-158">Nella tabella seguente è illustrata l'interpretazione del criterio di ricerca di espressioni regolari.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-158">The following table shows how the regular expression pattern is interpreted.</span></span>  
  
|<span data-ttu-id="ac2b2-159">Modello</span><span class="sxs-lookup"><span data-stu-id="ac2b2-159">Pattern</span></span>|<span data-ttu-id="ac2b2-160">Descrizione</span><span class="sxs-lookup"><span data-stu-id="ac2b2-160">Description</span></span>|  
|-------------|-----------------|  
|`(\w+)`|<span data-ttu-id="ac2b2-161">Trova la corrispondenza di uno o più caratteri alfanumerici.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-161">Match one or more word characters.</span></span> <span data-ttu-id="ac2b2-162">Equivale al primo gruppo di acquisizione.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-162">This is the first capturing group.</span></span>|  
|`\s`|<span data-ttu-id="ac2b2-163">Trova la corrispondenza con uno spazio vuoto.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-163">Match a white-space character.</span></span>|  
|`(\1)`|<span data-ttu-id="ac2b2-164">Trova la corrispondenza con la stringa nel primo gruppo acquisito.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-164">Match the string in the first captured group.</span></span> <span data-ttu-id="ac2b2-165">Equivale al secondo gruppo di acquisizione.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-165">This is the second capturing group.</span></span> <span data-ttu-id="ac2b2-166">L'esempio lo assegna a un gruppo acquisito in modo che sia possibile recuperare la posizione iniziale della parola duplicata dalla proprietà `Match.Index` .</span><span class="sxs-lookup"><span data-stu-id="ac2b2-166">The example assigns it to a captured group so that the starting position of the duplicate word can be retrieved from the `Match.Index` property.</span></span>|  
|`\W`|<span data-ttu-id="ac2b2-167">Trova la corrispondenza con un carattere non alfanumerico, inclusi spazio vuoto e punteggiatura.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-167">Match a non-word character, including white space and punctuation.</span></span> <span data-ttu-id="ac2b2-168">Impedisce al criterio dell'espressione regolare di trovare la corrispondenza con una parola che inizia con la parola del primo gruppo acquisito.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-168">This prevents the regular expression pattern from matching a word that starts with the word from the first captured group.</span></span>|  
  
<a name="named_matched_subexpression"></a>
## <a name="named-matched-subexpressions"></a><span data-ttu-id="ac2b2-169">Sottoespressioni corrispondenti denominate</span><span class="sxs-lookup"><span data-stu-id="ac2b2-169">Named Matched Subexpressions</span></span>  
 <span data-ttu-id="ac2b2-170">Il costrutto di raggruppamento seguente acquisisce una sottoespressione corrispondente e consente di accedervi tramite nome o numero:</span><span class="sxs-lookup"><span data-stu-id="ac2b2-170">The following grouping construct captures a matched subexpression and lets you access it by name or by number:</span></span>  
  
`(?<name>subexpression)`  
  
 <span data-ttu-id="ac2b2-171">oppure:</span><span class="sxs-lookup"><span data-stu-id="ac2b2-171">or:</span></span>  
  
`(?'name'subexpression)`  
  
 <span data-ttu-id="ac2b2-172">dove *nome* è un nome di gruppo valido e *sottoespressione* è un qualsiasi criterio di ricerca di espressioni regolari valido.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-172">where *name* is a valid group name, and *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="ac2b2-173">*nome* non deve contenere alcun simbolo di punteggiatura e non può iniziare con un numero.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-173">*name* must not contain any punctuation characters and cannot begin with a number.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="ac2b2-174">Se il parametro <xref:System.Text.RegularExpressions.RegexOptions> di un metodo dei criteri di ricerca di espressioni regolari include il flag <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> o se l'opzione `n` viene applicata a questa sottoespressione (vedere [Opzioni di gruppo](#group_options) più avanti in questo argomento), l'unico modo per acquisire una sottoespressione è assegnare esplicitamente un nome ai gruppi di acquisizione.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-174">If the <xref:System.Text.RegularExpressions.RegexOptions> parameter of a regular expression pattern matching method includes the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> flag, or if the `n` option is applied to this subexpression (see [Group options](#group_options) later in this topic), the only way to capture a subexpression is to explicitly name capturing groups.</span></span>  
  
 <span data-ttu-id="ac2b2-175">È possibile accedere ai gruppi acquisiti denominati nei modi seguenti:</span><span class="sxs-lookup"><span data-stu-id="ac2b2-175">You can access named captured groups in the following ways:</span></span>  
  
- <span data-ttu-id="ac2b2-176">Tramite il costrutto del backreference denominato all'interno dell'espressione regolare.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-176">By using the named backreference construct within the regular expression.</span></span> <span data-ttu-id="ac2b2-177">Si fa riferimento alla sottoespressione corrispondente nella stessa espressione regolare tramite la sintassi `\k<`*nome*`>`, dove *nome* è il nome della sottoespressione acquisita.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-177">The matched subexpression is referenced in the same regular expression by using the syntax `\k<`*name*`>`, where *name* is the name of the captured subexpression.</span></span>  
  
- <span data-ttu-id="ac2b2-178">Tramite il costrutto del backreference all'interno dell'espressione regolare.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-178">By using the backreference construct within the regular expression.</span></span> <span data-ttu-id="ac2b2-179">Si fa riferimento alla sottoespressione corrispondente nella stessa espressione regolare tramite la sintassi `\`*numero*, dove *numero* è il numero ordinale della sottoespressione acquisita.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-179">The matched subexpression is referenced in the same regular expression by using the syntax `\`*number*, where *number* is the ordinal number of the captured subexpression.</span></span> <span data-ttu-id="ac2b2-180">Le sottoespressioni corrispondenti denominate sono numerate consecutivamente da sinistra a destra dopo le sottoespressioni corrispondenti.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-180">Named matched subexpressions are numbered consecutively from left to right after matched subexpressions.</span></span>  
  
- <span data-ttu-id="ac2b2-181">Tramite la sequenza di sostituzione `${`*nome*`}` in una <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> o la chiamata al metodo <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> , dove *nome* è il nome della sottoespressione acquisita.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-181">By using the `${`*name*`}` replacement sequence in a <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> method call, where *name* is the name of the captured subexpression.</span></span>  
  
- <span data-ttu-id="ac2b2-182">Tramite la sequenza di sostituzione `$`*numero* in una <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> o la chiamata al metodo <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> , dove *numero* è il numero ordinale della sottoespressione acquisita.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-182">By using the `$`*number* replacement sequence in a <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Match.Result%2A?displayProperty=nameWithType> method call, where *number* is the ordinal number of the captured subexpression.</span></span>  
  
- <span data-ttu-id="ac2b2-183">A livello di codice, usando l'oggetto <xref:System.Text.RegularExpressions.GroupCollection> restituito dalla proprietà <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="ac2b2-183">Programmatically, by using the <xref:System.Text.RegularExpressions.GroupCollection> object returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="ac2b2-184">Il membro alla posizione zero nella raccolta rappresenta l'intera corrispondenza dell'espressione regolare.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-184">The member at position zero in the collection represents the entire regular expression match.</span></span> <span data-ttu-id="ac2b2-185">Ogni membro successivo rappresenta una sottoespressione corrispondente.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-185">Each subsequent member represents a matched subexpression.</span></span> <span data-ttu-id="ac2b2-186">I gruppi acquisiti denominati vengono archiviati nella raccolta dopo i gruppi acquisiti numerati.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-186">Named captured groups are stored in the collection after numbered captured groups.</span></span>  
  
- <span data-ttu-id="ac2b2-187">A livello di codice, fornendo il nome della sottoespressione all'indicizzatore dell'oggetto <xref:System.Text.RegularExpressions.GroupCollection> (in C#) o alla relativa proprietà <xref:System.Text.RegularExpressions.GroupCollection.Item%2A> (in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="ac2b2-187">Programmatically, by providing the subexpression name to the <xref:System.Text.RegularExpressions.GroupCollection> object's indexer (in C#) or to its <xref:System.Text.RegularExpressions.GroupCollection.Item%2A> property (in Visual Basic).</span></span>  
  
 <span data-ttu-id="ac2b2-188">Un criterio di ricerca di espressioni regolari semplice illustra in che modo è possibile fare riferimento a gruppi denominati e numerati (non denominati) a livello di codice o tramite la sintassi del linguaggio delle espressioni regolari.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-188">A simple regular expression pattern illustrates how numbered (unnamed) and named groups can be referenced either programmatically or by using regular expression language syntax.</span></span> <span data-ttu-id="ac2b2-189">L'espressione regolare `((?<One>abc)\d+)?(?<Two>xyz)(.*)` crea i gruppi di acquisizione seguenti in base a numero e nome.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-189">The regular expression `((?<One>abc)\d+)?(?<Two>xyz)(.*)` produces the following capturing groups by number and by name.</span></span> <span data-ttu-id="ac2b2-190">Il primo gruppo di acquisizione (numero 0) fa sempre riferimento all'intero criterio.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-190">The first capturing group (number 0) always refers to the entire pattern.</span></span>  
  
|<span data-ttu-id="ac2b2-191">Number</span><span class="sxs-lookup"><span data-stu-id="ac2b2-191">Number</span></span>|<span data-ttu-id="ac2b2-192">Nome</span><span class="sxs-lookup"><span data-stu-id="ac2b2-192">Name</span></span>|<span data-ttu-id="ac2b2-193">Modello</span><span class="sxs-lookup"><span data-stu-id="ac2b2-193">Pattern</span></span>|  
|------------|----------|-------------|  
|<span data-ttu-id="ac2b2-194">0</span><span class="sxs-lookup"><span data-stu-id="ac2b2-194">0</span></span>|<span data-ttu-id="ac2b2-195">0 (nome predefinito)</span><span class="sxs-lookup"><span data-stu-id="ac2b2-195">0 (default name)</span></span>|`((?<One>abc)\d+)?(?<Two>xyz)(.*)`|  
|<span data-ttu-id="ac2b2-196">1</span><span class="sxs-lookup"><span data-stu-id="ac2b2-196">1</span></span>|<span data-ttu-id="ac2b2-197">1 (nome predefinito)</span><span class="sxs-lookup"><span data-stu-id="ac2b2-197">1 (default name)</span></span>|`((?<One>abc)\d+)`|  
|<span data-ttu-id="ac2b2-198">2</span><span class="sxs-lookup"><span data-stu-id="ac2b2-198">2</span></span>|<span data-ttu-id="ac2b2-199">2 (nome predefinito)</span><span class="sxs-lookup"><span data-stu-id="ac2b2-199">2 (default name)</span></span>|`(.*)`|  
|<span data-ttu-id="ac2b2-200">3</span><span class="sxs-lookup"><span data-stu-id="ac2b2-200">3</span></span>|<span data-ttu-id="ac2b2-201">Uno</span><span class="sxs-lookup"><span data-stu-id="ac2b2-201">One</span></span>|`(?<One>abc)`|  
|<span data-ttu-id="ac2b2-202">4</span><span class="sxs-lookup"><span data-stu-id="ac2b2-202">4</span></span>|<span data-ttu-id="ac2b2-203">Due</span><span class="sxs-lookup"><span data-stu-id="ac2b2-203">Two</span></span>|`(?<Two>xyz)`|  
  
 <span data-ttu-id="ac2b2-204">Nell'esempio seguente viene illustrata un'espressione regolare che identifica parole duplicate e la parola che segue immediatamente ogni parola duplicata.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-204">The following example illustrates a regular expression that identifies duplicated words and the word that immediately follows each duplicated word.</span></span> <span data-ttu-id="ac2b2-205">Il criterio di ricerca di espressioni regolari definisce due sottoespressioni denominate: `duplicateWord`che rappresenta la parola duplicata e `nextWord`che rappresenta la parola che segue la parola duplicata.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-205">The regular expression pattern defines two named subexpressions: `duplicateWord`, which represents the duplicated word; and `nextWord`, which represents the word that follows the duplicated word.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#2](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/grouping2.cs#2)]
 [!code-vb[RegularExpressions.Language.Grouping#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/grouping2.vb#2)]  
  
 <span data-ttu-id="ac2b2-206">Il criterio di ricerca di espressioni regolari è il seguente:</span><span class="sxs-lookup"><span data-stu-id="ac2b2-206">The regular expression pattern is as follows:</span></span>  
  
`(?<duplicateWord>\w+)\s\k<duplicateWord>\W(?<nextWord>\w+)`  
  
 <span data-ttu-id="ac2b2-207">Nella tabella seguente viene illustrato come viene interpretata l'espressione regolare.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-207">The following table shows how the regular expression is interpreted.</span></span>  
  
|<span data-ttu-id="ac2b2-208">Modello</span><span class="sxs-lookup"><span data-stu-id="ac2b2-208">Pattern</span></span>|<span data-ttu-id="ac2b2-209">Descrizione</span><span class="sxs-lookup"><span data-stu-id="ac2b2-209">Description</span></span>|  
|-------------|-----------------|  
|`(?<duplicateWord>\w+)`|<span data-ttu-id="ac2b2-210">Trova la corrispondenza di uno o più caratteri alfanumerici.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-210">Match one or more word characters.</span></span> <span data-ttu-id="ac2b2-211">Il nome di questo gruppo di acquisizione è `duplicateWord`.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-211">Name this capturing group `duplicateWord`.</span></span>|  
|`\s`|<span data-ttu-id="ac2b2-212">Trova la corrispondenza con uno spazio vuoto.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-212">Match a white-space character.</span></span>|  
|`\k<duplicateWord>`|<span data-ttu-id="ac2b2-213">Trova la corrispondenza con la stringa del gruppo acquisito che è denominata `duplicateWord`.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-213">Match the string from the captured group that is named `duplicateWord`.</span></span>|  
|`\W`|<span data-ttu-id="ac2b2-214">Trova la corrispondenza con un carattere non alfanumerico, inclusi spazio vuoto e punteggiatura.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-214">Match a non-word character, including white space and punctuation.</span></span> <span data-ttu-id="ac2b2-215">Impedisce al criterio dell'espressione regolare di trovare la corrispondenza con una parola che inizia con la parola del primo gruppo acquisito.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-215">This prevents the regular expression pattern from matching a word that starts with the word from the first captured group.</span></span>|  
|`(?<nextWord>\w+)`|<span data-ttu-id="ac2b2-216">Trova la corrispondenza di uno o più caratteri alfanumerici.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-216">Match one or more word characters.</span></span> <span data-ttu-id="ac2b2-217">Il nome di questo gruppo di acquisizione è `nextWord`.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-217">Name this capturing group `nextWord`.</span></span>|  
  
 <span data-ttu-id="ac2b2-218">Il nome di un gruppo può essere ripetuto in un'espressione regolare.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-218">Note that a group name can be repeated in a regular expression.</span></span> <span data-ttu-id="ac2b2-219">Ad esempio, è possibile che più di un gruppo sia denominato `digit`, come illustrato nell'esempio seguente.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-219">For example, it is possible for more than one group to be named `digit`, as the following example illustrates.</span></span> <span data-ttu-id="ac2b2-220">Nel caso di nomi duplicati, il valore dell'oggetto <xref:System.Text.RegularExpressions.Group> dipende dall'ultima acquisizione corretta nella stringa di input.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-220">In the case of duplicate names, the value of the <xref:System.Text.RegularExpressions.Group> object is determined by the last successful capture in the input string.</span></span> <span data-ttu-id="ac2b2-221">Anche l'oggetto <xref:System.Text.RegularExpressions.CaptureCollection> viene popolato con informazioni su ogni acquisizione, secondo la normale procedura usata quando il nome del gruppo non è duplicato.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-221">In addition, the <xref:System.Text.RegularExpressions.CaptureCollection> is populated with information about each capture just as it would be if the group name was not duplicated.</span></span>  
  
 <span data-ttu-id="ac2b2-222">Nell'esempio seguente l'espressione regolare `\D+(?<digit>\d+)\D+(?<digit>\d+)?` include due occorrenze di un gruppo denominato `digit`.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-222">In the following example, the regular expression `\D+(?<digit>\d+)\D+(?<digit>\d+)?` includes two occurrences of a group named `digit`.</span></span> <span data-ttu-id="ac2b2-223">Il primo gruppo denominato `digit` acquisisce una o più cifre.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-223">The first `digit` named group captures one or more digit characters.</span></span> <span data-ttu-id="ac2b2-224">Il secondo gruppo denominato `digit` acquisisce zero o un'occorrenza di una o più cifre.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-224">The second `digit` named group captures either zero or one occurrence of one or more digit characters.</span></span> <span data-ttu-id="ac2b2-225">Come illustrato nell'esempio, se il secondo gruppo di acquisizione corrisponde al testo, il valore del testo definisce il valore dell'oggetto <xref:System.Text.RegularExpressions.Group> .</span><span class="sxs-lookup"><span data-stu-id="ac2b2-225">As the output from the example shows, if the second capturing group successfully matches text, the value of that text defines the value of the <xref:System.Text.RegularExpressions.Group> object.</span></span> <span data-ttu-id="ac2b2-226">Se il secondo gruppo di acquisizione non corrisponde alla stringa di input, il valore dell'ultima corrispondenza corretta definisce il valore dell'oggetto <xref:System.Text.RegularExpressions.Group> .</span><span class="sxs-lookup"><span data-stu-id="ac2b2-226">If the second capturing group cannot does not match the input string, the value of the last successful match defines the value of the <xref:System.Text.RegularExpressions.Group> object.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#12](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/duplicate1.cs#12)]
 [!code-vb[RegularExpressions.Language.Grouping#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/duplicate1.vb#12)]  
  
 <span data-ttu-id="ac2b2-227">Nella tabella seguente viene illustrato come viene interpretata l'espressione regolare.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-227">The following table shows how the regular expression is interpreted.</span></span>  
  
|<span data-ttu-id="ac2b2-228">Modello</span><span class="sxs-lookup"><span data-stu-id="ac2b2-228">Pattern</span></span>|<span data-ttu-id="ac2b2-229">Descrizione</span><span class="sxs-lookup"><span data-stu-id="ac2b2-229">Description</span></span>|  
|-------------|-----------------|  
|`\D+`|<span data-ttu-id="ac2b2-230">Corrisponde a una o più cifre non decimali.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-230">Match one or more non-decimal digit characters.</span></span>|  
|`(?<digit>\d+)`|<span data-ttu-id="ac2b2-231">Corrisponde a una o più cifre decimali.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-231">Match one or more decimal digit characters.</span></span> <span data-ttu-id="ac2b2-232">Assegna la corrispondenza al gruppo denominato `digit`.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-232">Assign the match to the `digit` named group.</span></span>|  
|`\D+`|<span data-ttu-id="ac2b2-233">Corrisponde a una o più cifre non decimali.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-233">Match one or more non-decimal digit characters.</span></span>|  
|`(?<digit>\d+)?`|<span data-ttu-id="ac2b2-234">Corrisponde a zero o a un'occorrenza di una o più cifre decimali.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-234">Match zero or one occurrence of one or more decimal digit characters.</span></span> <span data-ttu-id="ac2b2-235">Assegna la corrispondenza al gruppo denominato `digit`.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-235">Assign the match to the `digit` named group.</span></span>|  
  
<a name="balancing_group_definition"></a>
## <a name="balancing-group-definitions"></a><span data-ttu-id="ac2b2-236">Definizioni di gruppo di bilanciamento</span><span class="sxs-lookup"><span data-stu-id="ac2b2-236">Balancing Group Definitions</span></span>  
 <span data-ttu-id="ac2b2-237">Una definizione di gruppo di bilanciamento elimina la definizione di un gruppo precedentemente definito e archivia nel gruppo corrente l'intervallo tra il gruppo precedentemente definito e il gruppo corrente.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-237">A balancing group definition deletes the definition of a previously defined group and stores, in the current group, the interval between the previously defined group and the current group.</span></span> <span data-ttu-id="ac2b2-238">Questo costrutto di raggruppamento presenta il formato seguente:</span><span class="sxs-lookup"><span data-stu-id="ac2b2-238">This grouping construct has the following format:</span></span>  
  
`(?<name1-name2>subexpression)`  
  
 <span data-ttu-id="ac2b2-239">oppure:</span><span class="sxs-lookup"><span data-stu-id="ac2b2-239">or:</span></span>  
  
`(?'name1-name2' subexpression)`
  
 <span data-ttu-id="ac2b2-240">dove *nome1* è il gruppo corrente (facoltativo), *nome2* è un gruppo precedentemente definito e *sottoespressione* è qualsiasi criterio di ricerca di espressioni regolari valido.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-240">where *name1* is the current group (optional), *name2* is a previously defined group, and *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="ac2b2-241">La definizione di gruppo di bilanciamento elimina la definizione di *nome2* e archivia l'intervallo tra *nome2* e *nome1* in *nome1*.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-241">The balancing group definition deletes the definition of *name2* and stores the interval between *name2* and *name1* in *name1*.</span></span> <span data-ttu-id="ac2b2-242">Se non è definito alcun gruppo *nome2* , viene eseguito il backtracking della corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-242">If no *name2* group is defined, the match backtracks.</span></span> <span data-ttu-id="ac2b2-243">Poiché l'eliminazione dell'ultima definizione di *nome2* rivela la definizione precedente di *nome2*, questo costrutto consente di usare lo stack di acquisizioni per il gruppo *nome2* come contatore per tenere traccia dei costrutti annidati, come ad esempio le parentesi o le parentesi quadre di apertura e chiusura.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-243">Because deleting the last definition of *name2* reveals the previous definition of *name2*, this construct lets you use the stack of captures for group *name2* as a counter for keeping track of nested constructs such as parentheses or opening and closing brackets.</span></span>  
  
 <span data-ttu-id="ac2b2-244">La definizione del gruppo di bilanciamento usa *nome2* come uno stack.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-244">The balancing group definition uses *name2* as a stack.</span></span> <span data-ttu-id="ac2b2-245">Il carattere iniziale di ogni costrutto annidato viene posizionato nel gruppo e nella relativa raccolta <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="ac2b2-245">The beginning character of each nested construct is placed in the group and in its <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collection.</span></span> <span data-ttu-id="ac2b2-246">Quando viene trovata la corrispondenza con il carattere di chiusura, il carattere di apertura associato viene rimosso dal gruppo e la raccolta <xref:System.Text.RegularExpressions.Group.Captures%2A> viene ridotta di uno.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-246">When the closing character is matched, its corresponding opening character is removed from the group, and the <xref:System.Text.RegularExpressions.Group.Captures%2A> collection is decreased by one.</span></span> <span data-ttu-id="ac2b2-247">Dopo che la corrispondenza dei caratteri di apertura e chiusura di tutti i costrutti annidati è stata trovata, *nome2* è vuoto.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-247">After the opening and closing characters of all nested constructs have been matched, *name2* is empty.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="ac2b2-248">Dopo avere modificato l'espressione regolare dell'esempio seguente affinché usi il carattere di apertura e chiusura appropriato di un costrutto annidato, è possibile usarla per gestire più costrutti annidati, come ad esempio espressioni matematiche o righe di codice del programma che includono più chiamate al metodo annidate.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-248">After you modify the regular expression in the following example to use the appropriate opening and closing character of a nested construct, you can use it to handle most nested constructs, such as mathematical expressions or lines of program code that include multiple nested method calls.</span></span>  
  
 <span data-ttu-id="ac2b2-249">Nell'esempio seguente viene usata una definizione di gruppo di bilanciamento per trovare una corrispondenza di parentesi uncinate aperte e chiuse (<>) in una stringa di input.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-249">The following example uses a balancing group definition to match left and right angle brackets (<>) in an input string.</span></span> <span data-ttu-id="ac2b2-250">Nell'esempio vengono definiti due gruppi denominati, `Open` e `Close`, usati come uno stack per rilevare coppie corrispondenti di parentesi uncinate.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-250">The example defines two named groups, `Open` and `Close`, that are used like a stack to track matching pairs of angle brackets.</span></span> <span data-ttu-id="ac2b2-251">Ogni parentesi uncinata aperta acquisita viene inserita nella raccolta di acquisizioni del gruppo `Open` e ogni parentesi uncinata chiusa acquisita viene inserita nella raccolta di acquisizioni del gruppo `Close` .</span><span class="sxs-lookup"><span data-stu-id="ac2b2-251">Each captured left angle bracket is pushed into the capture collection of the `Open` group, and each captured right angle bracket is pushed into the capture collection of the `Close` group.</span></span> <span data-ttu-id="ac2b2-252">La definizione di gruppo di bilanciamento si assicura che sia presente una parentesi uncinata chiusa corrispondente per ogni parentesi uncinata aperta.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-252">The balancing group definition ensures that there is a matching right angle bracket for each left angle bracket.</span></span> <span data-ttu-id="ac2b2-253">In caso contrario, il criterio secondario `(?(Open)(?!))`finale viene valutato solo se il gruppo `Open` non è vuoto e, pertanto, se tutti i costrutti annidati non sono stati chiusi.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-253">If there is not, the final subpattern, `(?(Open)(?!))`, is evaluated only if the `Open` group is not empty (and, therefore, if all nested constructs have not been closed).</span></span> <span data-ttu-id="ac2b2-254">Se il criterio secondario finale viene valutato, non viene trovata la corrispondenza perché il criterio secondario `(?!)` è un'asserzione lookahead negativa di larghezza zero che ha sempre esito negativo.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-254">If the final subpattern is evaluated, the match fails, because the `(?!)` subpattern is a zero-width negative lookahead assertion that always fails.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#3](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/grouping3.cs#3)]
 [!code-vb[RegularExpressions.Language.Grouping#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/grouping3.vb#3)]  
  
 <span data-ttu-id="ac2b2-255">Il criterio di ricerca di espressioni regolari è:</span><span class="sxs-lookup"><span data-stu-id="ac2b2-255">The regular expression pattern is:</span></span>  
  
`^[^<>]*(((?'Open'<)[^<>]*)+((?'Close-Open'>)[^<>]*)+)*(?(Open)(?!))$`  
  
 <span data-ttu-id="ac2b2-256">L'espressione regolare viene interpretata nel modo seguente.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-256">The regular expression is interpreted as follows:</span></span>  
  
|<span data-ttu-id="ac2b2-257">Modello</span><span class="sxs-lookup"><span data-stu-id="ac2b2-257">Pattern</span></span>|<span data-ttu-id="ac2b2-258">Descrizione</span><span class="sxs-lookup"><span data-stu-id="ac2b2-258">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="ac2b2-259">Comincia all'inizio della stringa.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-259">Begin at the start of the string.</span></span>|  
|`[^<>]*`|<span data-ttu-id="ac2b2-260">Trova la corrispondenza di zero o più caratteri diversi da parentesi uncinate aperte o chiuse.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-260">Match zero or more characters that are not left or right angle brackets.</span></span>|  
|`(?'Open'<)`|<span data-ttu-id="ac2b2-261">Trova la corrispondenza di una parentesi uncinata aperta e la assegna a un gruppo denominato `Open`.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-261">Match a left angle bracket and assign it to a group named `Open`.</span></span>|  
|`[^<>]*`|<span data-ttu-id="ac2b2-262">Trova la corrispondenza di zero o più caratteri diversi da parentesi uncinate aperte o chiuse.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-262">Match zero or more characters that are not left or right angle brackets.</span></span>|  
|`((?'Open'<)[^<>]*)+`|<span data-ttu-id="ac2b2-263">Trova la corrispondenza di una o più occorrenze di una parentesi uncinata aperta seguita da zero o più caratteri diversi da parentesi uncinate aperte o chiuse.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-263">Match one or more occurrences of a left angle bracket followed by zero or more characters that are not left or right angle brackets.</span></span> <span data-ttu-id="ac2b2-264">Equivale al secondo gruppo di acquisizione.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-264">This is the second capturing group.</span></span>|  
|`(?'Close-Open'>)`|<span data-ttu-id="ac2b2-265">Trova la corrispondenza di una parentesi uncinata chiusa, assegna la sottostringa tra il gruppo `Open` e il gruppo corrente al gruppo `Close` ed elimina la definizione del gruppo `Open`.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-265">Match a right angle bracket, assign the substring between the `Open` group and the current group to the `Close` group, and delete the definition of the `Open` group.</span></span>|  
|`[^<>]*`|<span data-ttu-id="ac2b2-266">Trova la corrispondenza di zero o più occorrenze di qualsiasi carattere diverso da parentesi uncinate aperte o chiuse.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-266">Match zero or more occurrences of any character that is neither a left  nor a right angle bracket.</span></span>|  
|`((?'Close-Open'>)[^<>]*)+`|<span data-ttu-id="ac2b2-267">Trova la corrispondenza di una o più occorrenze di una parentesi uncinata chiusa seguita da zero o più occorrenze di caratteri diversi da parentesi uncinate aperte o chiuse.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-267">Match one or more occurrences of a right angle bracket, followed by zero or more occurrences of any character that is neither a left nor a right angle bracket.</span></span> <span data-ttu-id="ac2b2-268">In caso di corrispondenza di una parentesi uncinata chiusa, assegna la sottostringa tra il gruppo `Open` e il gruppo corrente al gruppo `Close` ed elimina la definizione del gruppo `Open` .</span><span class="sxs-lookup"><span data-stu-id="ac2b2-268">When matching the right angle bracket, assign the substring between the `Open` group and the current group to the `Close` group, and delete the definition of the `Open` group.</span></span> <span data-ttu-id="ac2b2-269">Equivale al terzo gruppo di acquisizione.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-269">This is the third capturing group.</span></span>|  
|`(((?'Open'<)[^<>]*)+((?'Close-Open'>)[^<>]*)+)*`|<span data-ttu-id="ac2b2-270">Trova la corrispondenza di zero o più occorrenze del criterio seguente: una o più occorrenze di una parentesi uncinata aperta seguite da zero o più parentesi uncinate, seguite da zero o più parentesi non uncinate, seguite da una o più occorrenze di parentesi uncinate chiuse, seguite da zero o più occorrenze di parentesi non uncinate.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-270">Match zero or more occurrences of the following pattern: one or more occurrences of a left angle bracket, followed by zero or more non-angle bracket characters, followed by one or more occurrences of a right angle bracket, followed by zero or more occurrences of non-angle brackets.</span></span> <span data-ttu-id="ac2b2-271">In caso di corrispondenza di una parentesi uncinata chiusa, elimina la definizione del gruppo `Open` e assegna la sottostringa tra il gruppo `Open` e il gruppo corrente al gruppo `Close` .</span><span class="sxs-lookup"><span data-stu-id="ac2b2-271">When matching the right angle bracket, delete the definition of the `Open` group, and assign the substring between the `Open` group and the current group to the `Close` group.</span></span> <span data-ttu-id="ac2b2-272">Equivale al primo gruppo di acquisizione.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-272">This is the first capturing group.</span></span>|  
|`(?(Open)(?!))`|<span data-ttu-id="ac2b2-273">Se il gruppo `Open` esiste, abbandona la corrispondenza se è possibile trovare una corrispondenza per una stringa vuota, ma non avanza la posizione del motore delle espressioni regolari nella stringa.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-273">If the `Open` group exists, abandon the match if an empty string can be matched, but do not advance the position of the regular expression engine in the string.</span></span> <span data-ttu-id="ac2b2-274">Si tratta di un'asserzione lookahead negativa di larghezza zero.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-274">This is a zero-width negative lookahead assertion.</span></span> <span data-ttu-id="ac2b2-275">Poiché una stringa vuota è sempre presente in modo implicito in una stringa di input, questa corrispondenza ha sempre esito negativo.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-275">Because an empty string is always implicitly present in an input string, this match always fails.</span></span> <span data-ttu-id="ac2b2-276">L'esito negativo della corrispondenza indica che le parentesi uncinate non sono bilanciate.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-276">Failure of this match indicates that the angle brackets are not balanced.</span></span>|  
|`$`|<span data-ttu-id="ac2b2-277">Trova la corrispondenza con la fine della stringa di input.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-277">Match the end of the input string.</span></span>|  
  
 <span data-ttu-id="ac2b2-278">La sottoespressione finale, `(?(Open)(?!))`, indica se i costrutti annidati nella stringa di input sono bilanciati correttamente, ad esempio se a ogni parentesi uncinata aperta corrisponde una parentesi uncinata chiusa.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-278">The final subexpression, `(?(Open)(?!))`, indicates whether the nesting constructs in the input string are properly balanced (for example, whether each left angle bracket is matched by a right angle bracket).</span></span> <span data-ttu-id="ac2b2-279">Usa la corrispondenza condizionale basata su un gruppo acquisito valido. Per altre informazioni, vedere [Alternation Constructs](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="ac2b2-279">It uses conditional matching based on a valid captured group; for more information, see [Alternation Constructs](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span></span> <span data-ttu-id="ac2b2-280">Se il gruppo `Open` è definito, il motore delle espressioni regolari tenta di stabilire una corrispondenza con la sottoespressione `(?!)` nella stringa di input.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-280">If the `Open` group is defined, the regular expression engine attempts to match the subexpression `(?!)` in the input string.</span></span> <span data-ttu-id="ac2b2-281">Il gruppo `Open` deve essere definito solo se i costrutti annidati non sono bilanciati.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-281">The `Open` group should be defined only if nesting constructs are unbalanced.</span></span> <span data-ttu-id="ac2b2-282">Di conseguenza, il criterio per cui trovare la corrispondenza nella stringa di input deve essere inclusi tra quelli che determinano sempre un esito negativo della corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-282">Therefore, the pattern to be matched in the input string should be one that always causes the match to fail.</span></span> <span data-ttu-id="ac2b2-283">In questo caso, `(?!)` è un'asserzione lookahead negativa di larghezza zero che ha sempre esito negativo, in quanto una stringa vuota è sempre implicitamente presente nella posizione successiva nella stringa di input.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-283">In this case, `(?!)` is a zero-width negative lookahead assertion that always fails, because an empty string is always implicitly present at the next position in the input string.</span></span>  
  
 <span data-ttu-id="ac2b2-284">Nell'esempio, il motore delle espressioni regolari valuta la stringa di input "\<abc><mno\<xyz>>", come illustrato nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-284">In the example, the regular expression engine evaluates the input string "\<abc><mno\<xyz>>" as shown in the following table.</span></span>  
  
|<span data-ttu-id="ac2b2-285">Passaggio</span><span class="sxs-lookup"><span data-stu-id="ac2b2-285">Step</span></span>|<span data-ttu-id="ac2b2-286">Modello</span><span class="sxs-lookup"><span data-stu-id="ac2b2-286">Pattern</span></span>|<span data-ttu-id="ac2b2-287">Risultato</span><span class="sxs-lookup"><span data-stu-id="ac2b2-287">Result</span></span>|  
|----------|-------------|------------|  
|<span data-ttu-id="ac2b2-288">1</span><span class="sxs-lookup"><span data-stu-id="ac2b2-288">1</span></span>|`^`|<span data-ttu-id="ac2b2-289">Inizia la corrispondenza all'inizio della stringa di input.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-289">Starts the match at the beginning of the input string</span></span>|  
|<span data-ttu-id="ac2b2-290">2</span><span class="sxs-lookup"><span data-stu-id="ac2b2-290">2</span></span>|`[^<>]*`|<span data-ttu-id="ac2b2-291">Cerca parentesi non uncinate prima della parentesi uncinata aperta; non trova corrispondenze.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-291">Looks for non-angle bracket characters before the left angle bracket;finds no matches.</span></span>|  
|<span data-ttu-id="ac2b2-292">3</span><span class="sxs-lookup"><span data-stu-id="ac2b2-292">3</span></span>|`(((?'Open'<)`|<span data-ttu-id="ac2b2-293">Trova la corrispondenza della parentesi uncinata aperta in "\<abc>" e la assegna al gruppo `Open`.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-293">Matches the left angle bracket in "\<abc>" and assigns it to the `Open` group.</span></span>|  
|<span data-ttu-id="ac2b2-294">4</span><span class="sxs-lookup"><span data-stu-id="ac2b2-294">4</span></span>|`[^<>]*`|<span data-ttu-id="ac2b2-295">Trova la corrispondenza con "abc".</span><span class="sxs-lookup"><span data-stu-id="ac2b2-295">Matches "abc".</span></span>|  
|<span data-ttu-id="ac2b2-296">5</span><span class="sxs-lookup"><span data-stu-id="ac2b2-296">5</span></span>|`)+`|<span data-ttu-id="ac2b2-297">"<abc" è il valore del secondo gruppo acquisito.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-297">"<abc" is the value of the second captured group.</span></span><br /><br /> <span data-ttu-id="ac2b2-298">Il carattere successivo nella stringa di input non è una parentesi uncinata aperta, pertanto il motore delle espressioni regolari non esegue il loopback al criterio secondario `(?'Open'<)[^<>]*)`.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-298">The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the `(?'Open'<)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="ac2b2-299">6</span><span class="sxs-lookup"><span data-stu-id="ac2b2-299">6</span></span>|`((?'Close-Open'>)`|<span data-ttu-id="ac2b2-300">Trova la corrispondenza della parentesi uncinata chiusa in "\<abc>", che è la sottostringa tra il gruppo `Open` e la parentesi uncinata chiusa, al gruppo `Close` ed elimina il valore corrente ("<") del gruppo `Open`, lasciandolo vuoto.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-300">Matches the right angle bracket in "\<abc>", assigns "abc", which is the substring between the `Open` group and the right angle bracket, to the `Close` group, and deletes the current value ("<") of the `Open` group, leaving it empty.</span></span>|  
|<span data-ttu-id="ac2b2-301">7</span><span class="sxs-lookup"><span data-stu-id="ac2b2-301">7</span></span>|`[^<>]*`|<span data-ttu-id="ac2b2-302">Cerca parentesi non uncinate dopo la parentesi uncinata chiusa; non trova corrispondenze.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-302">Looks for non-angle bracket characters after the right angle bracket; finds no matches.</span></span>|  
|<span data-ttu-id="ac2b2-303">8</span><span class="sxs-lookup"><span data-stu-id="ac2b2-303">8</span></span>|`)+`|<span data-ttu-id="ac2b2-304">Il valore del terzo gruppo acquisito è ">".</span><span class="sxs-lookup"><span data-stu-id="ac2b2-304">The value of the third captured group is ">".</span></span><br /><br /> <span data-ttu-id="ac2b2-305">Il carattere successivo nella stringa di input non è una parentesi uncinata chiusa, pertanto il motore delle espressioni regolari non esegue il loopback al criterio secondario `((?'Close-Open'>)[^<>]*)` .</span><span class="sxs-lookup"><span data-stu-id="ac2b2-305">The next character in the input string is not a right angle bracket, so the regular expression engine does not loop back to the `((?'Close-Open'>)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="ac2b2-306">9</span><span class="sxs-lookup"><span data-stu-id="ac2b2-306">9</span></span>|`)*`|<span data-ttu-id="ac2b2-307">Il valore del primo gruppo acquisito è "\<abc>".</span><span class="sxs-lookup"><span data-stu-id="ac2b2-307">The value of the first captured group is "\<abc>".</span></span><br /><br /> <span data-ttu-id="ac2b2-308">Il carattere successivo nella stringa di input è una parentesi uncinata aperta, pertanto il motore delle espressioni regolari esegue il loopback al criterio secondario `(((?'Open'<)` .</span><span class="sxs-lookup"><span data-stu-id="ac2b2-308">The next character in the input string is a left  angle bracket, so the regular expression engine loops back to the `(((?'Open'<)` subpattern.</span></span>|  
|<span data-ttu-id="ac2b2-309">10</span><span class="sxs-lookup"><span data-stu-id="ac2b2-309">10</span></span>|`(((?'Open'<)`|<span data-ttu-id="ac2b2-310">Trova la corrispondenza della parentesi uncinata aperta in "\<mno" e la assegna al gruppo `Open`.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-310">Matches the left angle bracket in "\<mno" and assigns it to the `Open` group.</span></span> <span data-ttu-id="ac2b2-311">Nella raccolta <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> è ora presente un solo valore, "<".</span><span class="sxs-lookup"><span data-stu-id="ac2b2-311">Its <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collection now has a single value, "<".</span></span>|  
|<span data-ttu-id="ac2b2-312">11</span><span class="sxs-lookup"><span data-stu-id="ac2b2-312">11</span></span>|`[^<>]*`|<span data-ttu-id="ac2b2-313">Trova la corrispondenza con "mno".</span><span class="sxs-lookup"><span data-stu-id="ac2b2-313">Matches "mno".</span></span>|  
|<span data-ttu-id="ac2b2-314">12</span><span class="sxs-lookup"><span data-stu-id="ac2b2-314">12</span></span>|`)+`|<span data-ttu-id="ac2b2-315">"<mno" è il valore del secondo gruppo acquisito.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-315">"<mno" is the value of the second captured group.</span></span><br /><br /> <span data-ttu-id="ac2b2-316">Il carattere successivo nella stringa di input è una parentesi uncinata aperta, pertanto il motore delle espressioni regolari esegue il loopback al criterio secondario `(?'Open'<)[^<>]*)` .</span><span class="sxs-lookup"><span data-stu-id="ac2b2-316">The next character in the input string is an left angle bracket, so the regular expression engine loops back to the `(?'Open'<)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="ac2b2-317">13</span><span class="sxs-lookup"><span data-stu-id="ac2b2-317">13</span></span>|`(((?'Open'<)`|<span data-ttu-id="ac2b2-318">Trova la corrispondenza della parentesi uncinata aperta in "\<xyz>" e la assegna al gruppo `Open`.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-318">Matches the left angle bracket in "\<xyz>" and assigns it to the `Open` group.</span></span> <span data-ttu-id="ac2b2-319">Nella raccolta <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> del gruppo `Open` sono ora incluse due acquisizioni: la parentesi uncinata aperta di "\<mno" e la parentesi uncinata aperta di "\<xyz>".</span><span class="sxs-lookup"><span data-stu-id="ac2b2-319">The <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> collection of the `Open` group now includes two captures: the left angle bracket from "\<mno", and the left angle bracket from "\<xyz>".</span></span>|  
|<span data-ttu-id="ac2b2-320">14</span><span class="sxs-lookup"><span data-stu-id="ac2b2-320">14</span></span>|`[^<>]*`|<span data-ttu-id="ac2b2-321">Trova la corrispondenza con "xyz".</span><span class="sxs-lookup"><span data-stu-id="ac2b2-321">Matches "xyz".</span></span>|  
|<span data-ttu-id="ac2b2-322">15</span><span class="sxs-lookup"><span data-stu-id="ac2b2-322">15</span></span>|`)+`|<span data-ttu-id="ac2b2-323">"<xyz" è il valore del secondo gruppo acquisito.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-323">"<xyz" is the value of the second captured group.</span></span><br /><br /> <span data-ttu-id="ac2b2-324">Il carattere successivo nella stringa di input non è una parentesi uncinata aperta, pertanto il motore delle espressioni regolari non esegue il loopback al criterio secondario `(?'Open'<)[^<>]*)`.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-324">The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the `(?'Open'<)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="ac2b2-325">16</span><span class="sxs-lookup"><span data-stu-id="ac2b2-325">16</span></span>|`((?'Close-Open'>)`|<span data-ttu-id="ac2b2-326">Trova la corrispondenza della parentesi uncinata chiusa in "\<xyz>".</span><span class="sxs-lookup"><span data-stu-id="ac2b2-326">Matches the right angle bracket in "\<xyz>".</span></span> <span data-ttu-id="ac2b2-327">"xyz", assegna la sottostringa tra il gruppo `Open` e la parentesi uncinata chiusa al gruppo `Close` ed elimina il valore corrente dal gruppo `Open`.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-327">"xyz", assigns the substring between the `Open` group and the right angle bracket to the `Close` group, and deletes the current value of the `Open` group.</span></span> <span data-ttu-id="ac2b2-328">Il valore dell'acquisizione precedente (la parentesi uncinata aperta in "\<mno") diventa il valore corrente del gruppo `Open`.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-328">The value of the previous capture (the left angle bracket in "\<mno") becomes the current value of the `Open` group.</span></span> <span data-ttu-id="ac2b2-329">Nella raccolta <xref:System.Text.RegularExpressions.Group.Captures%2A> del gruppo `Open` è ora inclusa una sola acquisizione, ovvero la parentesi uncinata aperta di "\<xyz>".</span><span class="sxs-lookup"><span data-stu-id="ac2b2-329">The <xref:System.Text.RegularExpressions.Group.Captures%2A> collection of the `Open` group now includes a single capture, the left angle bracket from "\<xyz>".</span></span>|  
|<span data-ttu-id="ac2b2-330">17</span><span class="sxs-lookup"><span data-stu-id="ac2b2-330">17</span></span>|`[^<>]*`|<span data-ttu-id="ac2b2-331">Cerca parentesi non uncinate; non trova corrispondenze.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-331">Looks for non-angle bracket characters; finds no matches.</span></span>|  
|<span data-ttu-id="ac2b2-332">18</span><span class="sxs-lookup"><span data-stu-id="ac2b2-332">18</span></span>|`)+`|<span data-ttu-id="ac2b2-333">Il valore del terzo gruppo acquisito è ">".</span><span class="sxs-lookup"><span data-stu-id="ac2b2-333">The value of the third captured group is ">".</span></span><br /><br /> <span data-ttu-id="ac2b2-334">Il carattere successivo nella stringa di input è una parentesi uncinata chiusa, pertanto il motore delle espressioni regolari esegue il loopback al criterio secondario `((?'Close-Open'>)[^<>]*)` .</span><span class="sxs-lookup"><span data-stu-id="ac2b2-334">The next character in the input string is a right angle bracket, so the regular expression engine loops back to the `((?'Close-Open'>)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="ac2b2-335">19</span><span class="sxs-lookup"><span data-stu-id="ac2b2-335">19</span></span>|`((?'Close-Open'>)`|<span data-ttu-id="ac2b2-336">Trova la corrispondenza della parentesi uncinata chiusa finale in "xyz>>", assegna "mno\<xyz>" (la sottostringa tra il gruppo `Open` e la parentesi uncinata chiusa) al gruppo `Close` ed elimina il valore corrente del gruppo `Open`.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-336">Matches the final right angle bracket in "xyz>>", assigns "mno\<xyz>" (the substring between the `Open` group and the right angle bracket) to the `Close` group, and deletes the current value of the `Open` group.</span></span> <span data-ttu-id="ac2b2-337">Il gruppo `Open` è ora vuoto.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-337">The `Open` group is now empty.</span></span>|  
|<span data-ttu-id="ac2b2-338">20</span><span class="sxs-lookup"><span data-stu-id="ac2b2-338">20</span></span>|`[^<>]*`|<span data-ttu-id="ac2b2-339">Cerca parentesi non uncinate; non trova corrispondenze.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-339">Looks for non-angle bracket characters; finds no matches.</span></span>|  
|<span data-ttu-id="ac2b2-340">21</span><span class="sxs-lookup"><span data-stu-id="ac2b2-340">21</span></span>|`)+`|<span data-ttu-id="ac2b2-341">Il valore del terzo gruppo acquisito è ">".</span><span class="sxs-lookup"><span data-stu-id="ac2b2-341">The value of the third captured group is ">".</span></span><br /><br /> <span data-ttu-id="ac2b2-342">Il carattere successivo nella stringa di input non è una parentesi uncinata chiusa, pertanto il motore delle espressioni regolari non esegue il loopback al criterio secondario `((?'Close-Open'>)[^<>]*)` .</span><span class="sxs-lookup"><span data-stu-id="ac2b2-342">The next character in the input string is not a right angle bracket, so the regular expression engine does not loop back to the `((?'Close-Open'>)[^<>]*)` subpattern.</span></span>|  
|<span data-ttu-id="ac2b2-343">22</span><span class="sxs-lookup"><span data-stu-id="ac2b2-343">22</span></span>|`)*`|<span data-ttu-id="ac2b2-344">Il valore del primo gruppo acquisito è "<mno\<xyz>>".</span><span class="sxs-lookup"><span data-stu-id="ac2b2-344">The value of the first captured group is "<mno\<xyz>>".</span></span><br /><br /> <span data-ttu-id="ac2b2-345">Il carattere successivo nella stringa di input non è una parentesi uncinata aperta, pertanto il motore delle espressioni regolari non esegue il loopback al criterio secondario `(((?'Open'<)`.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-345">The next character in the input string is not a left angle bracket, so the regular expression engine does not loop back to the `(((?'Open'<)` subpattern.</span></span>|  
|<span data-ttu-id="ac2b2-346">23</span><span class="sxs-lookup"><span data-stu-id="ac2b2-346">23</span></span>|`(?(Open)(?!))`|<span data-ttu-id="ac2b2-347">Il gruppo `Open` non è definito, pertanto non viene tentato di trovare corrispondenze.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-347">The `Open` group is not defined, so no match is attempted.</span></span>|  
|<span data-ttu-id="ac2b2-348">24</span><span class="sxs-lookup"><span data-stu-id="ac2b2-348">24</span></span>|`$`|<span data-ttu-id="ac2b2-349">Trova la corrispondenza della fine della stringa di input.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-349">Matches the end of the input string.</span></span>|  
  
<a name="noncapturing_group"></a>
## <a name="noncapturing-groups"></a><span data-ttu-id="ac2b2-350">Gruppi di non acquisizione</span><span class="sxs-lookup"><span data-stu-id="ac2b2-350">Noncapturing Groups</span></span>  
 <span data-ttu-id="ac2b2-351">Nel costrutto di raggruppamento seguente non viene acquisita la sottostringa quando viene trovata una corrispondenza con una sottoespressione:</span><span class="sxs-lookup"><span data-stu-id="ac2b2-351">The following grouping construct does not capture the substring that is matched by a subexpression:</span></span>  
  
`(?:subexpression)`
  
 <span data-ttu-id="ac2b2-352">dove *sottoespressione* è un qualsiasi criterio di espressioni regolari valido.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-352">where *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="ac2b2-353">Il costrutto del gruppo non di acquisizione viene generalmente usato quando un quantificatore è applicato a un gruppo, ma le sottostringhe acquisite dal gruppo non sono di alcun interesse.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-353">The noncapturing group construct is typically used when a quantifier is applied to a group, but the substrings captured by the group are of no interest.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="ac2b2-354">Se un'espressione regolare include costrutti di raggruppamento annidati, un costrutto del gruppo di non acquisizione esterno non si applica ai costrutti del gruppo annidati interni.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-354">If a regular expression includes nested grouping constructs, an outer noncapturing group construct does not apply to the inner nested group constructs.</span></span>  
  
 <span data-ttu-id="ac2b2-355">Nell'esempio seguente viene illustrata un'espressione regolare che include gruppi di non acquisizione.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-355">The following example illustrates a regular expression that includes noncapturing groups.</span></span> <span data-ttu-id="ac2b2-356">Si noti che nell'output non sono inclusi gruppi acquisiti.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-356">Note that the output does not include any captured groups.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#5](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/noncapture1.cs#5)]
 [!code-vb[RegularExpressions.Language.Grouping#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/noncapture1.vb#5)]  
  
 <span data-ttu-id="ac2b2-357">L'espressione regolare `(?:\b(?:\w+)\W*)+\.` trova la corrispondenza di una frase che termina con un punto.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-357">The regular expression `(?:\b(?:\w+)\W*)+\.` matches a sentence that is terminated by a period.</span></span> <span data-ttu-id="ac2b2-358">Poiché l'espressione regolare si concentra sulle frasi e non sulle singole parole, i costrutti di raggruppamento vengono usati esclusivamente come quantificatori.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-358">Because the regular expression focuses on sentences and not on individual words, grouping constructs are used exclusively as quantifiers.</span></span> <span data-ttu-id="ac2b2-359">Il criterio di ricerca di espressioni regolari viene interpretato come illustrato nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-359">The regular expression pattern is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="ac2b2-360">Modello</span><span class="sxs-lookup"><span data-stu-id="ac2b2-360">Pattern</span></span>|<span data-ttu-id="ac2b2-361">Descrizione</span><span class="sxs-lookup"><span data-stu-id="ac2b2-361">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="ac2b2-362">Inizia la corrispondenza sul confine di parola.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-362">Begin the match at a word boundary.</span></span>|  
|`(?:\w+)`|<span data-ttu-id="ac2b2-363">Trova la corrispondenza di uno o più caratteri alfanumerici.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-363">Match one or more word characters.</span></span> <span data-ttu-id="ac2b2-364">Non assegna il testo corrispondente a un gruppo acquisito.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-364">Do not assign the matched text to a captured group.</span></span>|  
|`\W*`|<span data-ttu-id="ac2b2-365">Trova la corrispondenza di zero o più caratteri non alfanumerici.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-365">Match zero or more non-word characters.</span></span>|  
|`(?:\b(?:\w+)\W*)+`|<span data-ttu-id="ac2b2-366">Trova la corrispondenza con il criterio di ricerca di uno o più caratteri alfanumerici a partire dal confine di una parola, seguiti da zero o più caratteri non alfanumerici, una o più volte.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-366">Match the pattern of one or more word characters starting at a word boundary, followed by zero or more non-word characters, one or more times.</span></span> <span data-ttu-id="ac2b2-367">Non assegna il testo corrispondente a un gruppo acquisito.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-367">Do not assign the matched text to a captured group.</span></span>|  
|`\.`|<span data-ttu-id="ac2b2-368">Trova la corrispondenza con un punto.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-368">Match a period.</span></span>|  
  
<a name="group_options"></a>
## <a name="group-options"></a><span data-ttu-id="ac2b2-369">Opzioni di gruppo</span><span class="sxs-lookup"><span data-stu-id="ac2b2-369">Group Options</span></span>  
 <span data-ttu-id="ac2b2-370">Il costrutto di raggruppamento applica o disabilita le opzioni specificate all'interno di una sottoespressione:</span><span class="sxs-lookup"><span data-stu-id="ac2b2-370">The following grouping construct applies or disables the specified options within a subexpression:</span></span>  
  
 <span data-ttu-id="ac2b2-371">`(?imnsx-imnsx:` *sottoespressione* `)`</span><span class="sxs-lookup"><span data-stu-id="ac2b2-371">`(?imnsx-imnsx:` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="ac2b2-372">dove *sottoespressione* è un qualsiasi criterio di espressioni regolari valido.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-372">where *subexpression* is any valid regular expression pattern.</span></span> <span data-ttu-id="ac2b2-373">Ad esempio, `(?i-s:)` disattiva la differenziazione tra maiuscole e minuscole e disabilita la modalità riga singola.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-373">For example, `(?i-s:)` turns on case insensitivity and disables single-line mode.</span></span> <span data-ttu-id="ac2b2-374">Per altre informazioni sulle opzioni inline che è possibile specificare, vedere [Opzioni di espressioni regolari](../../../docs/standard/base-types/regular-expression-options.md).</span><span class="sxs-lookup"><span data-stu-id="ac2b2-374">For more information about the inline options you can specify, see [Regular Expression Options](../../../docs/standard/base-types/regular-expression-options.md).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="ac2b2-375">È possibile specificare opzioni che si applicano a un'espressione regolare intera anziché a una sottoespressione usando un costruttore della classe <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> o un metodo statico.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-375">You can specify options that apply to an entire regular expression rather than a subexpression by using a <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> class constructor or a static method.</span></span> <span data-ttu-id="ac2b2-376">È possibile specificare anche opzioni inline che si applicano dopo un punto specifico in un'espressione regolare usando il costrutto di linguaggio `(?imnsx-imnsx)` .</span><span class="sxs-lookup"><span data-stu-id="ac2b2-376">You can also specify inline options that apply after a specific point in a regular expression by using the `(?imnsx-imnsx)` language construct.</span></span>  
  
 <span data-ttu-id="ac2b2-377">Il costrutto delle opzioni di gruppo non è un gruppo di acquisizione.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-377">The group options construct is not a capturing group.</span></span> <span data-ttu-id="ac2b2-378">Ovvero, sebbene qualsiasi parte di una stringa acquisita dalla *sottoespressione* sia inclusa nella corrispondenza, non viene inclusa in un gruppo acquisito né usata per popolare l'oggetto <xref:System.Text.RegularExpressions.GroupCollection> .</span><span class="sxs-lookup"><span data-stu-id="ac2b2-378">That is, although any portion of a string that is captured by *subexpression* is included in the match, it is not included in a captured group nor used to populate the <xref:System.Text.RegularExpressions.GroupCollection> object.</span></span>  
  
 <span data-ttu-id="ac2b2-379">Ad esempio, l'espressione regolare `\b(?ix: d \w+)\s` nell'esempio seguente usa opzioni inline in un costrutto di raggruppamento per abilitare la corrispondenza senza distinzione tra maiuscole e minuscole e per ignorare gli spazi nel criterio durante l'identificazione delle parole che iniziano con la lettera "d".</span><span class="sxs-lookup"><span data-stu-id="ac2b2-379">For example, the regular expression `\b(?ix: d \w+)\s` in the following example uses inline options in a grouping construct to enable case-insensitive matching and ignore pattern white space in identifying all words that begin with the letter "d".</span></span> <span data-ttu-id="ac2b2-380">L'espressione regolare è definita nel modo illustrato nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-380">The regular expression is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="ac2b2-381">Modello</span><span class="sxs-lookup"><span data-stu-id="ac2b2-381">Pattern</span></span>|<span data-ttu-id="ac2b2-382">Descrizione</span><span class="sxs-lookup"><span data-stu-id="ac2b2-382">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="ac2b2-383">Inizia la corrispondenza sul confine di parola.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-383">Begin the match at a word boundary.</span></span>|  
|`(?ix: d \w+)`|<span data-ttu-id="ac2b2-384">Usando la corrispondenza senza distinzione tra maiuscole e minuscole e ignorando lo spazio vuoto in questo criterio, trova la corrispondenza con una "d" seguita da uno o più caratteri alfanumerici.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-384">Using case-insensitive matching and ignoring white space in this pattern, match a "d" followed by one or more word characters.</span></span>|  
|`\s`|<span data-ttu-id="ac2b2-385">Trova la corrispondenza con uno spazio vuoto.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-385">Match a white-space character.</span></span>|  
  
 [!code-csharp[Conceptual.Regex.Language.Options#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/example1.cs#8)]
 [!code-vb[Conceptual.Regex.Language.Options#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/example1.vb#8)]  
  
<a name="zerowidth_positive_lookahead_assertion"></a>
## <a name="zero-width-positive-lookahead-assertions"></a><span data-ttu-id="ac2b2-386">Asserzioni lookahead positive di larghezza zero</span><span class="sxs-lookup"><span data-stu-id="ac2b2-386">Zero-Width Positive Lookahead Assertions</span></span>  
 <span data-ttu-id="ac2b2-387">Il costrutto di raggruppamento seguente definisce un'asserzione lookbehind positiva di larghezza zero:</span><span class="sxs-lookup"><span data-stu-id="ac2b2-387">The following grouping construct defines a zero-width positive lookahead assertion:</span></span>  
  
 <span data-ttu-id="ac2b2-388">`(?=` *sottoespressione* `)`</span><span class="sxs-lookup"><span data-stu-id="ac2b2-388">`(?=` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="ac2b2-389">dove *sottoespressione* è un qualsiasi criterio di espressioni regolari.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-389">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="ac2b2-390">Per trovare una corrispondenza, la stringa di input deve corrispondere al criterio di ricerca di espressioni regolari in *sottoespressione*, sebbene la sottostringa corrispondente non venga inclusa nel risultato della corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-390">For a match to be successful, the input string must match the regular expression pattern in *subexpression*, although the matched substring is not included in the match result.</span></span> <span data-ttu-id="ac2b2-391">Un'asserzione lookahead positiva di larghezza zero non esegue il backtracking.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-391">A zero-width positive lookahead assertion does not backtrack.</span></span>  
  
 <span data-ttu-id="ac2b2-392">In genere, un'asserzione lookahead positiva di larghezza zero viene trovata alla fine di un criterio di ricerca di espressioni regolari</span><span class="sxs-lookup"><span data-stu-id="ac2b2-392">Typically, a zero-width positive lookahead assertion is found at the end of a regular expression pattern.</span></span> <span data-ttu-id="ac2b2-393">Definisce una sottostringa che deve essere trovata alla fine di una stringa affinché venga stabilita una corrispondenza ma che non deve essere inclusa nella corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-393">It defines a substring that must be found at the end of a string for a match to occur but that should not be included in the match.</span></span> <span data-ttu-id="ac2b2-394">È anche utile per impedire un backtracking eccessivo.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-394">It is also useful for preventing excessive backtracking.</span></span> <span data-ttu-id="ac2b2-395">È possibile usare un'asserzione lookahead positiva di larghezza zero per assicurarsi che un particolare gruppo acquisito inizi con il testo che corrisponde a un subset del criterio definito per tale gruppo acquisito.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-395">You can use a zero-width positive lookahead assertion to ensure that a particular captured group begins with text that matches a subset of the pattern defined for that captured group.</span></span> <span data-ttu-id="ac2b2-396">Se, ad esempio, viene trovata la corrispondenza di un gruppo di acquisizioni con caratteri alfanumerici consecutivi, è possibile usare un'asserzione positiva lookahead di larghezza zero per richiedere che il primo carattere sia un carattere alfabetico maiuscolo.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-396">For example, if a capturing group matches consecutive word characters, you can use a zero-width positive lookahead assertion to require that the first character be an alphabetical uppercase character.</span></span>  
  
 <span data-ttu-id="ac2b2-397">Nell'esempio seguente viene usata un'asserzione lookahead positiva di larghezza zero per trovare la corrispondenza con la parola che precede il verbo "is" nella stringa di input.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-397">The following example uses a zero-width positive lookahead assertion to match the word that precedes the verb "is" in the input string.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#6](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/lookahead1.cs#6)]
 [!code-vb[RegularExpressions.Language.Grouping#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/lookahead1.vb#6)]  
  
 <span data-ttu-id="ac2b2-398">L'espressione regolare `\b\w+(?=\sis\b)` viene interpretata come illustrato nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-398">The regular expression `\b\w+(?=\sis\b)` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="ac2b2-399">Modello</span><span class="sxs-lookup"><span data-stu-id="ac2b2-399">Pattern</span></span>|<span data-ttu-id="ac2b2-400">Descrizione</span><span class="sxs-lookup"><span data-stu-id="ac2b2-400">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="ac2b2-401">Inizia la corrispondenza sul confine di parola.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-401">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="ac2b2-402">Trova la corrispondenza di uno o più caratteri alfanumerici.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-402">Match one or more word characters.</span></span>|  
|`(?=\sis\b)`|<span data-ttu-id="ac2b2-403">Determina se i caratteri alfanumerici vengono seguiti da uno spazio vuoto e dalla stringa "is", che termina su un confine di parola.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-403">Determine whether the word characters are followed by a white-space character and the string "is", which ends on a word boundary.</span></span> <span data-ttu-id="ac2b2-404">In tal caso, la corrispondenza ha esito positivo.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-404">If so, the match is successful.</span></span>|  
  
<a name="zerowidth_negative_lookahead_assertion"></a>
## <a name="zero-width-negative-lookahead-assertions"></a><span data-ttu-id="ac2b2-405">Asserzioni lookahead negative di larghezza zero</span><span class="sxs-lookup"><span data-stu-id="ac2b2-405">Zero-Width Negative Lookahead Assertions</span></span>  
 <span data-ttu-id="ac2b2-406">Nel costrutto di raggruppamento seguente viene definita un'asserzione lookahead negativa di larghezza zero:</span><span class="sxs-lookup"><span data-stu-id="ac2b2-406">The following grouping construct defines a zero-width negative lookahead assertion:</span></span>  
  
 <span data-ttu-id="ac2b2-407">`(?!` *sottoespressione* `)`</span><span class="sxs-lookup"><span data-stu-id="ac2b2-407">`(?!` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="ac2b2-408">dove *sottoespressione* è un qualsiasi criterio di espressioni regolari.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-408">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="ac2b2-409">Per trovare una corrispondenza, la stringa di input non deve corrispondere al criterio di ricerca di espressioni regolari in *sottoespressione*, sebbene la stringa corrispondente non venga inclusa nel risultato della corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-409">For the match to be successful, the input string must not match the regular expression pattern in *subexpression*, although the matched string is not included in the match result.</span></span>  
  
 <span data-ttu-id="ac2b2-410">Un'asserzione lookahead negativa di larghezza zero viene usata in genere all'inizio o alla fine di un'espressione regolare.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-410">A zero-width negative lookahead assertion is typically used either at the beginning or at the end of a regular expression.</span></span> <span data-ttu-id="ac2b2-411">All'inizio di un'espressione regolare, può definire un criterio specifico per il quale non deve essere trovata una corrispondenza quando l'inizio dell'espressione regolare definisce un criterio simile ma più generale per cui stabilire la corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-411">At the beginning of a regular expression, it can define a specific pattern that should not be matched when the beginning of the regular expression defines a similar but more general pattern to be matched.</span></span> <span data-ttu-id="ac2b2-412">In questo caso, viene spesso usata per limitare il backtracking.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-412">In this case, it is often used to limit backtracking.</span></span> <span data-ttu-id="ac2b2-413">Alla fine di un'espressione regolare, può definire una sottoespressione che non può verificarsi alla fine di una corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-413">At the end of a regular expression, it can define a subexpression that cannot occur at the end of a match.</span></span>  
  
 <span data-ttu-id="ac2b2-414">Nell'esempio seguente viene definita un'espressione regolare che usa un'asserzione lookahead di larghezza zero all'inizio dell'espressione regolare per trovare la corrispondenza con parole che non iniziano con "un".</span><span class="sxs-lookup"><span data-stu-id="ac2b2-414">The following example defines a regular expression that uses a zero-width lookahead assertion at the beginning of the regular expression to match words that do not begin with "un".</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#7](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/negativelookahead1.cs#7)]
 [!code-vb[RegularExpressions.Language.Grouping#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/negativelookahead1.vb#7)]  
  
 <span data-ttu-id="ac2b2-415">L'espressione regolare `\b(?!un)\w+\b` viene interpretata come illustrato nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-415">The regular expression `\b(?!un)\w+\b` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="ac2b2-416">Modello</span><span class="sxs-lookup"><span data-stu-id="ac2b2-416">Pattern</span></span>|<span data-ttu-id="ac2b2-417">Descrizione</span><span class="sxs-lookup"><span data-stu-id="ac2b2-417">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="ac2b2-418">Inizia la corrispondenza sul confine di parola.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-418">Begin the match at a word boundary.</span></span>|  
|`(?!un)`|<span data-ttu-id="ac2b2-419">Determina se i due caratteri successivi sono "un".</span><span class="sxs-lookup"><span data-stu-id="ac2b2-419">Determine whether the next two characters are "un".</span></span> <span data-ttu-id="ac2b2-420">Se non lo sono, è possibile stabilire la corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-420">If they are not, a match is possible.</span></span>|  
|`\w+`|<span data-ttu-id="ac2b2-421">Trova la corrispondenza di uno o più caratteri alfanumerici.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-421">Match one or more word characters.</span></span>|  
|`\b`|<span data-ttu-id="ac2b2-422">Termina la corrispondenza sul confine di parola.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-422">End the match at a word boundary.</span></span>|  
  
 <span data-ttu-id="ac2b2-423">Nell'esempio seguente viene definita un'espressione regolare che usa un'asserzione lookahead di larghezza zero alla fine dell'espressione regolare per trovare la corrispondenza con parole che non terminano con un carattere di punteggiatura.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-423">The following example defines a regular expression that uses a zero-width lookahead assertion at the end of the regular expression to match words that do not end with a punctuation character.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#8](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/negativelookahead2.cs#8)]
 [!code-vb[RegularExpressions.Language.Grouping#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/negativelookahead2.vb#8)]  
  
 <span data-ttu-id="ac2b2-424">L'espressione regolare `\b\w+\b(?!\p{P})` viene interpretata come illustrato nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-424">The regular expression `\b\w+\b(?!\p{P})` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="ac2b2-425">Modello</span><span class="sxs-lookup"><span data-stu-id="ac2b2-425">Pattern</span></span>|<span data-ttu-id="ac2b2-426">Descrizione</span><span class="sxs-lookup"><span data-stu-id="ac2b2-426">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="ac2b2-427">Inizia la corrispondenza sul confine di parola.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-427">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="ac2b2-428">Trova la corrispondenza di uno o più caratteri alfanumerici.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-428">Match one or more word characters.</span></span>|  
|`\b`|<span data-ttu-id="ac2b2-429">Termina la corrispondenza sul confine di parola.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-429">End the match at a word boundary.</span></span>|  
|`\p{P})`|<span data-ttu-id="ac2b2-430">Se il carattere successivo non è un simbolo di punteggiatura (quale un punto o una virgola), la corrispondenza ha esito positivo.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-430">If the next character is not a punctuation symbol (such as a period or a comma), the match succeeds.</span></span>|  
  
<a name="zerowidth_positive_lookbehind_assertion"></a>
## <a name="zero-width-positive-lookbehind-assertions"></a><span data-ttu-id="ac2b2-431">Asserzioni lookbehind positive di larghezza zero</span><span class="sxs-lookup"><span data-stu-id="ac2b2-431">Zero-Width Positive Lookbehind Assertions</span></span>  
 <span data-ttu-id="ac2b2-432">Nel costrutto di raggruppamento seguente viene definita un'asserzione lookbehind positiva di larghezza zero:</span><span class="sxs-lookup"><span data-stu-id="ac2b2-432">The following grouping construct defines a zero-width positive lookbehind assertion:</span></span>  
  
 <span data-ttu-id="ac2b2-433">`(?<=` *sottoespressione* `)`</span><span class="sxs-lookup"><span data-stu-id="ac2b2-433">`(?<=` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="ac2b2-434">dove *sottoespressione* è un qualsiasi criterio di espressioni regolari.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-434">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="ac2b2-435">Per trovare una corrispondenza, *sottoespressione* deve trovarsi nella stringa di input a sinistra della posizione corrente, sebbene `subexpression` non sia incluso nel risultato della corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-435">For a match to be successful, *subexpression* must occur at the input string to the left of the current position, although `subexpression` is not included in the match result.</span></span> <span data-ttu-id="ac2b2-436">Un'asserzione lookbehind positiva di larghezza zero non esegue il backtracking.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-436">A zero-width positive lookbehind assertion does not backtrack.</span></span>  
  
 <span data-ttu-id="ac2b2-437">Le asserzioni lookbehind positive di larghezza zero vengono usate in genere all'inizio delle espressioni regolari.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-437">Zero-width positive lookbehind assertions are typically used at the beginning of regular expressions.</span></span> <span data-ttu-id="ac2b2-438">Il criterio definito è una precondizione per una corrispondenza, anche se non fa parte del risultato della corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-438">The pattern that they define is a precondition for a match, although it is not a part of the match result.</span></span>  
  
 <span data-ttu-id="ac2b2-439">Ad esempio, nell'esempio seguente viene cercata la corrispondenza con le ultime due cifre dell'anno per il ventunesimo secolo ovvero, richiede che la cifra "20" preceda la stringa corrispondente.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-439">For example, the following example matches the last two digits of the year for the twenty first century (that is, it requires that the digits "20" precede the matched string).</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#9](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/lookbehind1.cs#9)]
 [!code-vb[RegularExpressions.Language.Grouping#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/lookbehind1.vb#9)]  
  
 <span data-ttu-id="ac2b2-440">Il criterio di espressione regolare `(?<=\b20)\d{2}\b` è interpretato nel modo illustrato nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-440">The regular expression pattern `(?<=\b20)\d{2}\b` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="ac2b2-441">Modello</span><span class="sxs-lookup"><span data-stu-id="ac2b2-441">Pattern</span></span>|<span data-ttu-id="ac2b2-442">Descrizione</span><span class="sxs-lookup"><span data-stu-id="ac2b2-442">Description</span></span>|  
|-------------|-----------------|  
|`\d{2}`|<span data-ttu-id="ac2b2-443">Trova la corrispondenza con due cifre decimali.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-443">Match two decimal digits.</span></span>|  
|`(?<=\b20)`|<span data-ttu-id="ac2b2-444">Continua la corrispondenza per verificare se le due cifre decimali sono precedute dalle cifre decimali "20" su un confine di parola.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-444">Continue the match if the two decimal digits are preceded by the decimal digits "20" on a word boundary.</span></span>|  
|`\b`|<span data-ttu-id="ac2b2-445">Termina la corrispondenza sul confine di parola.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-445">End the match at a word boundary.</span></span>|  
  
 <span data-ttu-id="ac2b2-446">Le asserzioni lookbehind positive di larghezza zero vengono usate anche per limitare il backtracking quando l'ultimo carattere o gli ultimi caratteri in un gruppo acquisito devono essere costituiti da un subset di caratteri corrispondenti al criterio di ricerca di espressioni regolari di tale gruppo.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-446">Zero-width positive lookbehind assertions are also used to limit backtracking when the last character or characters in a captured group must be a subset of the characters that match that group's regular expression pattern.</span></span> <span data-ttu-id="ac2b2-447">Se, ad esempio, un gruppo acquisisce tutti i caratteri alfanumerici consecutivi, è possibile usare un'asserzione positiva lookbehind di larghezza zero per richiedere che l'ultimo carattere sia un carattere alfabetico.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-447">For example, if a group captures all consecutive word characters, you can use a zero-width positive lookbehind assertion to require that the last character be alphabetical.</span></span>  
  
<a name="zerowidth_negative_lookbehind_assertion"></a>
## <a name="zero-width-negative-lookbehind-assertions"></a><span data-ttu-id="ac2b2-448">Asserzioni lookbehind negative di larghezza zero</span><span class="sxs-lookup"><span data-stu-id="ac2b2-448">Zero-Width Negative Lookbehind Assertions</span></span>  
 <span data-ttu-id="ac2b2-449">Nel costrutto di raggruppamento seguente viene definita un'asserzione lookbehind negativa di larghezza zero:</span><span class="sxs-lookup"><span data-stu-id="ac2b2-449">The following grouping construct defines a zero-width negative lookbehind assertion:</span></span>  
  
 <span data-ttu-id="ac2b2-450">`(?<!` *sottoespressione* `)`</span><span class="sxs-lookup"><span data-stu-id="ac2b2-450">`(?<!` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="ac2b2-451">dove *sottoespressione* è un qualsiasi criterio di espressioni regolari.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-451">where *subexpression* is any regular expression pattern.</span></span> <span data-ttu-id="ac2b2-452">Per trovare una corrispondenza, la *sottoespressione* non deve trovarsi nella stringa di input a sinistra della posizione corrente.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-452">For a match to be successful, *subexpression* must not occur at the input string to the left of the current position.</span></span> <span data-ttu-id="ac2b2-453">Tuttavia, qualsiasi sottostringa che non corrisponde a `subexpression` non viene inclusa nel risultato della corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-453">However, any substring that does not match `subexpression` is not included in the match result.</span></span>  
  
 <span data-ttu-id="ac2b2-454">Le asserzioni lookbehind negative di larghezza zero vengono usate in genere all'inizio delle espressioni regolari.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-454">Zero-width negative lookbehind assertions are typically used at the beginning of regular expressions.</span></span> <span data-ttu-id="ac2b2-455">Il criterio definito preclude una corrispondenza nella stringa che segue.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-455">The pattern that they define precludes a match in the string that follows.</span></span> <span data-ttu-id="ac2b2-456">Queste asserzioni vengono usate anche per limitare il backtracking quando l'ultimo carattere o gli ultimi caratteri in un gruppo acquisito non devono essere costituiti da uno o più caratteri corrispondenti al criterio di ricerca di espressioni regolari di tale gruppo.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-456">They are also used to limit backtracking when the last character or characters in a captured group must not be one or more of the characters that match that group's regular expression pattern.</span></span> <span data-ttu-id="ac2b2-457">Ad esempio, se un gruppo acquisisce tutti i caratteri alfanumerici consecutivi, è possibile usare un'asserzione positiva lookbehind di larghezza zero per richiedere che l'ultimo carattere non sia un carattere di sottolineatura (\_).</span><span class="sxs-lookup"><span data-stu-id="ac2b2-457">For example, if a group captures all consecutive word characters, you can use a zero-width positive lookbehind assertion to require that the last character not be an underscore (\_).</span></span>  
  
 <span data-ttu-id="ac2b2-458">Nell'esempio seguente viene cercata la corrispondenza della data per qualsiasi giorno della settimana diverso da un fine settimana (ovvero, che non è né sabato né domenica).</span><span class="sxs-lookup"><span data-stu-id="ac2b2-458">The following example matches the date for any day of the week that is not a weekend (that is, that is neither Saturday nor Sunday).</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#10](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/negativelookbehind1.cs#10)]
 [!code-vb[RegularExpressions.Language.Grouping#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/negativelookbehind1.vb#10)]  
  
 <span data-ttu-id="ac2b2-459">Il criterio di espressione regolare `(?<!(Saturday|Sunday) )\b\w+ \d{1,2}, \d{4}\b` è interpretato nel modo illustrato nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-459">The regular expression pattern `(?<!(Saturday|Sunday) )\b\w+ \d{1,2}, \d{4}\b` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="ac2b2-460">Modello</span><span class="sxs-lookup"><span data-stu-id="ac2b2-460">Pattern</span></span>|<span data-ttu-id="ac2b2-461">Descrizione</span><span class="sxs-lookup"><span data-stu-id="ac2b2-461">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="ac2b2-462">Inizia la corrispondenza sul confine di parola.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-462">Begin the match at a word boundary.</span></span>|  
|`\w+`|<span data-ttu-id="ac2b2-463">Trova la corrispondenza con uno o più caratteri alfanumerici seguiti da uno spazio vuoto.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-463">Match one or more word characters followed by a white-space character.</span></span>|  
|`\d{1,2},`|<span data-ttu-id="ac2b2-464">Trova la corrispondenza con una o due cifre digitali seguite da uno spazio vuoto e da una virgola.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-464">Match either one or two decimal digits followed by a white-space character and a comma.</span></span>|  
|`\d{4}\b`|<span data-ttu-id="ac2b2-465">Trova la corrispondenza di quattro cifre digitali e termina la corrispondenza sul confine di parola.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-465">Match four decimal digits, and end the match at a word boundary.</span></span>|  
|<code>(?<!(Saturday&#124;Sunday) )</code>|<span data-ttu-id="ac2b2-466">Se la corrispondenza viene preceduta da un elemento diverso dalle stringhe "Saturday" o "Sunday" seguito da uno spazio, la corrispondenza ha esito positivo.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-466">If the match is preceded by something other than the strings "Saturday" or "Sunday" followed by a space, the match is successful.</span></span>|  
  
<a name="atomic_groups"></a>
## <a name="atomic-groups"></a><span data-ttu-id="ac2b2-467">Gruppi atomici</span><span class="sxs-lookup"><span data-stu-id="ac2b2-467">Atomic groups</span></span>  
 <span data-ttu-id="ac2b2-468">Il costrutto di raggruppamento seguente rappresenta un gruppo atomico (noto in altri motori delle espressioni regolari come sottoespressione non di backtracking, una sottoespressione atomica o una sottoespressione solo una volta):</span><span class="sxs-lookup"><span data-stu-id="ac2b2-468">The following grouping construct represents an atomic group (known in some other regular expression engines as a nonbacktracking subexpression, an atomic subexpression, or a once-only subexpression):</span></span>
  
 <span data-ttu-id="ac2b2-469">`(?>` *sottoespressione* `)`</span><span class="sxs-lookup"><span data-stu-id="ac2b2-469">`(?>` *subexpression* `)`</span></span>  
  
 <span data-ttu-id="ac2b2-470">dove *sottoespressione* è un qualsiasi criterio di espressioni regolari.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-470">where *subexpression* is any regular expression pattern.</span></span>  
  
 <span data-ttu-id="ac2b2-471">Normalmente, se un'espressione regolare include un criterio di ricerca facoltativo o alternativo e una corrispondenza ha esito negativo, il motore delle espressioni regolari può creare un ramo in più direzioni per trovare la corrispondenza di una stringa di input con un criterio.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-471">Ordinarily, if a regular expression includes an optional or alternative matching pattern and a match does not succeed, the regular expression engine can branch in multiple directions to match an input string with a pattern.</span></span> <span data-ttu-id="ac2b2-472">Se non viene trovata una corrispondenza quando viene esaminato il primo ramo, il motore delle espressioni regolari può tornare, o eseguire il backtracking, al punto in cui ha trovato la prima corrispondenza e tenta la corrispondenza usando il secondo ramo.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-472">If a match is not found when it takes the first branch, the regular expression engine can back up or backtrack to the point where it took the first match and attempt the match using the second branch.</span></span> <span data-ttu-id="ac2b2-473">Questo processo può continuare fino a che non sono stati provati tutti i rami.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-473">This process can continue until all branches have been tried.</span></span>  
  
 <span data-ttu-id="ac2b2-474">Il gruppo `(?>`*sottoespressione*`)` disabilita il backtracking.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-474">The `(?>`*subexpression*`)` language construct disables backtracking.</span></span> <span data-ttu-id="ac2b2-475">Il motore delle espressioni regolari troverà la corrispondenza con il numero massimo possibile di caratteri nella stringa di input.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-475">The regular expression engine will match as many characters in the input string as it can.</span></span> <span data-ttu-id="ac2b2-476">Quando non sarà più possibile trovare altre corrispondenze, non eseguirà il backtracking per trovare corrispondenze alternative con i criteri.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-476">When no further match is possible, it will not backtrack to attempt alternate pattern matches.</span></span> <span data-ttu-id="ac2b2-477">Viene pertanto trovata la corrispondenza della sottoespressione solo con stringhe corrispondenti esclusivamente alla sottoespressione; non tenta di trovare una corrispondenza per una stringa in base alla sottoespressione e a qualsiasi sottoespressione successiva.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-477">(That is, the subexpression matches only strings that would be matched by the subexpression alone; it does not attempt to match a string based on the subexpression and any subexpressions that follow it.)</span></span>  
  
 <span data-ttu-id="ac2b2-478">Questa opzione è consigliata solo se si è certi che il backtracking avrà esito negativo.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-478">This option is recommended if you know that backtracking will not succeed.</span></span> <span data-ttu-id="ac2b2-479">Impedendo al motore delle espressioni regolari di eseguire ricerche non necessarie si registra un miglioramento delle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-479">Preventing the regular expression engine from performing unnecessary searching improves performance.</span></span>  
  
 <span data-ttu-id="ac2b2-480">Nell'esempio seguente viene illustrato il modo in cui un gruppo atomico modifica i risultati di una corrispondenza di criteri.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-480">The following example illustrates how an atomic group modifies the results of a pattern match.</span></span> <span data-ttu-id="ac2b2-481">L'espressione regolare di backtracking trova una corrispondenza per una serie di caratteri ripetuti seguiti da una o più occorrenze dello stesso carattere su un confine di parola, diversamente dall'espressione regolare di non backtracking.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-481">The backtracking regular expression successfully matches a series of repeated characters followed by one more occurrence of the same character on a word boundary, but the nonbacktracking regular expression does not.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#11](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/nonbacktracking1.cs#11)]
 [!code-vb[RegularExpressions.Language.Grouping#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/nonbacktracking1.vb#11)]  
  
 <span data-ttu-id="ac2b2-482">L'espressione regolare di non backtracking `(?>(\w)\1+).\b` è definita nel modo illustrato nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-482">The nonbacktracking regular expression `(?>(\w)\1+).\b` is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="ac2b2-483">Modello</span><span class="sxs-lookup"><span data-stu-id="ac2b2-483">Pattern</span></span>|<span data-ttu-id="ac2b2-484">Descrizione</span><span class="sxs-lookup"><span data-stu-id="ac2b2-484">Description</span></span>|  
|-------------|-----------------|  
|`(\w)`|<span data-ttu-id="ac2b2-485">Trova la corrispondenza di un singolo carattere alfanumerico e la assegna al primo gruppo di acquisizione.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-485">Match a single word character and assign it to the first capturing group.</span></span>|  
|`\1+`|<span data-ttu-id="ac2b2-486">Trova la corrispondenza con il valore della prima sottostringa acquisita una o più volte.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-486">Match the value of the first captured substring one or more times.</span></span>|  
|`.`|<span data-ttu-id="ac2b2-487">Trova la corrispondenza con qualsiasi carattere.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-487">Match any character.</span></span>|  
|`\b`|<span data-ttu-id="ac2b2-488">Termina la corrispondenza sul confine di parola.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-488">End the match on a word boundary.</span></span>|  
|`(?>(\w)\1+)`|<span data-ttu-id="ac2b2-489">Trova una o più occorrenze di un carattere alfanumerico duplicato ma non esegue il backtracking per trovare la corrispondenza con l'ultimo carattere su un confine di parola.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-489">Match one or more occurrences of a duplicated word character, but do not backtrack to match the last character on a word boundary.</span></span>|  
  
<a name="Objects"></a>
## <a name="grouping-constructs-and-regular-expression-objects"></a><span data-ttu-id="ac2b2-490">costrutti di raggruppamento e oggetti delle espressioni regolari</span><span class="sxs-lookup"><span data-stu-id="ac2b2-490">Grouping Constructs and Regular Expression Objects</span></span>  
 <span data-ttu-id="ac2b2-491">Le sottostringhe per cui viene trovata una corrispondenza da parte di un gruppo di acquisizione dell'espressione regolare sono rappresentate da oggetti <xref:System.Text.RegularExpressions.Group?displayProperty=nameWithType> , che possono essere recuperati dall'oggetto <xref:System.Text.RegularExpressions.GroupCollection?displayProperty=nameWithType> restituito dalla proprietà <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="ac2b2-491">Substrings that are matched by a regular expression capturing group are represented by <xref:System.Text.RegularExpressions.Group?displayProperty=nameWithType> objects, which can be retrieved from the <xref:System.Text.RegularExpressions.GroupCollection?displayProperty=nameWithType> object that is returned by the <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="ac2b2-492">L'oggetto <xref:System.Text.RegularExpressions.GroupCollection> è popolato come descritto di seguito:</span><span class="sxs-lookup"><span data-stu-id="ac2b2-492">The <xref:System.Text.RegularExpressions.GroupCollection> object is populated as follows:</span></span>  
  
- <span data-ttu-id="ac2b2-493">Il primo oggetto <xref:System.Text.RegularExpressions.Group> della raccolta (in corrispondenza dell'indice zero) rappresenta l'intera corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-493">The first <xref:System.Text.RegularExpressions.Group> object in the collection (the object at index zero) represents the entire match.</span></span>  
  
- <span data-ttu-id="ac2b2-494">Il set di oggetti <xref:System.Text.RegularExpressions.Group> successivo rappresenta i gruppi di acquisizione non denominati (numerati).</span><span class="sxs-lookup"><span data-stu-id="ac2b2-494">The next set of <xref:System.Text.RegularExpressions.Group> objects represent unnamed (numbered) capturing groups.</span></span> <span data-ttu-id="ac2b2-495">Vengono visualizzati nell'ordine in cui sono definiti nell'espressione regolare, da sinistra a destra.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-495">They appear in the order in which they are defined in the regular expression, from left to right.</span></span> <span data-ttu-id="ac2b2-496">I valori di indice di questi gruppi sono compresi tra 1 e il numero dei gruppi di acquisizione non denominati nella raccolta.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-496">The index values of these groups range from 1 to the number of unnamed capturing groups in the collection.</span></span> <span data-ttu-id="ac2b2-497">L'indice di un gruppo specifico è equivalente al relativo backreference numerato.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-497">(The index of a particular group is equivalent to its numbered backreference.</span></span> <span data-ttu-id="ac2b2-498">Per altre informazioni sui backreference, vedere [Backreference Constructs](../../../docs/standard/base-types/backreference-constructs-in-regular-expressions.md).)</span><span class="sxs-lookup"><span data-stu-id="ac2b2-498">For more information about backreferences, see [Backreference Constructs](../../../docs/standard/base-types/backreference-constructs-in-regular-expressions.md).)</span></span>  
  
- <span data-ttu-id="ac2b2-499">Il set di oggetti <xref:System.Text.RegularExpressions.Group> finale rappresenta i gruppi di acquisizione denominati.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-499">The final set of <xref:System.Text.RegularExpressions.Group> objects represent named capturing groups.</span></span> <span data-ttu-id="ac2b2-500">Vengono visualizzati nell'ordine in cui sono definiti nell'espressione regolare, da sinistra a destra.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-500">They appear in the order in which they are defined in the regular expression, from left to right.</span></span> <span data-ttu-id="ac2b2-501">Il valore di indice del primo gruppo di acquisizione denominato è maggiore di uno rispetto all'ultimo gruppo di acquisizione non denominato.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-501">The index value of the first named capturing group is one greater than the index of the last unnamed capturing group.</span></span> <span data-ttu-id="ac2b2-502">Se l'espressione regolare non contiene gruppi di acquisizione non denominati, il valore di indice del primo gruppo di acquisizione denominato è uno.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-502">If there are no unnamed capturing groups in the regular expression, the index value of the first named capturing group is one.</span></span>  
  
 <span data-ttu-id="ac2b2-503">Se si applica un quantificatore a un gruppo di acquisizione, le proprietà <xref:System.Text.RegularExpressions.Group> , <xref:System.Text.RegularExpressions.Capture.Value%2A?displayProperty=nameWithType>e <xref:System.Text.RegularExpressions.Capture.Index%2A?displayProperty=nameWithType>dell'oggetto <xref:System.Text.RegularExpressions.Capture.Length%2A?displayProperty=nameWithType> corrispondente riflettono l'ultima sottostringa acquisita da un gruppo di acquisizione.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-503">If you apply a quantifier to a capturing group, the corresponding <xref:System.Text.RegularExpressions.Group> object's <xref:System.Text.RegularExpressions.Capture.Value%2A?displayProperty=nameWithType>, <xref:System.Text.RegularExpressions.Capture.Index%2A?displayProperty=nameWithType>, and <xref:System.Text.RegularExpressions.Capture.Length%2A?displayProperty=nameWithType> properties reflect the last substring that is captured by a capturing group.</span></span> <span data-ttu-id="ac2b2-504">È possibile recuperare un set completo di sottostringhe acquisite da gruppi che dispongono di quantificatori dall'oggetto <xref:System.Text.RegularExpressions.CaptureCollection> restituito dalla proprietà <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="ac2b2-504">You can retrieve a complete set of substrings that are captured by groups that have quantifiers from the <xref:System.Text.RegularExpressions.CaptureCollection> object that is returned by the <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="ac2b2-505">Nell'esempio seguente viene illustrata la relazione tra gli oggetti <xref:System.Text.RegularExpressions.Group> e <xref:System.Text.RegularExpressions.Capture> .</span><span class="sxs-lookup"><span data-stu-id="ac2b2-505">The following example clarifies the relationship between the <xref:System.Text.RegularExpressions.Group> and <xref:System.Text.RegularExpressions.Capture> objects.</span></span>  
  
 [!code-csharp[RegularExpressions.Language.Grouping#4](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.language.grouping/cs/objectmodel1.cs#4)]
 [!code-vb[RegularExpressions.Language.Grouping#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.language.grouping/vb/objectmodel1.vb#4)]  
  
 <span data-ttu-id="ac2b2-506">Il criterio di ricerca di espressioni regolari `(\b(\w+)\W+)+` estrae singole parole da una stringa</span><span class="sxs-lookup"><span data-stu-id="ac2b2-506">The regular expression pattern `(\b(\w+)\W+)+` extracts individual words from a string.</span></span> <span data-ttu-id="ac2b2-507">e viene definito come illustrato nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-507">It is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="ac2b2-508">Modello</span><span class="sxs-lookup"><span data-stu-id="ac2b2-508">Pattern</span></span>|<span data-ttu-id="ac2b2-509">Descrizione</span><span class="sxs-lookup"><span data-stu-id="ac2b2-509">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="ac2b2-510">Inizia la corrispondenza sul confine di parola.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-510">Begin the match at a word boundary.</span></span>|  
|`(\w+)`|<span data-ttu-id="ac2b2-511">Trova la corrispondenza di uno o più caratteri alfanumerici.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-511">Match one or more word characters.</span></span> <span data-ttu-id="ac2b2-512">Insieme, questi caratteri formano una parola.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-512">Together, these characters form a word.</span></span> <span data-ttu-id="ac2b2-513">Equivale al secondo gruppo di acquisizione.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-513">This is the second capturing group.</span></span>|  
|`\W+`|<span data-ttu-id="ac2b2-514">Trova la corrispondenza di uno o più caratteri non alfanumerici.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-514">Match one or more non-word characters.</span></span>|  
|`(\b(\w+)\W+)`|<span data-ttu-id="ac2b2-515">Trova la corrispondenza con il criterio di uno o più caratteri alfanumerici seguiti da uno o più caratteri non alfanumerici, una o più volte.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-515">Match the pattern of one or more word characters followed by one or more non-word characters one or more times.</span></span> <span data-ttu-id="ac2b2-516">Equivale al primo gruppo di acquisizione.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-516">This is the first capturing group.</span></span>|  
  
 <span data-ttu-id="ac2b2-517">Il secondo gruppo di acquisizione trova la corrispondenza per ogni parola della frase.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-517">The second capturing group matches each word of the sentence.</span></span> <span data-ttu-id="ac2b2-518">Il primo gruppo di acquisizione trova la corrispondenza per ogni parola insieme alla punteggiatura e allo spazio vuoto che seguono la parola.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-518">The first capturing group matches each word along with the punctuation and white space that follow the word.</span></span> <span data-ttu-id="ac2b2-519">L'oggetto <xref:System.Text.RegularExpressions.Group> il cui indice è 2 fornisce informazioni sul testo corrispondente in base al secondo gruppo di acquisizione.</span><span class="sxs-lookup"><span data-stu-id="ac2b2-519">The <xref:System.Text.RegularExpressions.Group> object whose index is 2 provides information about the text matched by the second capturing group.</span></span> <span data-ttu-id="ac2b2-520">Il set completo di parole acquisite dal gruppo di acquisizione è disponibile tramite l'oggetto <xref:System.Text.RegularExpressions.CaptureCollection> restituito dalla proprietà <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="ac2b2-520">The complete set of words captured by the capturing group are available from the <xref:System.Text.RegularExpressions.CaptureCollection> object returned by the <xref:System.Text.RegularExpressions.Group.Captures%2A?displayProperty=nameWithType> property.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="ac2b2-521">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="ac2b2-521">See also</span></span>

- [<span data-ttu-id="ac2b2-522">Linguaggio di espressioni regolari - Riferimento rapido</span><span class="sxs-lookup"><span data-stu-id="ac2b2-522">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)
- [<span data-ttu-id="ac2b2-523">Backtracking</span><span class="sxs-lookup"><span data-stu-id="ac2b2-523">Backtracking</span></span>](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)
