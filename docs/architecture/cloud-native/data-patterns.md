---
title: Modelli di dati cloud nativi
description: Architettura di app .NET cloud native per Azure | Modelli di dati nativi cloud
ms.date: 06/30/2019
ms.openlocfilehash: 9e90409b0b633796b452cfcfecb3896e79002d4d
ms.sourcegitcommit: 30a558d23e3ac5a52071121a52c305c85fe15726
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 12/25/2019
ms.locfileid: "75337429"
---
# <a name="cloud-native-data-patterns"></a><span data-ttu-id="a5b92-103">Modelli di dati cloud nativi</span><span class="sxs-lookup"><span data-stu-id="a5b92-103">Cloud-native data patterns</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="a5b92-104">Sebbene i dati decentralizzati possano migliorare le prestazioni, la scalabilità e il risparmio sui costi, presentano anche molte problemi.</span><span class="sxs-lookup"><span data-stu-id="a5b92-104">While decentralized data can lead to improved performance, scalability, and cost savings, it also presents many challenges.</span></span> <span data-ttu-id="a5b92-105">L'esecuzione di query per i dati tra microservizi è complessa.</span><span class="sxs-lookup"><span data-stu-id="a5b92-105">Querying for data across microservices is complex.</span></span> <span data-ttu-id="a5b92-106">Una transazione che si estende su microservizi deve essere gestita a livello di programmazione perché le transazioni distribuite non sono supportate nelle applicazioni native del cloud.</span><span class="sxs-lookup"><span data-stu-id="a5b92-106">A transaction that spans microservices must be managed programmatically as distributed transactions aren't supported in cloud-native applications.</span></span> <span data-ttu-id="a5b92-107">Si passa da un mondo di *coerenza immediata* alla *coerenza finale*.</span><span class="sxs-lookup"><span data-stu-id="a5b92-107">You  move from a world of *immediate consistency* to *eventual consistency*.</span></span>

<span data-ttu-id="a5b92-108">Questi problemi sono ora discussi.</span><span class="sxs-lookup"><span data-stu-id="a5b92-108">We discuss these challenges now.</span></span>

## <a name="cross-service-queries"></a><span data-ttu-id="a5b92-109">Query tra servizi</span><span class="sxs-lookup"><span data-stu-id="a5b92-109">Cross-service queries</span></span>

<span data-ttu-id="a5b92-110">In che modo un'applicazione esegue query sui dati distribuiti in molti microservizi indipendenti?</span><span class="sxs-lookup"><span data-stu-id="a5b92-110">How does an application query data that is spread across many independent microservices?</span></span>

<span data-ttu-id="a5b92-111">Nella figura 5-4 è illustrato questo scenario.</span><span class="sxs-lookup"><span data-stu-id="a5b92-111">Figure 5-4 shows this scenario.</span></span>

![Esecuzione di query tra microservizi](./media/cross-service-query.png)

<span data-ttu-id="a5b92-113">**Figura 5-4**.</span><span class="sxs-lookup"><span data-stu-id="a5b92-113">**Figure 5-4**.</span></span> <span data-ttu-id="a5b92-114">Esecuzione di query tra microservizi</span><span class="sxs-lookup"><span data-stu-id="a5b92-114">Querying across microservices</span></span>

<span data-ttu-id="a5b92-115">Si noti come nella figura precedente viene visualizzato un microservizio carrello acquisti che aggiunge un elemento al carrello acquisti di un utente.</span><span class="sxs-lookup"><span data-stu-id="a5b92-115">Note how in the previous figure we see a shopping basket microservice that adds an item to a user's shopping cart.</span></span> <span data-ttu-id="a5b92-116">Mentre l'archivio dati del carrello contiene una tabella basket e lineItem, non contiene dati relativi a prodotti o prezzi quando tali elementi si trovano nei microservizi Product e price.</span><span class="sxs-lookup"><span data-stu-id="a5b92-116">While the shopping basket's data store contains a basket and lineItem table, it doesn't contain product or pricing data as those items are found in the product and price microservices.</span></span> <span data-ttu-id="a5b92-117">Per aggiungere un elemento, il microservizio carrello acquisti richiede i dati del prodotto e i dati sui prezzi.</span><span class="sxs-lookup"><span data-stu-id="a5b92-117">To add an item, the shopping basket microservice needs product data and pricing data.</span></span> <span data-ttu-id="a5b92-118">Quali sono le opzioni per ottenere i dati relativi ai prodotti e ai prezzi?</span><span class="sxs-lookup"><span data-stu-id="a5b92-118">What are options to obtain the product and pricing data?</span></span>

<span data-ttu-id="a5b92-119">La figura 5-5 Mostra il microservizio carrello acquisti che effettua una chiamata HTTP diretta al catalogo dei prodotti e ai microservizi tariffari.</span><span class="sxs-lookup"><span data-stu-id="a5b92-119">Figure 5-5 shows the shopping basket microservice making a direct HTTP call to both the product catalog and pricing microservices.</span></span>

![Comunicazione HTTP diretta](./media/direct-http-communication.png)

<span data-ttu-id="a5b92-121">**Figura 5-5**.</span><span class="sxs-lookup"><span data-stu-id="a5b92-121">**Figure 5-5**.</span></span> <span data-ttu-id="a5b92-122">Comunicazione HTTP diretta</span><span class="sxs-lookup"><span data-stu-id="a5b92-122">Direct HTTP communication</span></span>

<span data-ttu-id="a5b92-123">Sebbene sia possibile implementare, nel capitolo 4 è stato illustrato il modo in cui le chiamate HTTP dirette tra i microservizi si abbinano al sistema e non vengono considerate buone procedure.</span><span class="sxs-lookup"><span data-stu-id="a5b92-123">While feasible to implement, in chapter 4 we discussed how direct HTTP calls across microservices couple the system and aren't considered a good practice.</span></span>

<span data-ttu-id="a5b92-124">È possibile implementare un microservizio aggregator illustrato nella figura 5-6.</span><span class="sxs-lookup"><span data-stu-id="a5b92-124">We could implement an aggregator microservice shown in Figure 5-6.</span></span>

![Microservizio aggregator](./media/aggregator-microservice.png)

<span data-ttu-id="a5b92-126">**Figura 5-6.**</span><span class="sxs-lookup"><span data-stu-id="a5b92-126">**Figure 5-6.**</span></span> <span data-ttu-id="a5b92-127">Microservizio aggregator</span><span class="sxs-lookup"><span data-stu-id="a5b92-127">Aggregator microservice</span></span>

<span data-ttu-id="a5b92-128">Sebbene questo approccio incapsulare il flusso di lavoro dell'operazione di business in un singolo microservizio, aggiunge complessità e restituisce comunque le chiamate HTTP dirette.</span><span class="sxs-lookup"><span data-stu-id="a5b92-128">While this approach encapsulates the business operation workflow in an individual microservice, it adds complexity and still results in direct HTTP calls.</span></span>

<span data-ttu-id="a5b92-129">Un approccio comune per l'esecuzione di query tra servizi usa il [modello di vista materializzata](https://docs.microsoft.com/azure/architecture/patterns/materialized-view), illustrato nella figura 5-7.</span><span class="sxs-lookup"><span data-stu-id="a5b92-129">A common approach for executing cross-service queries uses the [Materialized View Pattern](https://docs.microsoft.com/azure/architecture/patterns/materialized-view), shown in Figure 5-7.</span></span>

![Modello di vista materializzata](./media/materialized-view-pattern.png)

<span data-ttu-id="a5b92-131">**Figure5-7**.</span><span class="sxs-lookup"><span data-stu-id="a5b92-131">**Figure5-7**.</span></span> <span data-ttu-id="a5b92-132">Modello di vista materializzata</span><span class="sxs-lookup"><span data-stu-id="a5b92-132">Materialized View Pattern</span></span>

<span data-ttu-id="a5b92-133">Con questo modello, si inserisce direttamente una tabella locale, nota come *modello di lettura*, nel servizio carrello acquisti che contiene una copia denormalizzata dei dati necessari per i microservizi Product e pricing.</span><span class="sxs-lookup"><span data-stu-id="a5b92-133">With this pattern, you directly place a local table (known as a *read model*) in the shopping basket service that contains a denormalized copy of the data that is needed from the product and pricing microservices.</span></span> <span data-ttu-id="a5b92-134">Inserendo i dati all'interno del microservizio carrello acquisti si elimina la necessità di richiamare costose chiamate tra servizi.</span><span class="sxs-lookup"><span data-stu-id="a5b92-134">Placing that data inside the shopping basket microservice eliminates the need for invoking expensive cross-service calls.</span></span> <span data-ttu-id="a5b92-135">Con i dati locali per il servizio, è possibile migliorare il tempo di risposta e l'affidabilità.</span><span class="sxs-lookup"><span data-stu-id="a5b92-135">With the data local to the service, you improve response time and reliability.</span></span>

<span data-ttu-id="a5b92-136">Il problema con questo approccio è che ora sono presenti dati duplicati nel sistema.</span><span class="sxs-lookup"><span data-stu-id="a5b92-136">The catch with this approach is you now have duplicate data in your system.</span></span> <span data-ttu-id="a5b92-137">Nei sistemi nativi del cloud, i dati duplicati non sono considerati un [anti-modello](https://en.wikipedia.org/wiki/Anti-pattern) ed è comunemente implementato nei sistemi nativi del cloud.</span><span class="sxs-lookup"><span data-stu-id="a5b92-137">In cloud-native systems, duplicate data isn't considered an [anti-pattern](https://en.wikipedia.org/wiki/Anti-pattern) and is commonly implemented in cloud-native systems.</span></span> <span data-ttu-id="a5b92-138">Tuttavia, un solo sistema può essere il proprietario di un set di dati ed è necessario implementare un meccanismo di sincronizzazione affinché il sistema di registrazione aggiorni tutti i modelli di lettura associati, ogni volta che viene apportata una modifica ai dati sottostanti.</span><span class="sxs-lookup"><span data-stu-id="a5b92-138">However, one and only one system can be the owner of any dataset, and you'll need to implement a synchronization mechanism for the system of record to update all of the associated read models, whenever a change to its underlying data occurs.</span></span>

## <a name="transactional-support"></a><span data-ttu-id="a5b92-139">Supporto delle transazioni</span><span class="sxs-lookup"><span data-stu-id="a5b92-139">Transactional support</span></span>

<span data-ttu-id="a5b92-140">Sebbene le query tra microservizi siano complesse, l'implementazione di una transazione tra microservizi può essere complessa.</span><span class="sxs-lookup"><span data-stu-id="a5b92-140">While queries across microservices are challenging, implementing a transaction across microservices can be complex.</span></span> <span data-ttu-id="a5b92-141">La sfida inerente alla gestione della coerenza dei dati tra le origini dati che si trovano in microservizi diversi non può essere sottostata.</span><span class="sxs-lookup"><span data-stu-id="a5b92-141">The inherent challenge of maintaining data consistency across data sources that reside in different microservices can't be understated.</span></span> <span data-ttu-id="a5b92-142">La figura 5-8 illustra il problema.</span><span class="sxs-lookup"><span data-stu-id="a5b92-142">Figure 5-8 shows the problem.</span></span>

![Transazione nel modello saga](./media/saga-transaction-operation.png)

<span data-ttu-id="a5b92-144">**Figura 5-8**.</span><span class="sxs-lookup"><span data-stu-id="a5b92-144">**Figure 5-8**.</span></span> <span data-ttu-id="a5b92-145">Implementazione di una transazione tra microservizi</span><span class="sxs-lookup"><span data-stu-id="a5b92-145">Implementing a transaction across microservices</span></span>

<span data-ttu-id="a5b92-146">Si noti che nella figura precedente cinque microservizi indipendenti partecipano tutti a una transazione di *creazione ordine* distribuita.</span><span class="sxs-lookup"><span data-stu-id="a5b92-146">Note how in the previous figure five independent microservices all participate in a distributed *Create Order* transaction.</span></span> <span data-ttu-id="a5b92-147">Tuttavia, la transazione per ognuno dei cinque singoli microservizi deve avere esito positivo oppure tutti devono interrompere ed eseguire il rollback dell'operazione.</span><span class="sxs-lookup"><span data-stu-id="a5b92-147">However, the transaction for each of the five individual microservices must succeed, or all must abort and roll back the operation.</span></span> <span data-ttu-id="a5b92-148">Sebbene il supporto transazionale predefinito sia disponibile all'interno di ogni microservizio, non esiste alcun supporto per una transazione distribuita in tutti i cinque servizi.</span><span class="sxs-lookup"><span data-stu-id="a5b92-148">While built-in transactional support is available inside each of the microservices, there's no support for a distributed transaction across all five services.</span></span>

<span data-ttu-id="a5b92-149">Poiché il supporto transazionale è essenziale per questa operazione per mantenere i dati coerenti in ogni microservizio, è necessario creare una transazione distribuita a livello di codice.</span><span class="sxs-lookup"><span data-stu-id="a5b92-149">Since transactional support is essential for this operation to keep the data consistent in each of the microservices, you have to programmatically construct a distributed transaction.</span></span>

<span data-ttu-id="a5b92-150">Uno dei modelli più diffusi per l'aggiunta a livello di codice del supporto transazionale è il [modello saga](https://blog.couchbase.com/saga-pattern-implement-business-transactions-using-microservices-part/).</span><span class="sxs-lookup"><span data-stu-id="a5b92-150">A popular pattern for programmatically adding transactional support is the [Saga pattern](https://blog.couchbase.com/saga-pattern-implement-business-transactions-using-microservices-part/).</span></span> <span data-ttu-id="a5b92-151">Viene implementato raggruppando le transazioni locali e richiamando in modo sequenziale ciascuna di esse.</span><span class="sxs-lookup"><span data-stu-id="a5b92-151">It's implemented by grouping local transactions together and sequentially invoking each one.</span></span> <span data-ttu-id="a5b92-152">Se una transazione locale ha esito negativo, la saga interrompe l'operazione e richiama un set di [transazioni di compensazione](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction) per annullare le modifiche apportate dalle transazioni locali precedenti.</span><span class="sxs-lookup"><span data-stu-id="a5b92-152">If a local transaction fails, the Saga aborts the operation and invokes a set of [compensating transactions](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction) to undo the changes made by the preceding local transactions.</span></span> <span data-ttu-id="a5b92-153">La figura 5-9 Mostra una transazione non riuscita con il modello saga.</span><span class="sxs-lookup"><span data-stu-id="a5b92-153">Figure 5-9 shows a failed transaction with the Saga pattern.</span></span>

![Eseguire il rollback nel modello saga](./media/saga-rollback-operation.png)

<span data-ttu-id="a5b92-155">**Figura 5-9**.</span><span class="sxs-lookup"><span data-stu-id="a5b92-155">**Figure 5-9**.</span></span> <span data-ttu-id="a5b92-156">Esecuzione del rollback di una transazione</span><span class="sxs-lookup"><span data-stu-id="a5b92-156">Rolling back a transaction</span></span>

<span data-ttu-id="a5b92-157">Si noti come nella figura precedente l'operazione *GenerateContent* non è riuscita nel microservizio Music.</span><span class="sxs-lookup"><span data-stu-id="a5b92-157">Note how in the previous figure the *GenerateContent* operation has failed in the music microservice.</span></span> <span data-ttu-id="a5b92-158">La saga richiama le transazioni di compensazione (in rosso) per rimuovere il contenuto, annullare il pagamento e annullare l'ordine, restituendo di nuovo i dati per ogni microservizio a uno stato coerente.</span><span class="sxs-lookup"><span data-stu-id="a5b92-158">The Saga invokes compensating transactions (in red) to remove the content, cancel the payment, and cancel the order, returning the data for each microservice back to a consistent state.</span></span>

<span data-ttu-id="a5b92-159">I modelli di Saga vengono in genere sottoposti a coreografia come una serie di eventi correlati o orchestrati come un set di comandi correlati.</span><span class="sxs-lookup"><span data-stu-id="a5b92-159">Saga patterns are typically choreographed as a series of related events or orchestrated as a set of related commands.</span></span>

## <a name="cqrs-pattern"></a><span data-ttu-id="a5b92-160">Modello CQRS</span><span class="sxs-lookup"><span data-stu-id="a5b92-160">CQRS pattern</span></span>

<span data-ttu-id="a5b92-161">CQRS, o [separazione di responsabilità per query e comandi](https://docs.microsoft.com/azure/architecture/patterns/cqrs), è uno schema architettonico che separa le operazioni di lettura dei dati da quelle che scrivono i dati.</span><span class="sxs-lookup"><span data-stu-id="a5b92-161">CQRS, or [Command and Query Responsibility Segregation](https://docs.microsoft.com/azure/architecture/patterns/cqrs), is an architectural pattern that separate operations that read data from those that write data.</span></span> <span data-ttu-id="a5b92-162">Questo modello consente di ottimizzare le prestazioni, la scalabilità e la sicurezza.</span><span class="sxs-lookup"><span data-stu-id="a5b92-162">This pattern can help maximize performance, scalability, and security.</span></span>

<span data-ttu-id="a5b92-163">Negli scenari di accesso ai dati normali si implementa un singolo modello (oggetto entità e repository) che eseguono operazioni *di lettura e* scrittura dei dati.</span><span class="sxs-lookup"><span data-stu-id="a5b92-163">In normal data access scenarios, you implement a single model (entity and repository object) that perform *both* read and write data operations.</span></span>

<span data-ttu-id="a5b92-164">Uno scenario di accesso ai dati più avanzato può tuttavia trarre vantaggio da modelli e tabelle di dati separati per operazioni di lettura e scrittura.</span><span class="sxs-lookup"><span data-stu-id="a5b92-164">However, a more advanced data access scenario might benefit from separate models and data tables for reads and writes.</span></span> <span data-ttu-id="a5b92-165">Per migliorare le prestazioni, l'operazione di lettura, nota come *query*, potrebbe eseguire query su una rappresentazione altamente denormalizzata dei dati per evitare costosi join di tabella ripetitivi.</span><span class="sxs-lookup"><span data-stu-id="a5b92-165">To improve performance, the read operation, known as a *query*, might query against a highly denormalized representation of the data to avoid expensive repetitive table joins.</span></span> <span data-ttu-id="a5b92-166">Mentre l'operazione di *scrittura* , nota come *comando*, potrebbe essere aggiornata rispetto a una rappresentazione completamente normalizzata dei dati.</span><span class="sxs-lookup"><span data-stu-id="a5b92-166">Whereas the *write* operation, known as a *command*, might update against a fully normalized representation of the data.</span></span> <span data-ttu-id="a5b92-167">Sarà quindi necessario implementare un meccanismo per mantenendo sincronizzate entrambe le rappresentazioni. In genere, ogni volta che la tabella di scrittura viene modificata, genera un evento che replica la modifica dei dati nella tabella Read.</span><span class="sxs-lookup"><span data-stu-id="a5b92-167">You would then need to implement a mechanism to keep both representations in sync. Typically, whenever the write table is modified, it raises an event that replicates the data modification to the read table.</span></span>

<span data-ttu-id="a5b92-168">La figura 5-10 illustra un'implementazione del modello CQRS.</span><span class="sxs-lookup"><span data-stu-id="a5b92-168">Figure 5-10 shows an implementation of the CQRS pattern.</span></span>

![Implementazione di CQRS](./media/cqrs-implementation.png)

<span data-ttu-id="a5b92-170">**Figura 5-10**.</span><span class="sxs-lookup"><span data-stu-id="a5b92-170">**Figure 5-10**.</span></span> <span data-ttu-id="a5b92-171">Implementazione di CQRS</span><span class="sxs-lookup"><span data-stu-id="a5b92-171">CQRS implementation</span></span>

<span data-ttu-id="a5b92-172">Si noti che nella figura precedente sono implementati i modelli di query e di comando separati.</span><span class="sxs-lookup"><span data-stu-id="a5b92-172">Note how in the previous figure separate command and query models are implemented.</span></span> <span data-ttu-id="a5b92-173">Ogni operazione di scrittura dei dati viene inoltre salvata nell'archivio di scrittura e quindi propagata nell'archivio di lettura.</span><span class="sxs-lookup"><span data-stu-id="a5b92-173">Moreover, each data write operation is saved to the write store and then propagated to the read store.</span></span> <span data-ttu-id="a5b92-174">Prestare particolare attenzione al modo in cui il processo di propagazione opera sul principio della [coerenza finale](https://www.cloudcomputingpatterns.org/eventual_consistency/), mentre il modello di lettura viene sincronizzato con il modello di scrittura, ma potrebbe verificarsi un certo ritardo nel processo.</span><span class="sxs-lookup"><span data-stu-id="a5b92-174">Pay close attention to how the propagation process operates on the principle of [eventual consistency](https://www.cloudcomputingpatterns.org/eventual_consistency/), whereas the read model eventually synchronizes with the write model, but there may be some lag in the process.</span></span>

<span data-ttu-id="a5b92-175">Implementando la separazione, è possibile ridimensionare le letture e le Scritture separatamente.</span><span class="sxs-lookup"><span data-stu-id="a5b92-175">By implementing separation, you have the ability to scale reads and writes separately.</span></span> <span data-ttu-id="a5b92-176">È anche possibile imporre una sicurezza più stretta sulle operazioni di scrittura rispetto a quelle relative alle letture.</span><span class="sxs-lookup"><span data-stu-id="a5b92-176">As well, you might impose tighter security on write operations than those concerning reads.</span></span>

<span data-ttu-id="a5b92-177">In genere, i modelli CQRS vengono applicati a sezioni limitate del sistema in base a specifiche esigenze.</span><span class="sxs-lookup"><span data-stu-id="a5b92-177">Typically, CQRS patterns are applied to limited sections of your system based upon specific needs.</span></span>

## <a name="relational-vs-nosql"></a><span data-ttu-id="a5b92-178">Confronto tra NoSQL e relazionali</span><span class="sxs-lookup"><span data-stu-id="a5b92-178">Relational vs NoSQL</span></span>

<span data-ttu-id="a5b92-179">L'effetto delle tecnologie [NoSQL](https://www.geeksforgeeks.org/introduction-to-nosql/) non può essere sovrastato, specialmente per i sistemi distribuiti nativi del cloud.</span><span class="sxs-lookup"><span data-stu-id="a5b92-179">The impact of [NoSQL](https://www.geeksforgeeks.org/introduction-to-nosql/) technologies can't be overstated, especially for distributed cloud-native systems.</span></span> <span data-ttu-id="a5b92-180">La proliferazione di nuove tecnologie dati in questo spazio ha comportato soluzioni che una volta si basavano esclusivamente sui database relazionali.</span><span class="sxs-lookup"><span data-stu-id="a5b92-180">The proliferation of new data technologies in this space has disrupted solutions that once exclusively relied on relational databases.</span></span>

<span data-ttu-id="a5b92-181">Da un lato, i database relazionali sono stati una tecnologia prevalente per decenni.</span><span class="sxs-lookup"><span data-stu-id="a5b92-181">On the one side, relational databases have been a prevalent technology for decades.</span></span> <span data-ttu-id="a5b92-182">Sono maturi, collaudati e ampiamente implementati.</span><span class="sxs-lookup"><span data-stu-id="a5b92-182">They're mature, proven, and widely implemented.</span></span> <span data-ttu-id="a5b92-183">I prodotti di database, le competenze e gli strumenti in competizione sono molto ricchi.</span><span class="sxs-lookup"><span data-stu-id="a5b92-183">Competing database products, expertise and tooling abounds.</span></span> <span data-ttu-id="a5b92-184">I database relazionali forniscono un archivio di tabelle di dati correlate.</span><span class="sxs-lookup"><span data-stu-id="a5b92-184">Relational databases provide a store of related data tables.</span></span> <span data-ttu-id="a5b92-185">Queste tabelle hanno uno schema fisso, usano SQL (Structured Query Language) per gestire i dati e hanno garanzie [acid](https://www.geeksforgeeks.org/acid-properties-in-dbms/) (noti anche come atomicità, coerenza, isolamento e durabilità).</span><span class="sxs-lookup"><span data-stu-id="a5b92-185">These tables have a fixed schema, use SQL (Structured Query Language) to manage data and have [ACID](https://www.geeksforgeeks.org/acid-properties-in-dbms/) (also known as Atomicity, Consistency, Isolation, and Durability) guarantees.</span></span>

<span data-ttu-id="a5b92-186">I database no-SQL, dall'altro lato, fanno riferimento a archivi dati non relazionali a prestazioni elevate.</span><span class="sxs-lookup"><span data-stu-id="a5b92-186">No-SQL databases, on the other side, refer to high-performance, non-relational data stores.</span></span> <span data-ttu-id="a5b92-187">Si distinguono per la facilità d'uso, la scalabilità, la resilienza e le caratteristiche di disponibilità.</span><span class="sxs-lookup"><span data-stu-id="a5b92-187">They excel in their ease-of-use, scalability, resilience, and availability characteristics.</span></span> <span data-ttu-id="a5b92-188">Anziché riunire le tabelle di dati normalizzati, NoSQL archivia i dati autodescrittivi (senza schema) in genere nei documenti JSON.</span><span class="sxs-lookup"><span data-stu-id="a5b92-188">Instead of joining tables of normalized data, NoSQL stores self-describing (schemaless) data typically in JSON documents.</span></span> <span data-ttu-id="a5b92-189">Non offrono garanzie [acid](https://www.geeksforgeeks.org/acid-properties-in-dbms/) .</span><span class="sxs-lookup"><span data-stu-id="a5b92-189">They don't offer [ACID](https://www.geeksforgeeks.org/acid-properties-in-dbms/) guarantees.</span></span>

<span data-ttu-id="a5b92-190">Un modo per comprendere le differenze tra questi tipi di database è disponibile nel [teorema Cap](https://towardsdatascience.com/cap-theorem-and-distributed-database-management-systems-5c2be977950e), un set di principi che è possibile applicare ai sistemi distribuiti che archiviano lo stato.</span><span class="sxs-lookup"><span data-stu-id="a5b92-190">A way to understand the differences between these types of databases can be found in the [CAP theorem](https://towardsdatascience.com/cap-theorem-and-distributed-database-management-systems-5c2be977950e), a set of principles that can be applied to distributed systems that store state.</span></span> <span data-ttu-id="a5b92-191">La figura 5-11 illustra le tre proprietà del teorema CAP.</span><span class="sxs-lookup"><span data-stu-id="a5b92-191">Figure 5-11 shows the three properties of the CAP theorem.</span></span>

![Teorema CAP](./media/cap-theorem.png)

<span data-ttu-id="a5b92-193">**Figura 5-11**.</span><span class="sxs-lookup"><span data-stu-id="a5b92-193">**Figure 5-11**.</span></span> <span data-ttu-id="a5b92-194">Teorema CAP</span><span class="sxs-lookup"><span data-stu-id="a5b92-194">The CAP theorem</span></span>

<span data-ttu-id="a5b92-195">Il teorema indica che qualsiasi sistema di dati distribuito offrirà un compromesso tra coerenza, disponibilità e tolleranza di partizione e che qualsiasi database può garantire solo due delle tre proprietà:</span><span class="sxs-lookup"><span data-stu-id="a5b92-195">The theorem states that any distributed data system will offer a trade-off between consistency, availability, and partition tolerance, and that any database can only guarantee two of the three properties:</span></span>

- <span data-ttu-id="a5b92-196">*Coerenza*: ogni nodo del cluster risponderà con i dati più recenti, anche se è necessario bloccare una richiesta fino a quando tutte le repliche non vengono aggiornate correttamente.</span><span class="sxs-lookup"><span data-stu-id="a5b92-196">*Consistency*: every node in the cluster will respond with the most recent data, even if it requires blocking a request until all replicas are correctly updated.</span></span>

- <span data-ttu-id="a5b92-197">*Disponibilità*: ogni nodo restituirà una risposta in un periodo di tempo ragionevole, anche se tale risposta non è i dati più recenti.</span><span class="sxs-lookup"><span data-stu-id="a5b92-197">*Availability*: every node will return a response in a reasonable amount of time, even if that response isn't the most recent data.</span></span>

- <span data-ttu-id="a5b92-198">*Tolleranza di partizione*: garantisce che il sistema continuerà a funzionare in caso di errore di un nodo o di perdita della connettività con un'altra.</span><span class="sxs-lookup"><span data-stu-id="a5b92-198">*Partition Tolerance*: guarantees that the system will continue operating if a node fails or loses connectivity with another.</span></span>

<span data-ttu-id="a5b92-199">I database relazionali presentano coerenza e disponibilità, ma non la tolleranza della partizione.</span><span class="sxs-lookup"><span data-stu-id="a5b92-199">Relational databases exhibit consistency and availability, but not partition tolerance.</span></span> <span data-ttu-id="a5b92-200">Il partizionamento di un database relazionale, ad esempio il partizionamento orizzontale, è difficile e può influisca sulle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="a5b92-200">Partitioning a relational database, such as sharding, is difficult and can impact performance.</span></span>

<span data-ttu-id="a5b92-201">D'altra parte, i database NoSQL in genere presentano tolleranza di partizione, nota come scalabilità orizzontale e disponibilità elevata.</span><span class="sxs-lookup"><span data-stu-id="a5b92-201">On the other hand, NoSQL databases typically exhibit partition tolerance, known as horizontal scalability, and high availability.</span></span> <span data-ttu-id="a5b92-202">Come specificato dal teorema CAP, è possibile avere solo due dei tre principi e si perde la proprietà di coerenza.</span><span class="sxs-lookup"><span data-stu-id="a5b92-202">As the CAP theorem specifies, you can only have two of the three principles, and you lose the  consistency property.</span></span>

<span data-ttu-id="a5b92-203">I database NoSQL vengono distribuiti e generalmente scalati orizzontalmente nei server di prodotti.</span><span class="sxs-lookup"><span data-stu-id="a5b92-203">NoSQL databases are distributed and commonly scaled out across commodity servers.</span></span> <span data-ttu-id="a5b92-204">Questa operazione può offrire una disponibilità straordinaria, sia all'interno che tra aree geografiche a un costo ridotto.</span><span class="sxs-lookup"><span data-stu-id="a5b92-204">Doing so can provide great availability, both within and across geographical regions at a reduced cost.</span></span> <span data-ttu-id="a5b92-205">I dati possono essere partizionati e replicati in questi computer, o nodi, garantendo ridondanza e tolleranza di errore.</span><span class="sxs-lookup"><span data-stu-id="a5b92-205">Data can be partitioned and replicated across these machines, or nodes, providing redundancy and fault tolerance.</span></span> <span data-ttu-id="a5b92-206">Il lato negativo è la coerenza.</span><span class="sxs-lookup"><span data-stu-id="a5b92-206">The downside is consistency.</span></span> <span data-ttu-id="a5b92-207">Una modifica ai dati in un nodo NoSQL può richiedere del tempo per la propagazione ad altri nodi.</span><span class="sxs-lookup"><span data-stu-id="a5b92-207">A change to data on one NoSQL node can take some time to propagate to other nodes.</span></span> <span data-ttu-id="a5b92-208">In genere, un nodo del database NoSQL fornirà una risposta immediata a una query, anche se i dati che presenta sono obsoleti e non sono stati ancora aggiornati.</span><span class="sxs-lookup"><span data-stu-id="a5b92-208">Typically, a NoSQL database node will provide an immediate response to a query, even if the data that it is presenting is stale and has not been updated yet.</span></span>

<span data-ttu-id="a5b92-209">Si tratta di una [coerenza finale](https://www.cloudcomputingpatterns.org/eventual_consistency/)nota, una caratteristica dei sistemi dati distribuiti in cui non sono supportate le transazioni ACID.</span><span class="sxs-lookup"><span data-stu-id="a5b92-209">This is known [eventual consistency](https://www.cloudcomputingpatterns.org/eventual_consistency/), a characteristic of distributed data systems where ACID transactions aren't supported.</span></span> <span data-ttu-id="a5b92-210">Si tratta di un breve ritardo tra l'aggiornamento di un elemento di dati e il tempo necessario per propagare tale aggiornamento a ogni nodo di replica.</span><span class="sxs-lookup"><span data-stu-id="a5b92-210">It's a brief delay between the update of a data item and time that it takes to propagate that update to each of the replica nodes.</span></span> <span data-ttu-id="a5b92-211">Se si aggiorna un elemento prodotto in un database NoSQL nel Stati Uniti, ma allo stesso tempo si esegue una query sullo stesso elemento di dati da un nodo di replica in Europa, è possibile recuperare le informazioni precedenti sul prodotto, fino a quando il nodo europeo non è stato aggiornato con la modifica del prodotto.</span><span class="sxs-lookup"><span data-stu-id="a5b92-211">If you update a product item in a NoSQL database in the United States, but at same time query that same data item from a replica node in Europe, you might retrieve the earlier product information - until the European node has been updated with product change.</span></span> <span data-ttu-id="a5b92-212">Il compromesso è che, grazie alla [coerenza](https://en.wikipedia.org/wiki/Strong_consistency)assoluta, in attesa dell'aggiornamento di tutti i nodi di replica prima della restituzione di un risultato della query, è possibile supportare volumi di traffico e scalabilità enormi, ma con la possibilità di presentare dati meno recenti.</span><span class="sxs-lookup"><span data-stu-id="a5b92-212">The trade-off is that by giving up [strong consistency](https://en.wikipedia.org/wiki/Strong_consistency),  waiting for all replica nodes to update before returning a query result, you can support enormous scale and traffic volume, but with the possibility of presenting older data.</span></span>

<span data-ttu-id="a5b92-213">I database NoSQL possono essere suddivisi in categorie in base ai quattro modelli seguenti:</span><span class="sxs-lookup"><span data-stu-id="a5b92-213">NoSQL databases can be categorized by the following four models:</span></span>

- <span data-ttu-id="a5b92-214">*Archivio documenti* (MongoDB, CouchDB, Couchbase): i dati (e i metadati corrispondenti) vengono archiviati in un formato non relazionale in documenti denormalizzati basati su JSON all'interno del database.</span><span class="sxs-lookup"><span data-stu-id="a5b92-214">*Document Store* (MongoDB, CouchDB, Couchbase): data (and corresponding metadata) is stored non-relationally in denormalized JSON-based documents inside the database.</span></span>

- <span data-ttu-id="a5b92-215">*Archivio chiave/valore* (Redis, Riak, Memcached): i dati vengono archiviati in semplici coppie chiave-valore con operazioni di sistema eseguite su una chiave di accesso univoca mappata a un valore di dati utente.</span><span class="sxs-lookup"><span data-stu-id="a5b92-215">*Key/Value Store* (Redis, Riak, memcached): data is stored in simple key-value pairs with system operations performed against a unique access key that is mapped to a value of user data.</span></span>

- <span data-ttu-id="a5b92-216">*Archivio a colonne Wide* (HBASE, Cassandra): i dati correlati vengono archiviati in un formato a colonne come un set di coppie chiave/valore annidate all'interno di una singola colonna con dati recuperati in genere come una singola unità senza dover unire più tabelle.</span><span class="sxs-lookup"><span data-stu-id="a5b92-216">*Wide-Column Store* (HBase, Cassandra): related Data is stored in a columnar format as a set of nested-key/value pairs within a single column with data typically retrieved as a single unit without having to join multiple tables together.</span></span>

- <span data-ttu-id="a5b92-217">*Archivi Graph* (Neo4j, Titan): i dati vengono archiviati come rappresentazione grafica all'interno di un nodo insieme ai bordi che specificano la relazione tra i nodi.</span><span class="sxs-lookup"><span data-stu-id="a5b92-217">*Graph stores* (neo4j, titan): data is stored as a graphical representation within a node along with edges that specify the relationship between the nodes.</span></span>

<span data-ttu-id="a5b92-218">I database NoSQL possono essere ottimizzati per gestire i dati su larga scala, soprattutto quando i dati sono relativamente semplici.</span><span class="sxs-lookup"><span data-stu-id="a5b92-218">NoSQL databases can be optimized to deal with large-scale data, especially when the data is relatively simple.</span></span> <span data-ttu-id="a5b92-219">Si consideri un database NoSQL nei casi seguenti:</span><span class="sxs-lookup"><span data-stu-id="a5b92-219">Consider a NoSQL database when:</span></span>

- <span data-ttu-id="a5b92-220">Il carico di lavoro richiede una grande scala e una concorrenza elevata.</span><span class="sxs-lookup"><span data-stu-id="a5b92-220">Your workload requires a large scale and high concurrency.</span></span>
- <span data-ttu-id="a5b92-221">Si dispone di un numero elevato di utenti.</span><span class="sxs-lookup"><span data-stu-id="a5b92-221">You have large numbers of users.</span></span>
- <span data-ttu-id="a5b92-222">I dati possono essere espressi semplicemente senza relazioni.</span><span class="sxs-lookup"><span data-stu-id="a5b92-222">Your data can be expressed simply without relationships.</span></span>
- <span data-ttu-id="a5b92-223">È necessario distribuire geograficamente i dati.</span><span class="sxs-lookup"><span data-stu-id="a5b92-223">You need to geographically distribute your data.</span></span>
- <span data-ttu-id="a5b92-224">Non sono necessarie le garanzie ACID.</span><span class="sxs-lookup"><span data-stu-id="a5b92-224">You don't need ACID guarantees.</span></span>
- <span data-ttu-id="a5b92-225">Verranno distribuiti nell'hardware di un prodotto.</span><span class="sxs-lookup"><span data-stu-id="a5b92-225">Will be deployed to commodity hardware.</span></span>

<span data-ttu-id="a5b92-226">Quindi, si consideri un database relazionale nei casi seguenti:</span><span class="sxs-lookup"><span data-stu-id="a5b92-226">Then, consider a relational database when:</span></span>

- <span data-ttu-id="a5b92-227">I carichi di lavoro richiedono una scala media-large.</span><span class="sxs-lookup"><span data-stu-id="a5b92-227">Your workloads require medium to large scale.</span></span>
- <span data-ttu-id="a5b92-228">La concorrenza non è un problema importante.</span><span class="sxs-lookup"><span data-stu-id="a5b92-228">Concurrency isn't a major concern.</span></span>
- <span data-ttu-id="a5b92-229">Sono necessarie le garanzie ACID.</span><span class="sxs-lookup"><span data-stu-id="a5b92-229">ACID guarantees are needed.</span></span>
- <span data-ttu-id="a5b92-230">I dati sono espressi in modo ottimale in modo relazionale.</span><span class="sxs-lookup"><span data-stu-id="a5b92-230">Data is best expressed relationally.</span></span>
- <span data-ttu-id="a5b92-231">L'applicazione verrà distribuita nell'hardware di fascia alta di grandi dimensioni.</span><span class="sxs-lookup"><span data-stu-id="a5b92-231">Your application will be deployed to large, high-end hardware.</span></span>

<span data-ttu-id="a5b92-232">Viene quindi esaminata l'archiviazione dei dati nel cloud di Azure.</span><span class="sxs-lookup"><span data-stu-id="a5b92-232">Next, we look at data storage in the Azure cloud.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="a5b92-233">[Precedente](distributed-data.md)
>[Successivo](azure-data-storage.md)</span><span class="sxs-lookup"><span data-stu-id="a5b92-233">[Previous](distributed-data.md)
[Next](azure-data-storage.md)</span></span>
