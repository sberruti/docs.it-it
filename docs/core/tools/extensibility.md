---
title: Modello di estendibilità dell'interfaccia della riga di comando di .NET Core
description: Informazioni su come estendere il interfaccia della riga di comando di .NET Core.
ms.date: 04/12/2017
ms.openlocfilehash: 56a9cedc090ddca446c0ee1a60f2ca49590e7635
ms.sourcegitcommit: 700ea803fb06c5ce98de017c7f76463ba33ff4a9
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 02/19/2020
ms.locfileid: "77451155"
---
# <a name="net-core-cli-extensibility-model"></a><span data-ttu-id="92a25-103">Modello di estendibilità dell'interfaccia della riga di comando di .NET Core</span><span class="sxs-lookup"><span data-stu-id="92a25-103">.NET Core CLI extensibility model</span></span>

<span data-ttu-id="92a25-104">In questo articolo vengono illustrati i diversi modi in cui è possibile estendere il interfaccia della riga di comando di .NET Core e spiegare gli scenari in cui sono disponibili tutti gli scenari.</span><span class="sxs-lookup"><span data-stu-id="92a25-104">This article covers the different ways you can extend the .NET Core CLI and explain the scenarios that drive each one of them.</span></span>
<span data-ttu-id="92a25-105">Si vedrà come usare gli strumenti e come creare i diversi tipi di strumenti.</span><span class="sxs-lookup"><span data-stu-id="92a25-105">You'll see how to consume the tools as well as how to build the different types of tools.</span></span>

## <a name="how-to-extend-the-cli"></a><span data-ttu-id="92a25-106">Come estendere l'interfaccia della riga di comando</span><span class="sxs-lookup"><span data-stu-id="92a25-106">How to extend the CLI</span></span>
<span data-ttu-id="92a25-107">L'interfaccia della riga di comando può essere estesa in tre modi principali:</span><span class="sxs-lookup"><span data-stu-id="92a25-107">The CLI can be extended in three main ways:</span></span>

1. [<span data-ttu-id="92a25-108">Tramite pacchetti NuGet in base al progetto</span><span class="sxs-lookup"><span data-stu-id="92a25-108">Via NuGet packages on a per-project basis</span></span>](#per-project-based-extensibility)

   <span data-ttu-id="92a25-109">Gli strumenti in base al progetto sono contenuti nel contesto del progetto stesso, ma consentono un'installazione facile mediante il ripristino.</span><span class="sxs-lookup"><span data-stu-id="92a25-109">Per-project tools are contained within the project's context, but they allow easy installation through restoration.</span></span>

2. [<span data-ttu-id="92a25-110">Tramite pacchetti NuGet con destinazioni personalizzate</span><span class="sxs-lookup"><span data-stu-id="92a25-110">Via NuGet packages with custom targets</span></span>](#custom-targets)

   <span data-ttu-id="92a25-111">Le destinazioni personalizzate consentono di estendere facilmente il processo di compilazione con attività personalizzate.</span><span class="sxs-lookup"><span data-stu-id="92a25-111">Custom targets allow you to easily extend the build process with custom tasks.</span></span>

3. [<span data-ttu-id="92a25-112">Tramite il PATH di sistema</span><span class="sxs-lookup"><span data-stu-id="92a25-112">Via the system's PATH</span></span>](#path-based-extensibility)

   <span data-ttu-id="92a25-113">Gli strumenti basati su PATH sono ottimi per scopi di carattere generale e validi per più progetti. Sono utilizzabili su un singolo computer.</span><span class="sxs-lookup"><span data-stu-id="92a25-113">PATH-based tools are good for general, cross-project tools that are usable on a single machine.</span></span>

<span data-ttu-id="92a25-114">I tre meccanismi di estendibilità sopra indicati non si escludono a vicenda.</span><span class="sxs-lookup"><span data-stu-id="92a25-114">The three extensibility mechanisms outlined above are not exclusive.</span></span> <span data-ttu-id="92a25-115">È possibile usarne uno, usarli tutti o usare una combinazione dei meccanismi.</span><span class="sxs-lookup"><span data-stu-id="92a25-115">You can use one, or all, or a combination of them.</span></span> <span data-ttu-id="92a25-116">La scelta dipende dall'obiettivo che si vuole ottenere con l'estensione.</span><span class="sxs-lookup"><span data-stu-id="92a25-116">Which one to pick depends largely on the goal you are trying to achieve with your extension.</span></span>

## <a name="per-project-based-extensibility"></a><span data-ttu-id="92a25-117">Estendibilità in base al progetto</span><span class="sxs-lookup"><span data-stu-id="92a25-117">Per-project based extensibility</span></span>
<span data-ttu-id="92a25-118">Gli strumenti in base al progetto sono [installazioni dipendenti dal framework](../deploying/index.md#publish-runtime-dependent) distribuite come pacchetti NuGet.</span><span class="sxs-lookup"><span data-stu-id="92a25-118">Per-project tools are [framework-dependent deployments](../deploying/index.md#publish-runtime-dependent) that are distributed as NuGet packages.</span></span> <span data-ttu-id="92a25-119">Sono disponibili solo nel contesto del progetto di riferimento, per il quale vengono ripristinati.</span><span class="sxs-lookup"><span data-stu-id="92a25-119">Tools are only available in the context of the project that references them and for which they are restored.</span></span> <span data-ttu-id="92a25-120">La chiamata all'esterno del contesto del progetto (ad esempio all'esterno della directory contenente il progetto) non riesce perché il comando non viene trovato.</span><span class="sxs-lookup"><span data-stu-id="92a25-120">Invocation outside of the context of the project (for example, outside of the directory that contains the project) will fail because the command cannot be found.</span></span>

<span data-ttu-id="92a25-121">Questi strumenti sono perfetti anche per i server di compilazione, dal momento che non è necessario nulla al di fuori del file di progetto.</span><span class="sxs-lookup"><span data-stu-id="92a25-121">These tools are perfect for build servers, since nothing outside of the project file is needed.</span></span> <span data-ttu-id="92a25-122">Il processo di compilazione esegue il ripristino del progetto compilato e gli strumenti saranno disponibili.</span><span class="sxs-lookup"><span data-stu-id="92a25-122">The build process runs restore for the project it builds and tools will be available.</span></span> <span data-ttu-id="92a25-123">Rientrano in questa categoria anche i progetti in un particolare linguaggio, ad esempio F#, perché ogni progetto può essere scritto in un solo linguaggio specifico.</span><span class="sxs-lookup"><span data-stu-id="92a25-123">Language projects, such as F#, are also in this category since each project can only be written in one specific language.</span></span>

<span data-ttu-id="92a25-124">Questo modello di estendibilità, infine, fornisce il supporto per la creazione di strumenti che devono accedere all'output compilato del progetto.</span><span class="sxs-lookup"><span data-stu-id="92a25-124">Finally, this extensibility model provides support for creation of tools that need access to the built output of the project.</span></span> <span data-ttu-id="92a25-125">Ad esempio, rientrano in questa categoria diversi strumenti di visualizzazione Razor presenti in applicazioni MVC [ASP.NET](https://www.asp.net/).</span><span class="sxs-lookup"><span data-stu-id="92a25-125">For instance, various Razor view tools in [ASP.NET](https://www.asp.net/) MVC applications fall into this category.</span></span>

### <a name="consuming-per-project-tools"></a><span data-ttu-id="92a25-126">Utilizzo di strumenti in base al progetto</span><span class="sxs-lookup"><span data-stu-id="92a25-126">Consuming per-project tools</span></span>
<span data-ttu-id="92a25-127">Per usare questi strumenti è necessario aggiungere al file di progetto un elemento `<DotNetCliToolReference>` per ogni strumento da usare.</span><span class="sxs-lookup"><span data-stu-id="92a25-127">Consuming these tools requires you to add a `<DotNetCliToolReference>` element to your project file for each tool you want to use.</span></span> <span data-ttu-id="92a25-128">All'interno dell'elemento `<DotNetCliToolReference>` si fa riferimento al pacchetto in cui risiede lo strumento e si specifica la versione necessaria.</span><span class="sxs-lookup"><span data-stu-id="92a25-128">Inside the `<DotNetCliToolReference>` element, you reference the package in which the tool resides and specify the version you need.</span></span> <span data-ttu-id="92a25-129">Dopo l'esecuzione di [`dotnet restore`](dotnet-restore.md) lo strumento e le relative dipendenze vengono ripristinati.</span><span class="sxs-lookup"><span data-stu-id="92a25-129">After running [`dotnet restore`](dotnet-restore.md), the tool and its dependencies are restored.</span></span>

[!INCLUDE[DotNet Restore Note](~/includes/dotnet-restore-note.md)]

<span data-ttu-id="92a25-130">Per gli strumenti che devono caricare l'output di compilazione del progetto per l'esecuzione, è in genere presente un'altra dipendenza elencata sotto le normali dipendenze del file di progetto.</span><span class="sxs-lookup"><span data-stu-id="92a25-130">For tools that need to load the build output of the project for execution, there is usually another dependency which is listed under the regular dependencies in the project file.</span></span> <span data-ttu-id="92a25-131">Poiché l'interfaccia della riga di comando usa MSBuild come motore di compilazione, è consigliabile che queste parti dello strumento vengano scritte come [destinazioni](/visualstudio/msbuild/msbuild-targets) e [attività](/visualstudio/msbuild/msbuild-tasks) MSBuild personalizzate, dato che possono essere incluse nel processo di compilazione globale.</span><span class="sxs-lookup"><span data-stu-id="92a25-131">Since CLI uses MSBuild as its build engine, we recommend that these parts of the tool be written as custom MSBuild [targets](/visualstudio/msbuild/msbuild-targets) and [tasks](/visualstudio/msbuild/msbuild-tasks), since they can then take part in the overall build process.</span></span> <span data-ttu-id="92a25-132">Tali destinazioni e attività possono anche ottenere facilmente alcuni o tutti i dati prodotti con la compilazione, ad esempio la posizione dei file di output, la configurazione corrente in fase di compilazione e così via.</span><span class="sxs-lookup"><span data-stu-id="92a25-132">Also, they can get any and all data easily that is produced via the build, such as the location of the output files, the current configuration being built, and so on.</span></span> <span data-ttu-id="92a25-133">Tutte queste informazioni diventano un set di proprietà MSBuild leggibili da qualsiasi destinazione.</span><span class="sxs-lookup"><span data-stu-id="92a25-133">All this information becomes a set of MSBuild properties that can be read from any target.</span></span> <span data-ttu-id="92a25-134">Il presente documento illustra come aggiungere una destinazione personalizzata usando NuGet.</span><span class="sxs-lookup"><span data-stu-id="92a25-134">You can see how to add a custom target using NuGet later in this document.</span></span>

<span data-ttu-id="92a25-135">Di seguito è riportato un esempio di aggiunta di un semplice strumento "tools" a un semplice progetto.</span><span class="sxs-lookup"><span data-stu-id="92a25-135">Let's review an example of adding a simple tools-only tool to a simple project.</span></span> <span data-ttu-id="92a25-136">Si consideri un comando di esempio denominato `dotnet-api-search` che consente di cercare nei pacchetti NuGet l'API specificata. Di seguito è riportato un file di progetto di un'applicazione console che usa tale strumento:</span><span class="sxs-lookup"><span data-stu-id="92a25-136">Given an example command called `dotnet-api-search` that allows you to search through the NuGet packages for the specified API, here is a console application's project file that uses that tool:</span></span>

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>netcoreapp2.1</TargetFramework>
  </PropertyGroup>

  <!-- The tools reference -->
  <ItemGroup>
    <DotNetCliToolReference Include="dotnet-api-search" Version="1.0.0" />
  </ItemGroup>
</Project>
```

<span data-ttu-id="92a25-137">L'elemento `<DotNetCliToolReference>` è strutturato in modo analogo all'elemento `<PackageReference>`.</span><span class="sxs-lookup"><span data-stu-id="92a25-137">The `<DotNetCliToolReference>` element is structured in a similar way as the `<PackageReference>` element.</span></span> <span data-ttu-id="92a25-138">Il ripristino richiede l'ID del pacchetto contenente lo strumento e la relativa versione.</span><span class="sxs-lookup"><span data-stu-id="92a25-138">It needs the package ID of the package containing the tool and its version to be able to restore.</span></span>

### <a name="building-tools"></a><span data-ttu-id="92a25-139">Compilazione degli strumenti</span><span class="sxs-lookup"><span data-stu-id="92a25-139">Building tools</span></span>
<span data-ttu-id="92a25-140">Come affermato in precedenza, gli strumenti sono essenzialmente applicazioni console portabili.</span><span class="sxs-lookup"><span data-stu-id="92a25-140">As mentioned, tools are just portable console applications.</span></span> <span data-ttu-id="92a25-141">La compilazione degli strumenti è analoga a quella di qualsiasi applicazione console.</span><span class="sxs-lookup"><span data-stu-id="92a25-141">You build tools as you would build any other console application.</span></span>
<span data-ttu-id="92a25-142">Dopo la compilazione usare il comando [`dotnet pack`](dotnet-pack.md) per creare un pacchetto NuGet (file nupkg) contenente il codice, le informazioni sulle dipendenze e così via.</span><span class="sxs-lookup"><span data-stu-id="92a25-142">After you build it, you use the [`dotnet pack`](dotnet-pack.md) command to create a NuGet package (.nupkg file) that contains your code, information about its dependencies, and so on.</span></span> <span data-ttu-id="92a25-143">È possibile assegnare qualsiasi nome al pacchetto, ma l'applicazione in esso contenuta, ovvero il file binario dello strumento, deve essere conforme alla convenzione `dotnet-<command>` per consentire a `dotnet` di chiamare il pacchetto.</span><span class="sxs-lookup"><span data-stu-id="92a25-143">You can give any name to the package, but the application inside, the actual tool binary, has to conform to the convention of `dotnet-<command>` in order for `dotnet` to be able to invoke it.</span></span>

> [!NOTE]
> <span data-ttu-id="92a25-144">Nelle versioni precedenti alla RC3 degli strumenti della riga di comando di .NET Core, esiste un bug per il comando `dotnet pack` a causa del quale il file *.runtimeconfig.json* non viene incluso nel pacchetto dello strumento.</span><span class="sxs-lookup"><span data-stu-id="92a25-144">In pre-RC3 versions of the .NET Core command-line tools, the `dotnet pack` command had a bug that caused the *.runtimeconfig.json* to not be packed with the tool.</span></span> <span data-ttu-id="92a25-145">La mancanza di tale file causa errori in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="92a25-145">Lacking that file results in errors at runtime.</span></span> <span data-ttu-id="92a25-146">Se si verifica questo problema, assicurarsi di eseguire l'aggiornamento alla versione più recente degli strumenti e ritentare il comando `dotnet pack`.</span><span class="sxs-lookup"><span data-stu-id="92a25-146">If you encounter this behavior, be sure to update to the latest tooling and try the `dotnet pack` again.</span></span>

<span data-ttu-id="92a25-147">Poiché gli strumenti sono applicazioni portabili, per eseguire uno strumento l'utente deve avere la versione delle librerie .NET Core con le quali lo strumento è stato creato.</span><span class="sxs-lookup"><span data-stu-id="92a25-147">Since tools are portable applications, the user consuming the tool must have the version of the .NET Core libraries that the tool was built against in order to run the tool.</span></span> <span data-ttu-id="92a25-148">Qualsiasi altra dipendenza usata dallo strumento e non contenuta nelle librerie .NET Core viene ripristinata e posizionata nella cache NuGet.</span><span class="sxs-lookup"><span data-stu-id="92a25-148">Any other dependency that the tool uses and that is not contained within the .NET Core libraries is restored and placed in the NuGet cache.</span></span> <span data-ttu-id="92a25-149">Di conseguenza, l'intero strumento viene eseguito usando gli assembly delle librerie .NET Core oltre agli assembly della cache NuGet.</span><span class="sxs-lookup"><span data-stu-id="92a25-149">The entire tool is, therefore, run using the assemblies from the .NET Core libraries as well as assemblies from the NuGet cache.</span></span>

<span data-ttu-id="92a25-150">Gli strumenti di questo tipo hanno un grafico delle dipendenze completamente separato da quello del progetto che li usa.</span><span class="sxs-lookup"><span data-stu-id="92a25-150">These kinds of tools have a dependency graph that is completely separate from the dependency graph of the project that uses them.</span></span> <span data-ttu-id="92a25-151">Il processo di ripristino ripristina innanzitutto le dipendenze del progetto, quindi ogni strumento e le relative dipendenze.</span><span class="sxs-lookup"><span data-stu-id="92a25-151">The restore process first restores the project's dependencies and then restores each of the tools and their dependencies.</span></span>

<span data-ttu-id="92a25-152">Esempi più dettagliati e differenti combinazioni sono disponibili in [.NET Core CLI repo](https://github.com/dotnet/cli/tree/release/2.1/TestAssets/TestProjects) (Archivio .NET Core dell'interfaccia della riga di comando).</span><span class="sxs-lookup"><span data-stu-id="92a25-152">You can find richer examples and different combinations of this in the [.NET Core CLI repo](https://github.com/dotnet/cli/tree/release/2.1/TestAssets/TestProjects).</span></span>
<span data-ttu-id="92a25-153">Nello stesso archivio è possibile vedere anche l'[implementazione degli strumenti usati](https://github.com/dotnet/cli/tree/release/2.1/TestAssets/TestPackages).</span><span class="sxs-lookup"><span data-stu-id="92a25-153">You can also see the [implementation of tools used](https://github.com/dotnet/cli/tree/release/2.1/TestAssets/TestPackages) in the same repo.</span></span>

## <a name="custom-targets"></a><span data-ttu-id="92a25-154">Destinazioni personalizzate</span><span class="sxs-lookup"><span data-stu-id="92a25-154">Custom targets</span></span>

<span data-ttu-id="92a25-155">NuGet è in grado di [creare pacchetti di destinazioni MSBuild personalizzate e file props](/nuget/create-packages/creating-a-package#include-msbuild-props-and-targets-in-a-package).</span><span class="sxs-lookup"><span data-stu-id="92a25-155">NuGet has the capability to [package custom MSBuild targets and props files](/nuget/create-packages/creating-a-package#include-msbuild-props-and-targets-in-a-package).</span></span> <span data-ttu-id="92a25-156">Con lo spostamento di .NET Core per l'uso di MSBuild, lo stesso meccanismo di estendibilità viene ora applicato ai progetti .NET Core.</span><span class="sxs-lookup"><span data-stu-id="92a25-156">With the move of the .NET Core to use MSBuild, the same mechanism of extensibility now applies to .NET Core projects.</span></span> <span data-ttu-id="92a25-157">È opportuno usare questo tipo di estendibilità quando si vuole estendere il processo di compilazione, quando si vuole accedere a qualsiasi elemento di tale processo, ad esempio i file generati, quando si vuole esaminare la configurazione in cui viene chiamata la compilazione e così via.</span><span class="sxs-lookup"><span data-stu-id="92a25-157">You would use this type of extensibility when you want to extend the build process, or when you want to access any of the artifacts in the build process, such as generated files, or you want to inspect the configuration under which the build is invoked, and so on.</span></span>

<span data-ttu-id="92a25-158">Nell'esempio seguente è possibile visualizzare il file di progetto della destinazione con la sintassi `csproj`.</span><span class="sxs-lookup"><span data-stu-id="92a25-158">In the following example, you can see the target's project file using the `csproj` syntax.</span></span> <span data-ttu-id="92a25-159">Il codice indica al comando [`dotnet pack`](dotnet-pack.md) quali elementi aggiungere al pacchetto, posizionando i file di destinazioni e gli assembly nella cartella *build* all'interno del pacchetto.</span><span class="sxs-lookup"><span data-stu-id="92a25-159">This instructs the [`dotnet pack`](dotnet-pack.md) command what to package, placing the targets files as well as the assemblies into the *build* folder inside the package.</span></span> <span data-ttu-id="92a25-160">Si noti l'elemento `<ItemGroup>` con la proprietà `Label` impostata su `dotnet pack instructions` e la destinazione definita sotto tale elemento.</span><span class="sxs-lookup"><span data-stu-id="92a25-160">Notice the `<ItemGroup>` element that has the `Label` property set to `dotnet pack instructions`, and the Target defined beneath it.</span></span>

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <Description>Sample Packer</Description>
    <VersionPrefix>0.1.0-preview</VersionPrefix>
    <TargetFramework>netstandard1.3</TargetFramework>
    <DebugType>portable</DebugType>
    <AssemblyName>SampleTargets.PackerTarget</AssemblyName>
  </PropertyGroup>
  <ItemGroup>
    <EmbeddedResource Include="Resources\Pkg\dist-template.xml;compiler\resources\**\*" Exclude="bin\**;obj\**;**\*.xproj;packages\**" />
    <None Include="build\SampleTargets.PackerTarget.targets" />
  </ItemGroup>
  <ItemGroup Label="dotnet pack instructions">
    <Content Include="build\*.targets">
      <Pack>true</Pack>
      <PackagePath>build\</PackagePath>
    </Content>
  </ItemGroup>
  <Target Name="CollectRuntimeOutputs" BeforeTargets="_GetPackageFiles">
    <!-- Collect these items inside a target that runs after build but before packaging. -->
    <ItemGroup>
      <Content Include="$(OutputPath)\*.dll;$(OutputPath)\*.json">
        <Pack>true</Pack>
        <PackagePath>build\</PackagePath>
      </Content>
    </ItemGroup>
  </Target>
  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.DependencyModel" Version="1.0.1-beta-000933"/>
    <PackageReference Include="Microsoft.Build.Framework" Version="0.1.0-preview-00028-160627" />
    <PackageReference Include="Microsoft.Build.Utilities.Core" Version="0.1.0-preview-00028-160627" />
    <PackageReference Include="Newtonsoft.Json" Version="9.0.1" />
  </ItemGroup>
  <ItemGroup />
  <PropertyGroup Label="Globals">
    <ProjectGuid>463c66f0-921d-4d34-8bde-7c9d0bffaf7b</ProjectGuid>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(TargetFramework)' == 'netstandard1.3' ">
    <DefineConstants>$(DefineConstants);NETSTANDARD1_3</DefineConstants>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)' == 'Release' ">
    <DefineConstants>$(DefineConstants);RELEASE</DefineConstants>
  </PropertyGroup>
</Project>
```

<span data-ttu-id="92a25-161">L'utilizzo delle destinazioni personalizzate è reso possibile dalla specifica di un elemento `<PackageReference>` che punta al pacchetto e alla relativa versione all'interno del progetto in fase di estensione.</span><span class="sxs-lookup"><span data-stu-id="92a25-161">Consuming custom targets is done by providing a `<PackageReference>` that points to the package and its version inside the project that is being extended.</span></span> <span data-ttu-id="92a25-162">A differenza degli strumenti, il pacchetto di destinazione personalizzato non viene incluso nella chiusura delle dipendenze del progetto.</span><span class="sxs-lookup"><span data-stu-id="92a25-162">Unlike the tools, the custom targets package does get included into the consuming project's dependency closure.</span></span>

<span data-ttu-id="92a25-163">L'uso della destinazione personalizzata dipende esclusivamente dal modo in cui questa viene configurata.</span><span class="sxs-lookup"><span data-stu-id="92a25-163">Using the custom target depends solely on how you configure it.</span></span> <span data-ttu-id="92a25-164">Dal momento che si tratta di una destinazione MSBuild, può dipendere da una destinazione data, essere eseguita dopo un'altra destinazione e anche essere chiamata manualmente mediante il comando `dotnet msbuild -t:<target-name>`.</span><span class="sxs-lookup"><span data-stu-id="92a25-164">Since it's an MSBuild target, it can depend on a given target, run after another target and can also be manually invoked using the `dotnet msbuild -t:<target-name>` command.</span></span>

<span data-ttu-id="92a25-165">Tuttavia per offrire agli utenti una migliore esperienza d'uso è possibile combinare strumenti in base al progetto e destinazioni personalizzate.</span><span class="sxs-lookup"><span data-stu-id="92a25-165">However, if you want to provide a better user experience to your users, you can combine per-project tools and custom targets.</span></span> <span data-ttu-id="92a25-166">In questo scenario lo strumento in base al progetto si limita ad accettare qualsiasi parametro necessario e lo traduce nella chiamata a [`dotnet msbuild`](dotnet-msbuild.md) richiesta, che esegue la destinazione.</span><span class="sxs-lookup"><span data-stu-id="92a25-166">In this scenario, the per-project tool would essentially just accept whatever needed parameters and would translate that into the required [`dotnet msbuild`](dotnet-msbuild.md) invocation that would execute the target.</span></span> <span data-ttu-id="92a25-167">È possibile visualizzare un esempio di questo tipo di sinergia nel repository degli [esempi di MVP Summit 2016 Hackathon](https://github.com/dotnet/MVPSummitHackathon2016) nel progetto [`dotnet-packer`](https://github.com/dotnet/MVPSummitHackathon2016/tree/master/dotnet-packer).</span><span class="sxs-lookup"><span data-stu-id="92a25-167">You can see a sample of this kind of synergy on the [MVP Summit 2016 Hackathon samples](https://github.com/dotnet/MVPSummitHackathon2016) repo in the [`dotnet-packer`](https://github.com/dotnet/MVPSummitHackathon2016/tree/master/dotnet-packer) project.</span></span>

## <a name="path-based-extensibility"></a><span data-ttu-id="92a25-168">Estendibilità basata su PATH</span><span class="sxs-lookup"><span data-stu-id="92a25-168">PATH-based extensibility</span></span>
<span data-ttu-id="92a25-169">L'estendibilità basata sul PATH viene in genere usata per i computer di sviluppo in cui è necessario disporre di uno strumento in grado di coprire concettualmente più di un singolo progetto.</span><span class="sxs-lookup"><span data-stu-id="92a25-169">PATH-based extensibility is usually used for development machines where you need a tool that conceptually covers more than a single project.</span></span> <span data-ttu-id="92a25-170">Il principale svantaggio di questo meccanismo di estensione sta nel fatto che è vincolato al computer in cui è presente lo strumento.</span><span class="sxs-lookup"><span data-stu-id="92a25-170">The main drawback of this extension mechanism is that it's tied to the machine where the tool exists.</span></span> <span data-ttu-id="92a25-171">Se si vuole usare questo meccanismo in un altro computer, è necessario eseguire un'attività di distribuzione.</span><span class="sxs-lookup"><span data-stu-id="92a25-171">If you need it on another machine, you would have to deploy it.</span></span>

<span data-ttu-id="92a25-172">Questo modello di estendibilità del set di strumenti dell'interfaccia della riga di comando è molto semplice.</span><span class="sxs-lookup"><span data-stu-id="92a25-172">This pattern of CLI toolset extensibility is very simple.</span></span> <span data-ttu-id="92a25-173">Come illustrato in [.NET Core CLI overview](index.md) (Panoramica sull'interfaccia della riga di comando di .NET Core), il driver `dotnet` può eseguire qualsiasi comando denominato in base alla convenzione `dotnet-<command>`.</span><span class="sxs-lookup"><span data-stu-id="92a25-173">As covered in the [.NET Core CLI overview](index.md), `dotnet` driver can run any command that is named after the `dotnet-<command>` convention.</span></span> <span data-ttu-id="92a25-174">La logica di risoluzione predefinita verifica diverse posizioni e infine sceglie il percorso specificato dal PATH di sistema.</span><span class="sxs-lookup"><span data-stu-id="92a25-174">The default resolution logic first probes several locations and finally falls back to the system PATH.</span></span> <span data-ttu-id="92a25-175">Se il comando richiesto è presente nel PATH di sistema ed è un file binario che è possibile richiamare, il driver `dotnet` lo richiamerà.</span><span class="sxs-lookup"><span data-stu-id="92a25-175">If the requested command exists in the system PATH and is a binary that can be invoked, `dotnet` driver will invoke it.</span></span>

<span data-ttu-id="92a25-176">Il file deve essere un file eseguibile.</span><span class="sxs-lookup"><span data-stu-id="92a25-176">The file must be executable.</span></span> <span data-ttu-id="92a25-177">Nei sistemi Unix può trattarsi di qualsiasi file con il bit eseguibile impostato tramite `chmod +x`.</span><span class="sxs-lookup"><span data-stu-id="92a25-177">On Unix systems, this means anything that has the execute bit set via `chmod +x`.</span></span> <span data-ttu-id="92a25-178">In Windows è possibile usare file *cmd*.</span><span class="sxs-lookup"><span data-stu-id="92a25-178">On Windows, you can use *cmd* files.</span></span>

<span data-ttu-id="92a25-179">Di seguito è riportata un'implementazione molto semplice di uno strumento "Hello World".</span><span class="sxs-lookup"><span data-stu-id="92a25-179">Let's take a look at the very simple implementation of a "Hello World" tool.</span></span> <span data-ttu-id="92a25-180">Si usa sia `bash` sia `cmd` in Windows.</span><span class="sxs-lookup"><span data-stu-id="92a25-180">We will use both `bash` and `cmd` on Windows.</span></span>
<span data-ttu-id="92a25-181">Il comando che segue trasmette semplicemente "Hello World" alla console.</span><span class="sxs-lookup"><span data-stu-id="92a25-181">The following command will simply echo "Hello World" to the console.</span></span>

```bash
#!/bin/bash

echo "Hello World!"
```

```cmd
echo "Hello World"
```

<span data-ttu-id="92a25-182">Nei sistemi MacOS è possibile salvare lo script come `dotnet-hello` e impostarne il bit eseguibile con `chmod +x dotnet-hello`.</span><span class="sxs-lookup"><span data-stu-id="92a25-182">On macOS, we can save this script as `dotnet-hello` and set its executable bit with `chmod +x dotnet-hello`.</span></span> <span data-ttu-id="92a25-183">È quindi possibile creare un collegamento simbolico in `/usr/local/bin` usando il comando `ln -s <full_path>/dotnet-hello /usr/local/bin/`.</span><span class="sxs-lookup"><span data-stu-id="92a25-183">We can then create a symbolic link to it in `/usr/local/bin` using the command `ln -s <full_path>/dotnet-hello /usr/local/bin/`.</span></span> <span data-ttu-id="92a25-184">In questo modo sarà possibile chiamare il comando usando la sintassi `dotnet hello`.</span><span class="sxs-lookup"><span data-stu-id="92a25-184">This will make it possible to invoke the command using the `dotnet hello` syntax.</span></span>

<span data-ttu-id="92a25-185">In Windows è possibile salvare lo script come `dotnet-hello.cmd` e inserirlo in una posizione inclusa in un percorso di sistema (o è possibile aggiungerlo a una cartella che si trova già in tale percorso).</span><span class="sxs-lookup"><span data-stu-id="92a25-185">On Windows, we can save this script as `dotnet-hello.cmd` and put it in a location that is in a system path (or you can add it to a folder that is already in the path).</span></span> <span data-ttu-id="92a25-186">In seguito è sufficiente usare `dotnet hello` per eseguire questo esempio.</span><span class="sxs-lookup"><span data-stu-id="92a25-186">After this, you can just use `dotnet hello` to run this example.</span></span>
